[
  {
    "serial_no": 1,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.DataSource;\nimport com.zimbra.cs.datasource.DataSourceManager;\nimport com.zimbra.cs.datasource.imap.ImapFolder;\nimport com.zimbra.cs.datasource.imap.ImapFolderCollection;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.mailbox.Mailbox;\n\npublic class DbImapFolder {\n\n    static final String TABLE_IMAP_FOLDER = \"imap_folder\";\n\n\n    public static ImapFolder getImapFolder(Mailbox mbox, DataSource ds, int itemId)\n        throws ServiceException {\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                conn = DbPool.getConnection(mbox);\n                stmt = conn.prepareStatement(\n                    \"SELECT local_path, remote_path, uid_validity\" +\n                    \" FROM \" + getTableName(mbox) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"item_id = ? \");\n                int pos = DbMailItem.setMailboxId(stmt, mbox, 1);\n                stmt.setInt(pos, itemId);\n                rs = stmt.executeQuery();\n                if (!rs.next()) return null;\n                String localPath = rs.getString(\"local_path\");\n                String remotePath = rs.getString(\"remote_path\");\n                Long uidValidity = rs.getLong(\"uid_validity\");\n                if (rs.wasNull()) {\n                    uidValidity = null;\n                }\n                return new ImapFolder(ds, itemId, remotePath, localPath, uidValidity);\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to get IMAP folder data\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n    /**\n     * Returns a <tt>List</tt> of <tt>ImapFolders</tt> for the given <tt>DataSource</tt>.\n     */\n    public static ImapFolderCollection getImapFolders(Mailbox mbox, DataSource ds)\n    throws ServiceException {\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n            ImapFolderCollection imapFolders = new ImapFolderCollection();\n\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                conn = DbPool.getConnection(mbox);\n\n                stmt = conn.prepareStatement(\n                    \"SELECT item_id, local_path, remote_path, uid_validity\" +\n                    \" FROM \" + getTableName(mbox) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"data_source_id = ?\");\n                int pos = 1;\n                pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                stmt.setString(pos++, ds.getId());\n                rs = stmt.executeQuery();\n\n                while (rs.next()) {\n                    int itemId = rs.getInt(\"item_id\");\n                    String localPath = rs.getString(\"local_path\");\n                    String remotePath = rs.getString(\"remote_path\");\n                    Long uidValidity = rs.getLong(\"uid_validity\");\n                    if (rs.wasNull())\n                        uidValidity = null;\n\n                    ImapFolder imapFolder = new ImapFolder(ds, itemId, remotePath, localPath, uidValidity);\n                    imapFolders.add(imapFolder);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to get IMAP folder data\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n\n            ZimbraLog.datasource.debug(\"Found %d folders for %s\", imapFolders.size(), ds);\n            return imapFolders;\n        }\n    }\n\n    public static ImapFolder createImapFolder(Mailbox mbox, DataSource ds, int itemId,\n                                              String localPath, String remotePath, long uidValidity)\n    throws ServiceException {\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            try {\n                conn = DbPool.getConnection(mbox);\n\n                ZimbraLog.datasource.debug(\n                    \"createImapFolder: itemId = %d, localPath = %s, remotePath = %s, uidValidity = %d\",\n                itemId, localPath, remotePath, uidValidity);\n                stmt = conn.prepareStatement(\n                    \"INSERT INTO \" + getTableName(mbox) +\n                    \" (\" + DbMailItem.MAILBOX_ID + \"item_id, data_source_id, local_path, remote_path, uid_validity) \" +\n                    \"VALUES (\"+DbMailItem.MAILBOX_ID_VALUE+\"?, ?, ?, ?, ?)\");\n                int pos = 1;\n                pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, itemId);\n                stmt.setString(pos++, ds.getId());\n                stmt.setString(pos++, localPath);\n                stmt.setString(pos++, remotePath);\n                stmt.setLong(pos++, uidValidity);\n                stmt.executeUpdate();\n                conn.commit();\n                return new ImapFolder(ds, itemId, remotePath, localPath, uidValidity);\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to store IMAP message data\", e);\n            } finally {\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n    /**\n     * Updates the database with the latest values stored in this <tt>ImapFolder</tt>.\n     */\n    public static void updateImapFolder(ImapFolder imapFolder)\n    throws ServiceException {\n        Mailbox mbox = DataSourceManager.getInstance().getMailbox(imapFolder.getDataSource());\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            try {\n                conn = DbPool.getConnection(mbox);\n\n                stmt = conn.prepareStatement(\n                    \"UPDATE \" + getTableName(mbox) +\n                    \" SET local_path = ?, remote_path = ?, uid_validity = ?\" +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"data_source_id = ? AND item_id = ?\");\n                int pos = 1;\n                stmt.setString(pos++, imapFolder.getLocalPath());\n                stmt.setString(pos++, imapFolder.getRemoteId());\n                stmt.setLong(pos++, imapFolder.getUidValidity());\n                pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                stmt.setString(pos++, imapFolder.getDataSource().getId());\n                stmt.setInt(pos++, imapFolder.getItemId());\n                int numRows = stmt.executeUpdate();\n                if (numRows != 1) {\n                    throw ServiceException.FAILURE(\n                        String.format(\"Incorrect number of rows updated (%d) for %s\",\n                            numRows, imapFolder), null);\n                }\n                conn.commit();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to update \" + imapFolder, e);\n            } finally {\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n    /**\n     * Deletes all IMAP message data for the given mailbox/data source.\n     */\n    public static void deleteImapData(Mailbox mbox, String dataSourceId)\n    throws ServiceException {\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n            ZimbraLog.datasource.info(\"Deleting IMAP data for DataSource %s\", dataSourceId);\n\n            if (StringUtil.isNullOrEmpty(dataSourceId))\n                return;\n\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            try {\n                // Note: data in imap_message gets deleted implicitly by the\n                // foreign key cascading delete\n                conn = DbPool.getConnection(mbox);\n\n                stmt = conn.prepareStatement(\n                    \"DELETE FROM \" + getTableName(mbox) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"data_source_id = ?\");\n                int pos = 1;\n                pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                stmt.setString(pos++, dataSourceId);\n                stmt.executeUpdate();\n                conn.commit();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to delete IMAP data\", e);\n            } finally {\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n    /**\n     * Deletes IMAP folder and message data for the given folder.\n     */\n    public static void deleteImapFolder(Mailbox mbox, DataSource ds, ImapFolder folder)\n    throws ServiceException {\n        synchronized (DbMailItem.getSynchronizer(mbox)) {\n            ZimbraLog.datasource.info(\"Deleting IMAP data for %s in %s\", folder, ds);\n\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            try {\n                // Note: data in imap_message gets deleted implicitly by the\n                // foreign key cascading delete\n                conn = DbPool.getConnection(mbox);\n\n                stmt = conn.prepareStatement(\n                    \"DELETE FROM \" + getTableName(mbox) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"data_source_id = ? and item_id = ?\");\n                int pos = 1;\n                pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                stmt.setString(pos++, ds.getId());\n                stmt.setInt(pos++, folder.getItemId());\n                stmt.executeUpdate();\n                conn.commit();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to delete IMAP folder\", e);\n            } finally {\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n\n    public static String getTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_IMAP_FOLDER);\n    }\n\n    public static String getTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_IMAP_FOLDER);\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "DbImapFolder.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 2,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        return false;\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override public String scriptCommandDelimiter() {\n        return \"%\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        LinkedList<java.sql.Connection> connections = new LinkedList<java.sql.Connection>();\n        for (int i = 0; i < poolSize; i++) {\n            java.sql.Connection conn = pool.getConnection();\n            if (i == 0)\n                ZimbraLog.dbconn.info(\"sqlite driver running in \" + conn.getMetaData().getDriverVersion() + \" mode\");\n\n            try {\n                conn.setAutoCommit(true);\n                pragma(conn, \"synchronous\", \"NORMAL\");\n                pragma(conn, \"fullfsync\", \"0\");\n                pragma(conn, \"journal_mode\", \"PERSIST\");\n//                pragma(conn, \"locking_mode\", \"EXCLUSIVE\");\n                pragma(conn, \"legacy_file_format\", \"OFF\");\n//                pragma(conn, \"read_uncommitted\", \"1\");\n            } finally {\n                connections.add(conn);\n                conn.setAutoCommit(false);\n            }\n        }\n        for (java.sql.Connection conn : connections)\n            conn.close();\n\n        super.startup(pool, poolSize);\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private static final int CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = 7;\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(CONNECTION_POOL_SIZE);\n\n    @SuppressWarnings(\"unchecked\")\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(conn.getConnection());\n    }\n\n    private void recordAttachedDatabase(Connection conn, String dbname) {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(conn.getConnection(), attachedDBs);\n        }\n    }\n\n    @Override void registerDatabaseInterest(Connection conn, String dbname) throws SQLException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                if (detachDatabase(conn, it.next()))\n                    it.remove();\n            }\n        }\n\n        attachDatabase(conn, dbname);\n        recordAttachedDatabase(conn, dbname);\n    }\n\n    private void attachDatabase(Connection conn, String dbname) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.sqltrace.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // XXX: since it's so easy to end up with an empty SQLite database, make sure that the tables we want are actually in there\n        //   (yes, this assumes that we're looking for a MBOXGROUP database, which is beyond the scope of this method's contract)\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + dbname + \".sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= DbMailbox.sTables.length) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"foo\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.sqltrace.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    private static final String DATABASE_DIRECTORY = System.getProperty(\"derby.system.home\", LC.zimbra_home.value() + File.separator + \"sqlite\");\n\n    static String getDatabaseFilename(String dbname) {\n        return DATABASE_DIRECTORY + File.separator + dbname + \".db\";\n    }\n\n    static final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            ZimbraLog.misc.debug(\"Setting connection pool size to \" + mPoolSize);\n        }\n\n        private static Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            if (output != null)\n                output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6927445ff7c09363d1fa2fbcedfee3a163e311d6",
    "commit_msg": "(split)bug: 29563\n\nSQLite connection pool size is now controlled by the localconfig key \"sqlite_pool_size\" (defaults to 12).\n\nIf you want to set extra PRAGMAs on SQLite DB connections, put them in a standard-format Java properties file and point the localconfig key \"sqlite_pragma_file\" at that file.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 111948",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 3,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.cs.mailbox.ScheduledTask;\n\n/**\n * Database persistence code for <tt>DataSourceTask</tt>s.\n *\n * @author bburtin\n */\npublic class DbScheduledTask {\n    \n    public static String TABLE_SCHEDULED_TASK = \"scheduled_task\";\n    \n    /**\n     * Saves the given task to the database.\n     */\n    public static void createTask(Connection conn, ScheduledTask task)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.scheduler.debug(\"Creating %s\", task);\n\n        try {\n            stmt = conn.prepareStatement(\n                \"INSERT INTO \" + TABLE_SCHEDULED_TASK  +\n                \" (class_name, name, mailbox_id, exec_time, interval_millis, metadata) \" +\n                \"VALUES (?, ?, ?, ?, ?, ?)\");\n            stmt.setString(1, task.getClass().getName());\n            stmt.setString(2, task.getName());\n            stmt.setInt(3, task.getMailboxId());\n            stmt.setTimestamp(4, DbUtil.dateToTimestamp(task.getExecTime()));\n            if (task.getIntervalMillis() > 0) {\n                stmt.setLong(5, task.getIntervalMillis());\n            } else {\n                stmt.setNull(5, Types.INTEGER);\n            }\n            stmt.setString(6, getEncodedMetadata(task));\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to create \" + task, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    /**\n     * Retrieves scheduled tasks from the database.\n     * \n     * @param className the <tt>ScheduledTask</tt> class name, or <tt>null</tt>\n     * for all classes\n     * @param mailboxId the mailbox ID, or <tt>0</tt> for all mailboxes\n     */\n    public static List<ScheduledTask> getTasks(String className, int mailboxId)\n    throws ServiceException {\n        ZimbraLog.scheduler.debug(\"Retrieving tasks for class %s, mailbox %d\", className, mailboxId);\n        \n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        List<ScheduledTask> tasks = new ArrayList<ScheduledTask>();\n\n        try {\n            conn = DbPool.getConnection();\n            String sql =\n                \"SELECT class_name, name, mailbox_id, exec_time, interval_millis, metadata \" +\n                \"FROM \" + TABLE_SCHEDULED_TASK;\n            if (className != null) {\n                sql += \" WHERE class_name = ?\";\n            }\n            if (mailboxId > 0) {\n                if (className == null) {\n                    sql += \" WHERE mailbox_id = ?\";\n                } else {\n                    sql += \" AND mailbox_id = ?\";\n                }\n            }\n            stmt = conn.prepareStatement(sql);\n            int i = 1;\n            if (className != null) {\n                stmt.setString(i++, className);\n            }\n            if (mailboxId > 0) {\n                stmt.setInt(i++, mailboxId);\n            }\n\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                className = rs.getString(\"class_name\");\n                String name = rs.getString(\"name\");\n                ScheduledTask task = null;\n                \n                // Instantiate task\n                try {\n                    Object obj = Class.forName(className).newInstance();\n                    if (obj instanceof ScheduledTask) {\n                        task = (ScheduledTask) obj;\n                    } else {\n                        ZimbraLog.scheduler.warn(\"Class %s is not an instance of ScheduledTask for task %s\",\n                            className, name);\n                        continue;\n                    }\n                } catch (Exception e) {\n                    ZimbraLog.scheduler.warn(\"Unable to instantiate class %s for task %s.  \" +\n                        \"Class must be an instance of %s and have a constructor with no arguments.\",\n                        className, name, ScheduledTask.class.getSimpleName(), e);\n                    continue;\n                }\n                \n                // Set member vars\n                task.setMailboxId(rs.getInt(\"mailbox_id\"));\n                task.setExecTime(DbUtil.timestampToDate(rs.getTimestamp(\"exec_time\")));\n                task.setIntervalMillis(rs.getLong(\"interval_millis\"));\n                \n                try {\n                    setProperties(task, rs.getString(\"metadata\"));\n                } catch (ServiceException e) {\n                    ZimbraLog.scheduler.warn(\"Unable to read metadata for %s.  Not scheduling this task.\", task, e);\n                    continue;\n                }\n                \n                tasks.add(task);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get all DataSourceTasks\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n\n        ZimbraLog.scheduler.info(\"Loaded %d scheduled data source tasks\", tasks.size());\n        return tasks;\n    }\n\n    public static void updateTask(Connection conn, ScheduledTask task)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.scheduler.debug(\"Updating %s\", task);\n\n        try {\n            stmt = conn.prepareStatement(\n                \"UPDATE  \" + TABLE_SCHEDULED_TASK  +\n                \" SET mailbox_id = ?, exec_time = ?, interval_millis = ?, metadata = ? \" +\n                \"WHERE class_name = ? AND name = ?\");\n            stmt.setInt(1, task.getMailboxId());\n            stmt.setTimestamp(2, DbUtil.dateToTimestamp(task.getExecTime()));\n            if (task.getIntervalMillis() > 0) {\n                stmt.setLong(3, task.getIntervalMillis());\n            } else {\n                stmt.setNull(3, Types.INTEGER);\n            }\n            stmt.setString(4, getEncodedMetadata(task));\n            stmt.setString(5, task.getClass().getName());\n            stmt.setString(6, task.getName());\n\n            int numRows = stmt.executeUpdate();\n            if (numRows != 1) {\n                String msg = String.format(\"Unexpected number of rows (%d) updated for %s\", numRows, task);\n                throw ServiceException.FAILURE(msg, null);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to update \" + task, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void deleteTask(String className, String taskName)\n    throws ServiceException {\n        Connection conn = null;\n        try {\n            conn = DbPool.getConnection();\n            deleteTask(conn, className, taskName);\n            conn.commit();\n        } finally {\n            DbPool.quietClose(conn);\n        }\n    }\n    \n    public static void deleteTask(Connection conn, String className, String taskName)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.scheduler.debug(\"Deleting scheduled task from the database.  className=%s, taskName=%s\",\n            className, taskName);\n\n        try {\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + TABLE_SCHEDULED_TASK  +\n                \" WHERE class_name = ? AND name = ?\");\n            stmt.setString(1, className);\n            stmt.setString(2, taskName);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete scheduled task: className=\" +\n                className+ \", taskName=\" + taskName, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    private static String getEncodedMetadata(ScheduledTask task) {\n        boolean hasProperties = false;\n        Metadata metadata = new Metadata();\n        for (String key : task.getPropertyNames()) {\n            hasProperties = true;\n            metadata.put(key, task.getProperty(key));\n        }\n        if (!hasProperties) {\n            return null;\n        }\n        return metadata.toString();\n    }\n    \n    private static void setProperties(ScheduledTask task, String encodedMetadata)\n    throws ServiceException {\n        if (StringUtil.isNullOrEmpty(encodedMetadata)) {\n            return;\n        }\n        \n        Metadata metadata = new Metadata(encodedMetadata);\n        Map map = metadata.asMap();\n        for (Object key : map.keySet()) {\n            Object value = map.get(key);\n            if (key instanceof String && value instanceof String) {\n                task.setProperty((String) key, (String) value);\n            }\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "d679a9a78b98b3eed2b7b13d2c34c0e3a0b60f27",
    "commit_msg": "(split)bug: 37476\n\nEnclose all database accesses with appropriate synchronization blocks to avoid conflicts in the case where the underlying database does not support row-level locking.  In the case where the database *does* have this support (i.e. everything but SQLite), we're synchronizing on a new Object, which shouldn't slow things down too much.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=37476\n\nCopied from Perforce\n Change: 161770",
    "original_file": "DbScheduledTask.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 4,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Oct 28, 2004\n */\npackage com.zimbra.cs.db;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ByteUtil;\nimport com.zimbra.cs.util.Config;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\n\n/**\n * @author kchen\n */\npublic class DbMailbox {\n\n    public static final int CI_ID;\n    public static final int CI_GROUP_ID;\n    public static final int CI_ACCOUNT_ID;\n    public static final int CI_INDEX_VOLUME_ID;\n    public static final int CI_ITEM_ID_CHECKPOINT;\n    public static final int CI_CONTACT_COUNT;\n    public static final int CI_SIZE_CHECKPOINT;\n    public static final int CI_CHANGE_CHECKPOINT;\n    public static final int CI_TRACKING_SYNC;\n    public static final int CI_TRACKING_IMAP;\n    public static final int CI_LAST_BACKUP_AT;\n    public static final int CI_COMMENT;\n    public static final int CI_LAST_SOAP_ACCESS;\n    public static final int CI_NEW_MESSAGES;\n    public static final int CI_IDX_DEFERRED_COUNT;\n\n    static {\n        int pos = 1;\n        // Order must match the order of column definition in zimbra.mailbox\n        // table in db.sql script.\n        CI_ID = pos++;\n        CI_GROUP_ID = pos++;\n        CI_ACCOUNT_ID = pos++;\n        CI_INDEX_VOLUME_ID = pos++;\n        CI_ITEM_ID_CHECKPOINT = pos++;\n        CI_CONTACT_COUNT = pos++;\n        CI_SIZE_CHECKPOINT = pos++;\n        CI_CHANGE_CHECKPOINT = pos++;\n        CI_TRACKING_SYNC = pos++;\n        CI_TRACKING_IMAP = pos++;\n        CI_LAST_BACKUP_AT = pos++;\n        CI_COMMENT = pos++;\n        CI_LAST_SOAP_ACCESS = pos++;\n        CI_NEW_MESSAGES = pos++;\n        CI_IDX_DEFERRED_COUNT = pos++;\n    }\n\n    public static final int CI_METADATA_MAILBOX_ID = 1;\n    public static final int CI_METADATA_SECTION    = 2;\n    public static final int CI_METADATA_METADATA   = 3;\n\n    public static final int CI_SCHEDULED_TASK_MAILBOX_ID = 3;\n    public static final int CI_OUT_OF_OFFICE_MAILBOX_ID = 1;\n\n    static String DB_PREFIX_MAILBOX_GROUP = \"mboxgroup\";\n\n    private static int MAX_COMMENT_LENGTH = 255;\n\n    public static class NewMboxId {\n        public int id;\n        public int groupId;\n    }\n\n    public synchronized static NewMboxId createMailbox(Connection conn, int mailboxId, String accountId, String comment, int lastBackupAt)\n    throws ServiceException {\n        String limitClause = Db.supports(Db.Capability.LIMIT_CLAUSE) ? \" ORDER BY index_volume_id LIMIT 1\" : \"\";\n        boolean explicitId = (mailboxId != Mailbox.ID_AUTO_INCREMENT);\n        if (!explicitId) {\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                stmt = conn.prepareStatement(\"SELECT next_mailbox_id FROM current_volumes\" + limitClause);\n                rs = stmt.executeQuery();\n                if (rs.next())\n                    mailboxId = rs.getInt(1);\n                else\n                    throw ServiceException.FAILURE(\"Unable to assign next new mailbox id\", null);\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"determining next new mailbox id\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n        }\n        int groupId = getMailboxGroupId(mailboxId);\n        // Make sure the group database exists before we start doing DMLs.\n        createMailboxDatabase(conn, mailboxId, groupId);\n\n        if (comment != null && comment.length() > MAX_COMMENT_LENGTH)\n            comment = comment.substring(0, MAX_COMMENT_LENGTH);\n        if (comment != null)\n            removeFromDeletedAccount(conn, comment);\n\n        NewMboxId ret = new NewMboxId();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"INSERT INTO mailbox\" +\n                    \"(account_id, id, group_id, index_volume_id, item_id_checkpoint, last_backup_at, comment)\" +\n                    \" SELECT ?, ?, 0, index_volume_id, \" + (Mailbox.FIRST_USER_ID - 1) + \", ?, ?\" +\n                    \" FROM current_volumes\" + limitClause);\n            int attr = 1;\n            stmt.setString(attr++, accountId);\n            stmt.setInt(attr++, mailboxId);\n            if (lastBackupAt >= 0)\n                stmt.setInt(attr++, lastBackupAt);\n            else\n                stmt.setNull(attr++, Types.INTEGER);\n            stmt.setString(attr++, comment);\n            stmt.executeUpdate();\n            stmt.close();\n            stmt = null;\n\n            if (explicitId) {\n                stmt = conn.prepareStatement(\n                        \"UPDATE current_volumes SET next_mailbox_id = ? + 1 WHERE next_mailbox_id <= ?\");\n                stmt.setInt(1, mailboxId);\n                stmt.setInt(2, mailboxId);\n            } else {\n                stmt = conn.prepareStatement(\n                        \"UPDATE current_volumes SET next_mailbox_id = next_mailbox_id + 1\");\n            }\n            stmt.executeUpdate();\n            stmt.close();\n            stmt = null;\n\n            ret.id = mailboxId;\n            ret.groupId = groupId;\n            if (explicitId)\n                return ret;\n\n            stmt = conn.prepareStatement(\"UPDATE mailbox SET group_id = ? WHERE id = ?\");\n            stmt.setInt(1, ret.groupId);\n            stmt.setInt(2, ret.id);\n            stmt.executeUpdate();\n            stmt.close();\n            stmt = null;\n\n            return ret;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new mailbox row for account \" + accountId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Create a database for the specified mailbox.\n     * \n     * @throws ServiceException if the database creation fails */\n    public static void createMailboxDatabase(Connection conn, int mailboxId, int groupId)\n    throws ServiceException {\n        ZimbraLog.mailbox.debug(\"createMailboxDatabase(\" + mailboxId + \")\");\n\n        File file = Config.getPathRelativeToZimbraHome(\"db/create_database.sql\");\n\n        PreparedStatement stmt = null;\n        try {\n            String dbName = getDatabaseName(groupId);\n            if (Db.getInstance().databaseExists(conn, dbName)) {\n                // If database didn't exist we would end up doing CREATE DATABASE which does implicit commit.\n                // Let's do an explicit here so pending transactions always committed on exit from this method\n                // whether we create a database or not.\n                conn.commit();\n                return;\n            }\n\n            // Create the new database\n            ZimbraLog.mailbox.info(\"Creating database \" + dbName);\n            Db.getInstance().registerDatabaseInterest(conn, dbName);\n\n            String template = new String(ByteUtil.getContent(file));\n            Map<String, String> vars = new HashMap<String, String>();\n            vars.put(\"DATABASE_NAME\", dbName);\n            String script = StringUtil.fillTemplate(template, vars);\n            DbUtil.executeScript(conn, new StringReader(script));\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"unable to read SQL statements from \" + file.getPath(), e);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"createMailboxDatabase(\" + mailboxId + \")\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // Tables are listed in order of creation.  dropMailboxFromGroup() drops them\n    // in reverse order.\n    static final String[] sTables = new String[] {\n            DbMailItem.TABLE_MAIL_ITEM,\n            DbMailItem.TABLE_OPEN_CONVERSATION,\n            DbMailItem.TABLE_APPOINTMENT,\n            DbMailItem.TABLE_REVISION,\n            DbMailItem.TABLE_TOMBSTONE,\n            DbImapFolder.TABLE_IMAP_FOLDER,\n            DbImapMessage.TABLE_IMAP_MESSAGE,\n            DbPop3Message.TABLE_POP3_MESSAGE\n    };\n\n    private static void dropMailboxFromGroup(Connection conn, Mailbox mbox)\n    throws ServiceException {\n        int mailboxId = mbox.getId();\n        int groupId = mbox.getSchemaGroupId();        \n        ZimbraLog.mailbox.info(\"Clearing contents of mailbox \" + mailboxId + \", group \" + groupId);\n\n        String dbname = getDatabaseName(mbox);\n\n        if (DebugConfig.disableMailboxGroups && Db.supports(Db.Capability.FILE_PER_DATABASE)) {\n            Db.getInstance().deleteDatabaseFile(dbname);\n            return;\n        }\n\n        if (conn == null)\n            conn = mbox.getOperationConnection();\n\n        try {\n            if (Db.supports(Db.Capability.DISABLE_CONSTRAINT_CHECK))\n                conn.disableForeignKeyConstraints();\n\n            // Delete in reverse order.\n            for (int i = sTables.length - 1; i >= 0; i--) {\n                String table = dbname + \".\" + sTables[i];\n                PreparedStatement stmt = null;\n                try {\n                    stmt = conn.prepareStatement(\"DELETE FROM \" + table +\n                            (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = \" + mailboxId));\n                    stmt.executeUpdate();\n                } finally {\n                    DbPool.closeStatement(stmt);\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"dropMailboxFromGroup(\" + mailboxId + \")\", e);\n        } finally {\n            try {\n                if (Db.supports(Db.Capability.DISABLE_CONSTRAINT_CHECK))\n                    conn.enableForeignKeyConstraints();\n            } catch (ServiceException e) {\n                ZimbraLog.mailbox.error(\"Error enabling foreign key constraints during mailbox deletion\", e);\n                // Don't rethrow to avoid masking any exception from DELETE statements.\n            }\n        }\n    }\n\n    public static void clearMailboxContent(Mailbox mbox) throws ServiceException {\n        clearMailboxContent(null, mbox);\n    }\n\n    public static void clearMailboxContent(Connection conn, Mailbox mbox) throws ServiceException {\n        dropMailboxFromGroup(conn, mbox);\n    }\n\n    public static void renameMailbox(Connection conn, Mailbox mbox, String newName) throws ServiceException {\n        int mailboxId = mbox.getId();\n        ZimbraLog.mailbox.info(\"Renaming email/comment of mailbox \" + mailboxId + \" to \" + newName);\n\n        if (conn == null)\n            conn = mbox.getOperationConnection();\n\n        try {\n            PreparedStatement stmt = null;\n            try {\n                stmt = conn.prepareStatement(\"UPDATE mailbox SET comment = ?, last_backup_at = NULL WHERE id = ?\");\n                stmt.setString(1, newName);\n                stmt.setInt(2, mailboxId);\n                stmt.executeUpdate();\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"renameMailbox(\" + mailboxId + \")\", e);\n        }\n    }\n\n    public static void clearMailboxContactCount(Mailbox mbox) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE mailbox SET contact_count = NULL WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"clearing contact count for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void recordLastSoapAccess(Mailbox mbox) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE mailbox SET last_soap_access = ? WHERE id = ?\");\n            stmt.setInt(1, (int) (mbox.getLastSoapAccessTime() / 1000));\n            stmt.setInt(2, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating last SOAP access time for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void updateMailboxStats(Mailbox mbox) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE mailbox\" +\n                    \" SET item_id_checkpoint = ?, contact_count = ?, change_checkpoint = ?, size_checkpoint = ?, new_messages = ?, idx_deferred_count = ?\" +\n                    \" WHERE id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, mbox.getLastItemId());\n            stmt.setInt(pos++, mbox.getContactCount());\n            stmt.setInt(pos++, mbox.getLastChangeID());\n            stmt.setLong(pos++, mbox.getSize());\n            stmt.setInt(pos++, mbox.getRecentMessageCount());\n            stmt.setInt(pos++, mbox.getIndexDeferredCount());\n            stmt.setInt(pos++, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating mailbox statistics for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void startTrackingSync(Mailbox mbox) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE mailbox SET tracking_sync = ? WHERE id = ? AND tracking_sync <= 0\");\n            stmt.setInt(1, mbox.getLastChangeID());\n            stmt.setInt(2, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"turning on sync tracking for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void startTrackingImap(Mailbox mbox) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE mailbox SET tracking_imap = 1 WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"turning on imap tracking for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static String getConfig(Mailbox mbox, String section) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT metadata FROM mailbox_metadata WHERE mailbox_id = ? AND section = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setString(2, section);\n            rs = stmt.executeQuery();\n            if (rs.next())\n                return rs.getString(1);\n            return null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting metadata section '\" + section + \"' in mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void updateConfig(Mailbox mbox, String section, Metadata config) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            if (config == null) {\n                stmt = conn.prepareStatement(\"DELETE FROM mailbox_metadata\" +\n                    \" WHERE mailbox_id = ? AND \" + Db.equalsSTRING(\"section\"));\n                stmt.setInt(1, mbox.getId());\n                stmt.setString(2, section.toUpperCase());\n                stmt.executeUpdate();\n                stmt.close();\n            } else {\n                // We try INSERT first even though it's the less common case, to avoid MySQL\n                // deadlock.  See bug 19404 for more info.\n                try {\n                    stmt = conn.prepareStatement(\"INSERT INTO mailbox_metadata (mailbox_id, section, metadata) \" +\n                    \"VALUES (?, ?, ?)\");\n                    stmt.setInt(1, mbox.getId());\n                    stmt.setString(2, section);\n                    stmt.setString(3, config.toString());\n                    stmt.executeUpdate();\n                } catch (SQLException e) {\n                    if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                        stmt = conn.prepareStatement(\"UPDATE mailbox_metadata \" +\n                            \"SET metadata = ? \" +\n                        \"WHERE mailbox_id = ? AND section = ?\");\n                        stmt.setString(1, config.toString());\n                        stmt.setInt(2, mbox.getId());\n                        stmt.setString(3, section);\n                        int numRows = stmt.executeUpdate();\n                        if (numRows != 1) {\n                            String msg = String.format(\n                                \"Unexpected number of rows (%d) updated for section %s\", numRows, section);\n                            throw ServiceException.FAILURE(msg, e);\n                        }\n                    }\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting metadata section '\" + section + \"' in mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Returns the zimbra IDs and mailbox IDs for all mailboxes on the\n     *  system.  Note that mailboxes are created lazily, so there may be\n     *  accounts homed on this system for whom there is is not yet a mailbox\n     *  and hence are not included in the returned <code>Map</code>.\n     * \n     * @param conn  An open database connection.\n     * @return A <code>Map</code> whose keys are zimbra IDs and whose values\n     *         are the corresponding numeric mailbox IDs.\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><code>service.FAILURE</code> - an error occurred while accessing\n     *        the database; a SQLException is encapsulated</ul> */\n    public static Map<String, Integer> getMailboxes(Connection conn) throws ServiceException {\n        HashMap<String, Integer> result = new HashMap<String, Integer>();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT account_id, id FROM mailbox\");\n            rs = stmt.executeQuery();\n            while (rs.next())\n                result.put(rs.getString(1), rs.getInt(2));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching mailboxes\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Returns the zimbra IDs and approximate sizes for all mailboxes on\n     *  the system.  Note that mailboxes are created lazily, so there may be\n     *  accounts homed on this system for whom there is is not yet a mailbox\n     *  and hence are not included in the returned <code>Map</code>.  Sizes\n     *  are checkpointed frequently, but there is no guarantee that the\n     *  approximate sizes are currently accurate.\n     * \n     * @param conn  An open database connection.\n     * @return A <code>Map</code> whose keys are zimbra IDs and whose values\n     *         are the corresponding approximate mailbox sizes.\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><code>service.FAILURE</code> - an error occurred while accessing\n     *        the database; a SQLException is encapsulated</ul> */\n    public static Map<String, Long> getMailboxSizes(Connection conn) throws ServiceException {\n        HashMap<String, Long> result = new HashMap<String, Long>();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT account_id, size_checkpoint FROM mailbox\");\n            rs = stmt.executeQuery();\n            while (rs.next())\n                result.put(rs.getString(1), rs.getLong(2));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching mailboxes\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static final int CHANGE_CHECKPOINT_INCREMENT = Math.max(1, LC.zimbra_mailbox_change_checkpoint_frequency.intValue());\n    public static final int ITEM_CHECKPOINT_INCREMENT   = 20;\n\n    public static Mailbox.MailboxData getMailboxStats(Connection conn, int mailboxId) throws ServiceException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\n                    \"SELECT account_id, group_id,\" +\n                    \" size_checkpoint, contact_count, item_id_checkpoint, change_checkpoint, tracking_sync,\" +\n                    \" tracking_imap, index_volume_id, last_soap_access, new_messages, idx_deferred_count \" +\n                    \"FROM mailbox WHERE id = ?\");\n            stmt.setInt(1, mailboxId);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                return null;\n            int pos = 1;\n            Mailbox.MailboxData mbd = new Mailbox.MailboxData();\n            mbd.id            = mailboxId;\n            mbd.accountId     = rs.getString(pos++);\n            mbd.schemaGroupId = rs.getInt(pos++);\n            mbd.size          = rs.getLong(pos++);\n            if (rs.wasNull())\n                mbd.size = -1;\n            mbd.contacts      = rs.getInt(pos++);\n            if (rs.wasNull())\n                mbd.contacts = -1;\n            mbd.lastItemId    = rs.getInt(pos++) + ITEM_CHECKPOINT_INCREMENT - 1;\n            mbd.lastChangeId  = rs.getInt(pos++) + CHANGE_CHECKPOINT_INCREMENT - 1;\n            mbd.trackSync     = rs.getInt(pos++);\n            mbd.trackImap     = rs.getBoolean(pos++);\n            mbd.indexVolumeId = rs.getShort(pos++);\n            mbd.lastWriteDate = rs.getInt(pos++);\n            mbd.recentMessages = rs.getInt(pos++);\n            mbd.idxDeferredCount = rs.getInt(pos++);\n\n            // round lastItemId and lastChangeId up so that they get written on the next change\n            long rounding = mbd.lastItemId % ITEM_CHECKPOINT_INCREMENT;\n            if (rounding != ITEM_CHECKPOINT_INCREMENT - 1)\n                mbd.lastItemId -= rounding + 1;\n            rounding = mbd.lastChangeId % CHANGE_CHECKPOINT_INCREMENT;\n            if (rounding != CHANGE_CHECKPOINT_INCREMENT - 1)\n                mbd.lastChangeId -= rounding + 1;\n\n            rs.close();\n            stmt.close();\n\n            stmt = conn.prepareStatement(\"SELECT section FROM mailbox_metadata WHERE mailbox_id = ?\");\n            stmt.setInt(1, mailboxId);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                if (mbd.configKeys == null)\n                    mbd.configKeys = new HashSet<String>();\n                mbd.configKeys.add(rs.getString(1));\n            }\n\n            return mbd;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching stats on mailbox \" + mailboxId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Fills in the \"data\" arg with volume information on the mailbox.\n     * @param conn\n     * @param data must have id field set to valid mailbox id\n     * @throws ServiceException\n     */\n    public static void getMailboxVolumeInfo(Connection conn, Mailbox.MailboxData data) throws ServiceException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT index_volume_id FROM mailbox WHERE id = ?\");\n            stmt.setInt(1, data.id);\n            rs = stmt.executeQuery();\n            if (!rs.next())\n                throw MailServiceException.NO_SUCH_MBOX(data.id);\n            data.indexVolumeId = rs.getShort(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting mailbox volume info\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static int getMailboxGroupId(int mailboxId) {\n        int groups = DebugConfig.numMailboxGroups;\n        // -1 / +1 operations are done so that the group\n        // id is never 0.\n        return (mailboxId - 1) % groups + 1;\n    }\n\n    /** Returns the name of the database that contains tables for the\n     *  specified <code>mailboxId</code>.  As a side effect, also registers\n     *  interest on that database with the specified {@link Connection} (if\n     *  not <tt>null</tt>). */\n    public static String getDatabaseName(Mailbox mbox) {\n        return getDatabaseName(mbox.getSchemaGroupId());\n    }\n\n    public static String getDatabaseName(int groupId) {\n        return DB_PREFIX_MAILBOX_GROUP + groupId;\n    }\n\n    public static String qualifyTableName(Mailbox mbox, String tableName) {\n        return qualifyTableName(mbox.getSchemaGroupId(), tableName);\n    }\n\n    public static String qualifyTableName(int groupId, String tableName) {\n        return DB_PREFIX_MAILBOX_GROUP + groupId + '.' + tableName;\n    }\n\n\n    public static void removeFromDeletedAccount(Connection conn, String email)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        try {\n            // add the mailbox's account to deleted_account table\n            stmt = conn.prepareStatement(\"DELETE FROM deleted_account WHERE email = ?\");\n            stmt.setString(1, email.toLowerCase());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting row for \" + email + \" from deleted_account table\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static void addToDeletedAccount(Connection conn, Mailbox mbox) throws ServiceException {\n        // Get email address for mailbox by querying the mailbox table.  We can't get it by\n        // calling mbox.getAccount().getName() because the account was already deleted from LDAP.\n        String email = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT comment FROM mailbox WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            if (rs.next())\n                email = rs.getString(1);\n            else\n                throw ServiceException.FAILURE(\"no email address found for mailbox \" + mbox.getId(), null);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting email address for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        removeFromDeletedAccount(conn, email);\n\n        try {\n            // add the mailbox's account to deleted_account table\n            stmt = conn.prepareStatement(\n                    \"INSERT INTO deleted_account \" +\n                    \"(email, account_id, mailbox_id, deleted_at) \" +\n                    \"SELECT ?, account_id, id, ? FROM mailbox WHERE id = ?\");\n            stmt.setString(1, email.toLowerCase());\n            stmt.setLong(2, System.currentTimeMillis() / 1000);\n            stmt.setInt(3, mbox.getId());\n            stmt.executeUpdate();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking mailbox \" + mbox.getId() + \" as deleted\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Returns a DeletedAccount object for the given email, if the account for the email\n     * address was previously deleted.  Returns null if account for the email was not\n     * deleted.\n     * @param conn\n     * @param email\n     * @return\n     * @throws ServiceException\n     */\n    public static DeletedAccount getDeletedAccount(Connection conn, String email)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\n                    \"SELECT email, account_id, mailbox_id, deleted_at \" +\n                    \"FROM deleted_account WHERE email = ?\");\n            stmt.setString(1, email.toLowerCase());\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                String emailCol = rs.getString(1);\n                String accountId = rs.getString(2);\n                int mailboxId = rs.getInt(3);\n                long deletedAt = rs.getLong(4) * 1000;\n                return new DeletedAccount(emailCol, accountId, mailboxId, deletedAt);\n            } else {\n                return null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"checking if account \" + email + \" is deleted\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class DeletedAccount {\n        private String mEmail;\n        private String mAccountId;\n        private int mMailboxId;\n        private long mDeletedAt;\n\n        public DeletedAccount(String email, String accountId, int mailboxId, long deletedAt) {\n            mEmail = email;\n            mAccountId = accountId;\n            mMailboxId = mailboxId;\n            mDeletedAt = deletedAt;\n        }\n\n        public String getEmail() { return mEmail; }\n        public String getAccountId() { return mAccountId; }\n        public int getMailboxId() { return mMailboxId; }\n        public long getDeletedAt() { return mDeletedAt; }\n    }\n\n    /**\n     * Deletes the row for the specified mailbox from the <code>mailbox</code> table.\n     *  \n     * @throws ServiceException if the database operation failed\n     */\n    public static void deleteMailbox(Connection conn, Mailbox mbox) throws ServiceException {\n        addToDeletedAccount(conn, mbox);\n        PreparedStatement stmt = null;\n        try {\n            // remove entry from mailbox table\n            stmt = conn.prepareStatement(\"DELETE FROM mailbox WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    static Set<Long> getDistinctTagsets(Connection conn, Mailbox mbox) throws ServiceException {\n        Set<Long> tagsets = new HashSet<Long>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT DISTINCT(tags) FROM \" + DbMailItem.getMailItemTableName(mbox) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next())\n                tagsets.add(rs.getLong(1));\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct tagsets\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return tagsets;\n    }\n\n    static Set<Long> getDistinctFlagsets(Connection conn, Mailbox mbox) throws ServiceException {\n        Set<Long> flagsets = new HashSet<Long>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT DISTINCT(flags) FROM \" + DbMailItem.getMailItemTableName(mbox) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next())\n                flagsets.add(rs.getLong(1));\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct flagsets\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return flagsets;\n    }\n\n    /**\n     * Returns the account id's for the current server.\n     */\n    public static Set<String> getAccountIds(Connection conn) throws ServiceException {\n        Set<String> accountIds = new HashSet<String>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\n                \"SELECT account_id FROM mailbox\");\n            rs = stmt.executeQuery();\n            while (rs.next())\n                accountIds.add(rs.getString(1));\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct account id's\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return accountIds;\n    }\n    \n    public static class MailboxRawData {\n        public int id;\n        public int group_id;\n        public String account_id;\n        public int index_volume_id;\n        public int item_id_checkpoint;\n        public int contact_count;\n        public long size_checkpoint;\n        public int change_checkpoint;\n        public int tracking_sync;\n        public boolean tracking_imap;\n        public int last_backup_at;\n        public String comment;\n        public int last_soap_access;\n        public int new_messages;\n        public int idx_deferred_count;\n    }\n    \n    public static List<MailboxRawData> getMailboxRawData(Connection conn) throws ServiceException {\n        List<MailboxRawData> results = new ArrayList<MailboxRawData>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\n                    \"SELECT \" +\n                    \"id, \" +\n                    \"group_id, \" +\n                    \"account_id, \" +\n                    \"index_volume_id, \" +\n                    \"item_id_checkpoint, \" +\n                    \"contact_count, \" +\n                    \"size_checkpoint, \" +\n                    \"change_checkpoint, \" +\n                    \"tracking_sync, \" +\n                    \"tracking_imap, \" +\n                    \"last_backup_at, \" +\n                    // \"comment, \" +\n                    \"last_soap_access, \" +\n                    \"new_messages, \" +\n                    \"idx_deferred_count \" +\n                    \"FROM mailbox\");\n            rs = stmt.executeQuery();\n            \n            while (rs.next()) {\n                MailboxRawData data = new MailboxRawData();\n                int pos = 1;\n                \n                data.id = rs.getInt(pos++);\n                data.group_id = rs.getInt(pos++);\n                data.account_id = rs.getString(pos++);\n                data.index_volume_id = rs.getShort(pos++);\n                data.item_id_checkpoint = rs.getInt(pos++);\n                data.contact_count = rs.getInt(pos++);\n                data.size_checkpoint = rs.getLong(pos++);\n                data.change_checkpoint = rs.getInt(pos++);\n                data.tracking_sync = rs.getInt(pos++);\n                data.tracking_imap = rs.getBoolean(pos++);\n                data.last_backup_at = rs.getInt(pos++);\n                // data.comment = rs.getString(pos++);\n                data.last_soap_access = rs.getInt(pos++);\n                data.new_messages = rs.getInt(pos++);\n                data.idx_deferred_count = rs.getInt(pos++);\n                \n                results.add(data);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct account id's\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return results;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "078d38277aefd25de4fac9bebd6723c634e53622",
    "commit_msg": "(split)bug: 29563\n\nAvoid cross-database transactions in SQLite by writing to a MBOXGROUP<N>.MAILBOX table instead of a ZIMBRA.MAILBOX table when stats change on the mailbox.  When we load a mailbox, we make sure that the two rows match and update the ZIMBRA.MAILBOX row if they don't.  Every 10 changes, we batch up all the changed MBOXGROUP<N>.MAILBOX values and write them all to ZIMBRA.MAILBOX.  As a result, a few mailboxes' stats may be a little out of date for some admin commands, but the system will run off the correct values (since it fetches for the MBOXGROUP authoritative values) and the problem should self-correct.  This feature is turned on by the new \"debug_defer_mailbox_updates\" config key (defaults to FALSE, of course).\n\nPerf gain is significant, bringing SQLite into line with derby though still significantly slower than MySQL.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 106587",
    "original_file": "DbMailbox.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 5,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private Map<Db.Error, String> mErrorCodes;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        //mErrorCodes.put(Db.Error.DEADLOCK_DETECTED,        \"\");\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW,            \"column id is not unique\");\n        //mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT,    \"\");\n        //mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, \"\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && code.equals(e.getMessage());\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override public String scriptCommandDelimiter() {\n        return \"%\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        Map<String, String> pragmas = getCustomPragmas();\n\n        LinkedList<java.sql.Connection> connections = new LinkedList<java.sql.Connection>();\n        for (int i = 0; i < poolSize; i++) {\n            java.sql.Connection conn = pool.getConnection();\n            if (i == 0)\n                ZimbraLog.dbconn.info(\"sqlite driver running in \" + conn.getMetaData().getDriverVersion() + \" mode\");\n\n            try {\n                conn.setAutoCommit(true);\n                pragma(conn, \"page_size\", \"4096\");\n                pragma(conn, \"default_page_size\", \"4096\");\n                pragma(conn, \"synchronous\", \"NORMAL\");\n                pragma(conn, \"fullfsync\", \"0\");\n                pragma(conn, \"journal_mode\", \"PERSIST\");\n//                pragma(conn, \"locking_mode\", \"EXCLUSIVE\");\n                pragma(conn, \"legacy_file_format\", \"OFF\");\n//                pragma(conn, \"read_uncommitted\", \"1\");\n\n                for (Map.Entry<String, String> pragma : pragmas.entrySet())\n                    pragma(conn, pragma.getKey(), pragma.getValue());\n            } finally {\n                connections.add(conn);\n                conn.setAutoCommit(false);\n            }\n        }\n        for (java.sql.Connection conn : connections)\n            conn.close();\n\n        super.startup(pool, poolSize);\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private Map<String, String> getCustomPragmas() {\n        String propsfile = LC.get(\"sqlite_pragma_file\");\n        if (propsfile == null || propsfile.trim().equals(\"\"))\n            return Collections.emptyMap();\n\n        try {\n            Properties props = new Properties();\n            props.load(new FileInputStream(propsfile));\n            ZimbraLog.dbconn.info(\"reading custom sqlite pragmas from conf file: \" + propsfile);\n\n            Map<String, String> pragmas = new HashMap<String, String>(props.size() * 3 / 2);\n            for (Map.Entry<Object, Object> foo : props.entrySet()) {\n                String key = (String) foo.getKey(), value = (String) foo.getValue();\n                pragmas.put(key, value);\n                ZimbraLog.dbconn.info(\"  found custom pragma: '\" + key + \"' => '\" + value + \"'\");\n            }\n            return pragmas;\n        } catch (FileNotFoundException x) {\n            ZimbraLog.dbconn.info(\"no sqlite pragma conf file found; will use standard config\");\n        } catch (IOException x) {\n            ZimbraLog.dbconn.warn(\"exception reading from sqlite pragma conf file (\" + propsfile + \"); will use standard config\", x);\n        }\n        return Collections.emptyMap();\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private void recordAttachedDatabase(Connection conn, String dbname) {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n    \n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                if (detachDatabase(conn, it.next()))\n                    it.remove();\n            }\n        }\n\n        attachDatabase(conn, dbname);\n        recordAttachedDatabase(conn, dbname);\n    }\n\n    @SuppressWarnings(\"unused\")\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // XXX: since it's so easy to end up with an empty SQLite database, make sure that the tables we want are actually in there\n        //   (yes, this assumes that we're looking for a MBOXGROUP database, which is beyond the scope of this method's contract)\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + dbname + \".sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= DbMailbox.sTables.size()) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"foo\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6713e51587bf06470b5d7e638845cd245bc7baad",
    "commit_msg": "(split)bug: 35710 more sqlite/derby build issues\nzimbra.db is now created dynamically during server startup\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=35710\n\nCopied from Perforce\n Change: 212005",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 6,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.common.util;\n\nimport java.io.File;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeMap;\n\nimport org.apache.log4j.PropertyConfigurator;\n\n/**\n * Log categories.\n *\n * @author schemers\n */\npublic final class ZimbraLog {\n\n    /**\n     * \"ip\" key for context. IP of request\n     */\n    private static final String C_IP = \"ip\";\n\n    /**\n     * \"oip\" key for context. originating IP of request\n     */\n    private static final String C_OIP = \"oip\";\n\n    /**\n     * \"id\" key for context. Id of the target account\n     */\n    public static final String C_ID = \"id\";\n\n    /**\n     * \"name\" key for context. Id of the target account\n     */\n    public static final String C_NAME = \"name\";\n\n    /**\n     * \"aid\" key for context. Id in the auth token. Only present if target id is\n     * different then auth token id.\n     */\n    public static final String C_AID = \"aid\";\n\n    /**\n     * \"aname\" key for context. name in the auth token. Only present if target id is\n     * different then auth token id.\n     */\n    public static final String C_ANAME = \"aname\";\n\n    /**\n     * \"cid\" is the connection id of a server that is monotonically increasing - useful\n     * for tracking individual connections.\n     */\n    public static final String C_CONNECTIONID = \"cid\";\n\n    /**\n     * \"mid\" key for context. Id of requested mailbox. Only present if request is\n     * dealing with a mailbox.\n     */\n    public static final String C_MID = \"mid\";\n\n    /**\n     * \"ua\" key for context.  The name of the client application.\n     */\n    private static final String C_USER_AGENT = \"ua\";\n\n    /**\n     * List of IP addresses and user-agents of the proxy chain.\n     * was sent.\n     */\n    private static final String C_VIA = \"via\";\n\n    /**\n     * \"msgid\" key for context.  The Message-ID header of the message being\n     * operated on.\n     */\n    private static final String C_MSG_ID = \"msgid\";\n\n    /**\n     * \"item\" key for context.\n     */\n    private static final String C_ITEM = \"item\";\n\n    /**\n     * \"ds\" key for context.  The name of the Data Source being operated on.\n     */\n    private static final String C_DATA_SOURCE_NAME = \"ds\";\n\n    /**\n     * \"port\" key for context.  The server port to which the client connected.\n     */\n    private static final String C_PORT = \"port\";\n\n    /**\n     * the \"zimbra.misc\" logger. For all events that don't have a specific-catagory.\n     */\n    public static final Log misc = LogFactory.getLog(\"zimbra.misc\");\n\n    /**\n     * the \"zimbra.net\" logger. For logging of network activities\n     */\n    public static final Log net = LogFactory.getLog(\"zimbra.net\");\n\n    /**\n     * the \"zimbra.index\" logger. For indexing.\n     */\n    public static final Log index = LogFactory.getLog(\"zimbra.index\");\n\n    /**\n     * the \"zimbra.search\" logger. For search.\n     */\n    public static final Log search = LogFactory.getLog(\"zimbra.search\");\n\n    /**\n     * Fhe \"zimbra.searchstat\" logger.  For logging statistics about what kinds of searches are run\n     */\n    public static final Log searchstats = LogFactory.getLog(\"zimbra.searchstats\");\n\n    /**\n     * the \"zimbra.redolog\" logger. For redolog-releated events.\n     */\n    public static final Log redolog = LogFactory.getLog(\"zimbra.redolog\");\n\n    /**\n     * the \"zimbra.lmtp\" logger. For LMTP-related events.\n     */\n    public static final Log lmtp = LogFactory.getLog(\"zimbra.lmtp\");\n\n    /**\n     * the \"zimbra.smtp\" logger. For SMTP-related events.\n     */\n    public static final Log smtp = LogFactory.getLog(\"zimbra.smtp\");\n\n    /**\n     * the \"zimbra.nio\" logger. For NIO-related events.\n     */\n    public static final Log nio = LogFactory.getLog(\"zimbra.nio\");\n\n    /**\n     * the \"zimbra.imap.client\" logger. For IMAP client related events.\n     */\n    public static final Log imap_client = LogFactory.getLog(\"zimbra.imap-client\");\n\n    /**\n     * the \"zimbra.imap\" logger. For IMAP server related events.\n     */\n    public static final Log imap = LogFactory.getLog(\"zimbra.imap\");\n\n    /**\n     * the \"zimbra.pop.client\" logger. For POP3 client related events.\n     */\n    public static final Log pop_client = LogFactory.getLog(\"zimbra.pop-client\");\n\n    /**\n     * the \"zimbra.pop\" logger. For POP3 server related events.\n     */\n    public static final Log pop = LogFactory.getLog(\"zimbra.pop\");\n\n    /**\n     * the \"zimbra.milter\" logger. For MILTER-related events\n     */\n    public static final Log milter = LogFactory.getLog(\"zimbra.milter\");\n\n    /**\n     * the \"zimbra.mailbox\" logger. For mailbox-related events.\n     */\n    public static final Log mailbox = LogFactory.getLog(\"zimbra.mailbox\");\n\n    /**\n     * the \"zimbra.calendar\" logger. For calendar-related events.\n     */\n    public static final Log calendar = LogFactory.getLog(\"zimbra.calendar\");\n\n    /**\n     * the \"zimbra.im\" logger. For instant messaging-related events.\n     */\n    public static final Log im = LogFactory.getLog(\"zimbra.im\");\n\n    /**\n     * the \"zimbra.im.intercept\" logger. The IM packet interceptor (IM protocol logger)\n     */\n    public static final Log im_intercept= LogFactory.getLog(\"zimbra.im.intercept\");\n\n    /**\n     * the \"zimbra.account\" logger. For account-related events.\n     */\n    public static final Log account = LogFactory.getLog(\"zimbra.account\");\n\n    /**\n     * the \"zimbra.gal\" logger. For gal-related events.\n     */\n    public static final Log gal = LogFactory.getLog(\"zimbra.gal\");\n\n    /**\n     * the \"zimbra.ldap\" logger. For ldap-related events.\n     */\n    public static final Log ldap = LogFactory.getLog(\"zimbra.ldap\");\n\n    /**\n     * the \"zimbra.acl\" logger. For acl-related events.\n     */\n    public static final Log acl = LogFactory.getLog(\"zimbra.acl\");\n\n    /**\n     * the \"zimbra.security\" logger. For security-related events\n     */\n    public static final Log security = LogFactory.getLog(\"zimbra.security\");\n\n    /**\n     * the \"zimbra.soap\" logger. For soap-related events\n     */\n    public static final Log soap = LogFactory.getLog(\"zimbra.soap\");\n\n    /**\n     * the \"zimbra.test\" logger. For testing-related events\n     */\n    public static final Log test = LogFactory.getLog(\"zimbra.test\");\n\n    /**\n     * the \"zimbra.sqltrace\" logger. For tracing SQL statements sent to the database\n     */\n    public static final Log sqltrace = LogFactory.getLog(\"zimbra.sqltrace\");\n\n    /**\n     * the \"zimbra.dbconn\" logger. For tracing database connections\n     */\n    public static final Log dbconn = LogFactory.getLog(\"zimbra.dbconn\");\n\n    /**\n     * the \"zimbra.perf\" logger. For logging performance statistics\n     */\n    public static final Log perf = LogFactory.getLog(\"zimbra.perf\");\n\n    /**\n     * the \"zimbra.cache\" logger. For tracing object cache activity\n     */\n    public static final Log cache = LogFactory.getLog(\"zimbra.cache\");\n\n    /**\n     * the \"zimbra.filter\" logger. For filter-related logs.\n     */\n    public static final Log filter = LogFactory.getLog(\"zimbra.filter\");\n\n    /**\n     * the \"zimbra.session\" logger. For session- and notification-related logs.\n     */\n    public static final Log session = LogFactory.getLog(\"zimbra.session\");\n\n    /**\n     * the \"zimbra.backup\" logger. For backup/restore-related logs.\n     */\n    public static final Log backup = LogFactory.getLog(\"zimbra.backup\");\n\n    /**\n     * the \"zimbra.system\" logger. For startup/shutdown and other related logs.\n     */\n    public static final Log system = LogFactory.getLog(\"zimbra.system\");\n\n    /**\n     * the \"zimbra.sync\" logger. For sync client interface logs.\n     */\n    public static final Log sync = LogFactory.getLog(\"zimbra.sync\");\n\n    /**\n     * the \"zimbra.synctrace\" logger. For sync client interface logs.\n     */\n    public static final Log synctrace = LogFactory.getLog(\"zimbra.synctrace\");\n\n    /**\n     * the \"zimbra.syncstate\" logger. For sync client interface logs.\n     */\n    public static final Log syncstate = LogFactory.getLog(\"zimbra.syncstate\");\n\n    /**\n     * the \"zimbra.wbxml\" logger. For wbxml client interface logs.\n     */\n    public static final Log wbxml = LogFactory.getLog(\"zimbra.wbxml\");\n\n    /**\n     * the \"zimbra.xsync\" logger. For xsync client interface logs.\n     */\n    public static final Log xsync = LogFactory.getLog(\"zimbra.xsync\");\n\n    /**\n     * the \"zimbra.extensions\" logger. For logging extension loading related info.\n     */\n    public static final Log extensions = LogFactory.getLog(\"zimbra.extensions\");\n\n    /**\n     * the \"zimbra.zimlet\" logger. For logging zimlet related info.\n     */\n    public static final Log zimlet = LogFactory.getLog(\"zimbra.zimlet\");\n\n    /**\n     * the \"zimbra.wiki\" logger. For wiki and document sharing.\n     */\n    public static final Log wiki = LogFactory.getLog(\"zimbra.wiki\");\n\n    /**\n     * the \"zimbra.op\" logger. Logs server operations\n     */\n    public static final Log op = LogFactory.getLog(\"zimbra.op\");\n\n    /**\n     * the \"zimbra.dav\" logger. Logs dav operations\n     */\n    public static final Log dav = LogFactory.getLog(\"zimbra.dav\");\n\n    /**\n     * the \"zimbra.io\" logger.  Logs file IO operations.\n     */\n    public static final Log io = LogFactory.getLog(\"zimbra.io\");\n\n    /**\n     * the \"zimbra.datasource\" logger.  Logs data source operations.\n     */\n    public static final Log datasource = LogFactory.getLog(\"zimbra.datasource\");\n\n    /**\n     * remote management.\n     */\n    public static final Log rmgmt = LogFactory.getLog(\"zimbra.rmgmt\");\n\n    /**\n     * the \"zimbra.webclient\" logger. Logs ZimbraWebClient servlet and jsp operations.\n     */\n    public static final Log webclient = LogFactory.getLog(\"zimbra.webclient\");\n\n    /**\n     * the \"zimbra.scheduler\" logger.  Logs scheduled task operations.\n     */\n    public static final Log scheduler = LogFactory.getLog(\"zimbra.scheduler\");\n\n    /**\n     * the \"zimbra.store\" logger.  Logs filesystem storage operations.\n     */\n    public static final Log store = LogFactory.getLog(\"zimbra.store\");\n\n    /**\n     * the \"zimbra.fb\" logger.  Logs free/busy operations.\n     */\n    public static final Log fb = LogFactory.getLog(\"zimbra.fb\");\n\n    /**\n     * the \"zimbra.purge\" logger.  Logs mailbox purge operations.\n     */\n    public static final Log purge = LogFactory.getLog(\"zimbra.purge\");\n\n    /**\n     * the \"zimbra.mailop\" logger.  Logs changes to items in the mailbox.\n     */\n    public static final Log mailop = LogFactory.getLog(\"zimbra.mailop\");\n\n    /**\n     * \"zimbra.slogger\" logger.  Used for \"logger service\", publishes stats events to syslog\n     */\n    public static final Log slogger = LogFactory.getLog(\"zimbra.slogger\");\n\n    /**\n     * the \"zimbra.mbxmgr\" logger is used to track mailbox loading/maintenance mode\n     */\n    public static final Log mbxmgr = LogFactory.getLog(\"zimbra.mbxmgr\");\n\n    /**\n     * \"zimbra.tnef\" logger.  Logs TNEF conversion operations.\n     */\n    public static final Log tnef = LogFactory.getLog(\"zimbra.tnef\");\n\n\n    /**\n     * Maps the log category name to its description.\n     */\n    public static final Map<String, String> CATEGORY_DESCRIPTIONS;\n\n    private ZimbraLog() {\n    }\n\n    /**\n     * Returns a new <tt>Set</tt> that contains the values of\n     * {@link #C_NAME} and {@link #C_ANAME} if they are set.\n     */\n    public static Set<String> getAccountNamesFromContext() {\n        Map<String, String> contextMap = sContextMap.get();\n        if (contextMap == null) {\n            return Collections.emptySet();\n        }\n\n        String name = contextMap.get(C_NAME);\n        String aname = contextMap.get(C_ANAME);\n        if (name == null && aname == null) {\n            return Collections.emptySet();\n        }\n\n        Set<String> names = new HashSet<String>();\n        if (name != null) {\n            names.add(name);\n        }\n        if (aname != null) {\n            names.add(aname);\n        }\n        return names;\n    }\n\n    private static final ThreadLocal<Map<String, String>> sContextMap = new ThreadLocal<Map<String, String>>();\n    private static final ThreadLocal<String> sContextString = new ThreadLocal<String>();\n\n    private static final Set<String> CONTEXT_KEY_ORDER = new LinkedHashSet<String>();\n\n    static {\n        CONTEXT_KEY_ORDER.add(C_NAME);\n        CONTEXT_KEY_ORDER.add(C_ANAME);\n        CONTEXT_KEY_ORDER.add(C_MID);\n        CONTEXT_KEY_ORDER.add(C_IP);\n\n        // Initialize log category descriptions.  Categories that don't have a description\n        // won't be listed in zmprov online help.\n        Map<String, String> descriptions = new TreeMap<String, String>();\n        descriptions.put(misc.getCategory(), \"Miscellaneous\");\n        descriptions.put(index.getCategory(), \"Indexing operations\");\n        descriptions.put(search.getCategory(), \"Search operations\");\n        descriptions.put(redolog.getCategory(), \"Redo log operations\");\n        descriptions.put(lmtp.getCategory(), \"LMTP server (incoming mail)\");\n        descriptions.put(smtp.getCategory(), \"SMTP client (outgoing mail)\");\n        descriptions.put(imap_client.getCategory(), \"IMAP client\");\n        descriptions.put(imap.getCategory(), \"IMAP server\");\n        descriptions.put(milter.getCategory(), \"MILTER protocol operations\");\n        descriptions.put(pop_client.getCategory(), \"POP client\");\n        descriptions.put(pop.getCategory(), \"POP server\");\n        descriptions.put(mailbox.getCategory(), \"General mailbox operations\");\n        descriptions.put(calendar.getCategory(), \"Calendar operations\");\n        descriptions.put(im.getCategory(), \"Instant messaging operations\");\n        descriptions.put(account.getCategory(), \"Account operations\");\n        descriptions.put(gal.getCategory(), \"GAL operations\");\n        descriptions.put(ldap.getCategory(), \"LDAP operations\");\n        descriptions.put(acl.getCategory(), \"ACL operations\");\n        descriptions.put(security.getCategory(), \"Security events\");\n        descriptions.put(soap.getCategory(), \"SOAP protocol\");\n        descriptions.put(sqltrace.getCategory(), \"SQL tracing\");\n        descriptions.put(dbconn.getCategory(), \"Database connection tracing\");\n        descriptions.put(cache.getCategory(), \"In-memory cache operations\");\n        descriptions.put(filter.getCategory(), \"Mail filtering\");\n        descriptions.put(session.getCategory(), \"User session tracking\");\n        descriptions.put(backup.getCategory(), \"Backup and restore\");\n        descriptions.put(system.getCategory(), \"Startup/shutdown and other system messages\");\n        descriptions.put(sync.getCategory(), \"Sync client operations\");\n        descriptions.put(extensions.getCategory(), \"Server extension loading\");\n        descriptions.put(zimlet.getCategory(), \"Zimlet operations\");\n        descriptions.put(wiki.getCategory(), \"Wiki operations\");\n        descriptions.put(mailop.getCategory(), \"Changes to mailbox state\");\n        descriptions.put(dav.getCategory(), \"DAV operations\");\n        descriptions.put(io.getCategory(), \"Filesystem operations\");\n        descriptions.put(store.getCategory(), \"Mail store disk operations\");\n        descriptions.put(purge.getCategory(), \"Mailbox purge operations\");\n        descriptions.put(datasource.getCategory(), \"Data Source operations\");\n        CATEGORY_DESCRIPTIONS = Collections.unmodifiableMap(descriptions);\n    }\n\n    static String getContextString() {\n        return sContextString.get();\n    }\n\n    //this is called from offline and only at LC init so we are taking chances with race\n    private static final Set<String> CONTEXT_FILTER = new HashSet<String>();\n    public static void addContextFilters(String filters) {\n        for (String item : filters.split(\",\"))\n            CONTEXT_FILTER.add(item);\n    }\n\n    /**\n     * Adds a key/value pair to the current thread's logging context.  If\n     * <tt>key</tt> is null, does nothing.  If <tt>value</tt> is null,\n     * removes the context entry.\n     */\n    public static void addToContext(String key, String value) {\n        if (key == null || CONTEXT_FILTER.contains(key))\n            return;\n\n        Map<String, String> contextMap = sContextMap.get();\n        boolean contextChanged = false;\n\n        if (StringUtil.isNullOrEmpty(value)) {\n            // Remove\n            if (contextMap != null) {\n                String oldValue = contextMap.remove(key);\n                if (oldValue != null) {\n                    contextChanged = true;\n                }\n            }\n        } else {\n            // Add\n            if (contextMap == null) {\n                contextMap = new LinkedHashMap<String, String>();\n                sContextMap.set(contextMap);\n            }\n            String oldValue = contextMap.put(key, value);\n            if (!StringUtil.equal(oldValue, value)) {\n                contextChanged = true;\n            }\n        }\n        if (contextChanged) {\n            updateContextString();\n        }\n    }\n\n    /**\n     * Updates the context string with the latest data in {@link #sContextMap}.\n     */\n    private static void updateContextString() {\n        Map<String, String> contextMap = sContextMap.get();\n        if (contextMap == null || contextMap.size() == 0) {\n            sContextString.set(null);\n            return;\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        // Append ordered keys first\n        for (String key : CONTEXT_KEY_ORDER) {\n            String value = contextMap.get(key);\n            if (value != null) {\n                encodeArg(sb, key, value);\n            }\n        }\n\n        // Append the rest\n        for (String key : contextMap.keySet()) {\n            if (!CONTEXT_KEY_ORDER.contains(key)) {\n                String value = contextMap.get(key);\n                if (key != null && value != null) {\n                    encodeArg(sb, key, value);\n                }\n            }\n        }\n\n        sContextString.set(sb.toString());\n    }\n\n    /**\n     * Adds a <tt>MailItem</tt> id to the current thread's\n     * logging context.\n     */\n    public static void addItemToContext(int itemId) {\n        addToContext(C_ITEM, Integer.toString(itemId));\n    }\n\n    /**\n     * Removes a key/value pair from the current thread's logging context.\n     */\n    public static void removeFromContext(String key) {\n        if (key != null) {\n            addToContext(key, null);\n        }\n    }\n\n    /**\n     * Removes a <tt>MailItem</tt> id from the current thread's\n     * logging context.\n     */\n    public static void removeItemFromContext(int itemId) {\n        removeFromContext(C_ITEM);\n    }\n\n    /**\n     * Adds account name to the current thread's logging context.\n     */\n    public static void addAccountNameToContext(String accountName) {\n        ZimbraLog.addToContext(C_NAME, accountName);\n    }\n\n    /**\n     * Removes all account-specific values from the current thread's\n     * logging context.\n     */\n    public static void removeAccountFromContext() {\n        removeFromContext(C_ID);\n        removeFromContext(C_MID);\n        removeFromContext(C_NAME);\n        removeFromContext(C_ANAME);\n        removeFromContext(C_ITEM);\n        removeFromContext(C_MSG_ID);\n    }\n\n    /**\n     * Adds ip to the current thread's logging context.\n     */\n    public static void addIpToContext(String ipAddress) {\n        ZimbraLog.addToContext(C_IP, ipAddress);\n    }\n\n    /**\n     * Adds oip (originating IP) to the current thread's logging context.\n     */\n    public static void addOrigIpToContext(String ipAddress) {\n        ZimbraLog.addToContext(C_OIP, ipAddress);\n    }\n\n    /**\n     * Adds connection id to the current thread's logging context.\n     */\n    public static void addConnectionIdToContext(String connectionId) {\n        ZimbraLog.addToContext(C_CONNECTIONID, connectionId);\n    }\n\n    /**\n     * Adds mailbox id to the current thread's logging context.\n     */\n    public static void addMboxToContext(int mboxId) {\n        addToContext(C_MID, Integer.toString(mboxId));\n    }\n\n    /**\n     * Removes mailbox id from the current thread's logging context.\n     */\n    public static void removeMboxFromContext() {\n        removeFromContext(C_MID);\n    }\n\n    /**\n     * Adds message id to the current thread's logging context.\n     */\n    public static void addMsgIdToContext(String messageId) {\n        addToContext(C_MSG_ID, messageId);\n    }\n\n    /**\n     * Adds data source name to the current thread's logging context.\n     */\n    public static void addDataSourceNameToContext(String dataSourceName) {\n        addToContext(C_DATA_SOURCE_NAME, dataSourceName);\n    }\n\n    /**\n     * Removes data source name from the current thread's logging context.\n     */\n    public static void removeDataSourceNameFromContext() {\n        removeFromContext(C_DATA_SOURCE_NAME);\n    }\n\n    /**\n     * Adds port to the current thread's logging context.\n     */\n    public static void addPortToContext(int port) {\n        ZimbraLog.addToContext(C_PORT, Integer.toString(port));\n    }\n\n    /**\n     * Adds user agent to the current thread's logging context.\n     */\n    public static void addUserAgentToContext(String ua) {\n        ZimbraLog.addToContext(C_USER_AGENT, ua);\n    }\n\n    /**\n     * Adds {@code via} to the current thread's logging context.\n     *\n     * @param value\n     */\n    public static void addViaToContext(String value) {\n        ZimbraLog.addToContext(C_VIA, value);\n    }\n\n    /**\n     * Clears the current thread's logging context.\n     *\n     */\n    public static void clearContext() {\n        Map<String, String> contextMap = sContextMap.get();\n        if (contextMap != null) {\n            contextMap.clear();\n        }\n        sContextString.remove();\n    }\n\n    /**\n     * Setup log4j for our command line tools.\n     *\n     * If System.getProperty(zimbra.log4j.level) is set then log at that level.\n     * Else log at the specified defaultLevel.\n     */\n    public static void toolSetupLog4j(String defaultLevel, String logFile, boolean showThreads) {\n        String level = System.getProperty(\"zimbra.log4j.level\");\n        if (level == null) {\n            level = defaultLevel;\n        }\n        Properties p = new Properties();\n        p.put(\"log4j.rootLogger\", level + \",A1\");\n        if (logFile != null) {\n            p.put(\"log4j.appender.A1\", \"org.apache.log4j.FileAppender\");\n            p.put(\"log4j.appender.A1.File\", logFile);\n            p.put(\"log4j.appender.A1.Append\", \"false\");\n        } else {\n            p.put(\"log4j.appender.A1\", \"org.apache.log4j.ConsoleAppender\");\n        }\n        p.put(\"log4j.appender.A1.layout\", \"org.apache.log4j.PatternLayout\");\n        if (showThreads) {\n            p.put(\"log4j.appender.A1.layout.ConversionPattern\", \"[%t] [%x] %p: %m%n\");\n        } else {\n            p.put(\"log4j.appender.A1.layout.ConversionPattern\", \"[%x] %p: %m%n\");\n        }\n        PropertyConfigurator.configure(p);\n    }\n\n    public static void toolSetupLog4jConsole(String defaultLevel, boolean stderr, boolean showThreads) {\n        String level = System.getProperty(\"zimbra.log4j.level\");\n        if (level == null) {\n            level = defaultLevel;\n        }\n        Properties p = new Properties();\n        p.put(\"log4j.rootLogger\", level + \",A1\");\n\n        p.put(\"log4j.appender.A1\", \"org.apache.log4j.ConsoleAppender\");\n        if (stderr)\n            p.put(\"log4j.appender.A1.target\", \"System.err\");\n\n        p.put(\"log4j.appender.A1.layout\", \"org.apache.log4j.PatternLayout\");\n        if (showThreads) {\n            p.put(\"log4j.appender.A1.layout.ConversionPattern\", \"[%t] [%x] %p: %m%n\");\n        } else {\n            p.put(\"log4j.appender.A1.layout.ConversionPattern\", \"[%x] %p: %m%n\");\n        }\n        PropertyConfigurator.configure(p);\n    }\n\n    /**\n     * Setup log4j for command line tool using specified log4j.properties file.\n     * If file doesn't exist System.getProperty(zimbra.home)/conf/log4j.properties\n     * file will be used.\n     * @param defaultLevel\n     * @param propsFile full path to log4j.properties file\n     */\n    public static void toolSetupLog4j(String defaultLevel, String propsFile) {\n        if (propsFile != null && new File(propsFile).exists()) {\n            PropertyConfigurator.configure(propsFile);\n        } else {\n            toolSetupLog4j(defaultLevel, null, false);\n        }\n    }\n\n    private static void encodeArg(StringBuilder sb, String name, String value) {\n        if (value == null) {\n            value = \"\";\n        }\n        if (value.indexOf(';') != -1) {\n            value = value.replaceAll(\";\", \";;\");\n        }\n        // replace returns ref to original string if char to replace doesn't exist\n        value = value.replace('\\r', ' ');\n        value = value.replace('\\n', ' ');\n        sb.append(name);\n        sb.append(\"=\");\n        sb.append(value);\n        sb.append(';');\n    }\n\n    /**\n     * Take an array of Strings [ \"name1\", \"value1\", \"name2\", \"value2\", ...] and\n     * format them for logging purposes.\n     *\n     * @param strings\n     * @return formatted string\n     */\n    public static String encodeAttrs(String[] args) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < args.length; i += 2) {\n            if (i > 0) {\n                sb.append(' ');\n            }\n            encodeArg(sb, args[i], args[i + 1]);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Take an array of Strings [ \"name1\", \"value1\", \"name2\", \"value2\", ...] and\n     * format them for logging purposes into: <tt>name1=value1; name2=value;</tt>.\n     * Semicolons are escaped with two semicolons (value a;b is encoded as a;;b).\n     *\n     * @param strings\n     * @return formatted string\n     */\n    public static String encodeAttrs(String[] args, Map<String, ?> extraArgs) {\n        StringBuilder sb = new StringBuilder();\n        boolean needSpace = false;\n        for (int i = 0; i < args.length; i += 2) {\n            if (needSpace) {\n                sb.append(' ');\n            } else {\n                needSpace = true;\n            }\n            encodeArg(sb, args[i], args[i + 1]);\n        }\n        if (extraArgs != null) {\n            for (Map.Entry<String, ?> entry : extraArgs.entrySet()) {\n                if (needSpace) {\n                    sb.append(' ');\n                } else {\n                    needSpace = true;\n                }\n                String name = entry.getKey();\n                Object value = entry.getValue();\n                if (value == null) {\n                    encodeArg(sb, name, \"\");\n                } else if (value instanceof String) {\n                    encodeArg(sb, name, (String) value);\n                } else if (value instanceof String[]) {\n                    for (String arg : (String[]) value) {\n                        encodeArg(sb, name, arg);\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n",
    "vulnerability_type": "Path Traversal",
    "repo": "zm-mailbox",
    "commit": "0549eeb8305ca12cf27aace4121f80795375db57",
    "commit_msg": "bug: 57365\n\nIntegrating from main to HELIX\n\nChange 286584 by jhahm@jhahm-mac3 on 2011/04/01 16:59:45\n\n        bug: 57365\n\n        Indicate the appointment's folder.  Client should use this \n        information to hide A/T/D buttons when appointment is in trash.\n\n        Appointment folder id is specified in \"ciFolder\" attribute: \n        <inv><comp calItemId=\"123\" ciFolder=\"3\" .../><inv>.  calItemId and \n        ciFolder go together.  Both will be present if appointment exists.  \n        Neither will be present if appointment doesn't exist.  Appointment \n        item may not exist if it was never created (auto add is disabled) or \n        if trash was emptied after appointment delete/cancel.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=57365\n\nCopied from Perforce\n Change: 286619",
    "original_file": "ZimbraLog.java",
    "confidence_score": 0.6
  },
  {
    "serial_no": 7,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\n\npublic class MySQL extends Db {\n\n    private Map<Db.Error, Integer> mErrorCodes;\n\n    MySQL() {\n        mErrorCodes = new HashMap<Db.Error, Integer>(6);\n        mErrorCodes.put(Db.Error.DEADLOCK_DETECTED,        1213);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW,            1062);\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT,    1216);\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, 1217);\n        mErrorCodes.put(Db.Error.NO_SUCH_DATABASE,         1146);\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE,            1146);\n    }\n\n    @Override\n    boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return false;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return true;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return true;\n            case ON_DUPLICATE_KEY:           return true;\n            case ON_UPDATE_CASCADE:          return true;\n            case UNIQUE_NAME_INDEX:          return true;\n        }\n        return false;\n    }\n\n    @Override\n    boolean compareError(SQLException e, Db.Error error) {\n        Integer code = mErrorCodes.get(error);\n        return (code != null && e.getErrorCode() == code);\n    }\n\n    @Override\n    String forceIndexClause(String index) {\n        return \" FORCE INDEX (\" + index + ')';\n    }\n\n    @Override String getIFNULL(String column1, String column2) {\n        return \"IFNULL(\" + column1 + \", \" + column2 + \")\";\n    }\n\n    @Override\n    DbPool.PoolConfig getPoolConfig() {\n        return new MySQLConfig();\n    }\n    \n    @Override\n    public boolean databaseExists(Connection conn, String databaseName)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        int numSchemas = 0;\n        \n        try {\n            stmt = conn.prepareStatement(\n                \"SELECT COUNT(*) FROM INFORMATION_SCHEMA.SCHEMATA \" +\n                \"WHERE schema_name = ?\");\n            stmt.setString(1, databaseName);\n            rs = stmt.executeQuery();\n            rs.next();\n            numSchemas = rs.getInt(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to determine whether database exists\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return (numSchemas > 0);\n    }\n\n    static final class MySQLConfig extends DbPool.PoolConfig {\n        MySQLConfig() {\n            mDriverClassName = \"com.mysql.jdbc.Driver\";\n            mPoolSize = 100;\n            mRootUrl = \"jdbc:mysql://\" + LC.mysql_bind_address.value() + \":\" + LC.mysql_port.value() + \"/\";\n            mConnectionUrl = mRootUrl + \"zimbra\";\n            mLoggerUrl = \"jdbc:mysql://\" + LC.logger_mysql_bind_address.value() + \":\" + LC.logger_mysql_port.value() + \"/\";\n            mSupportsStatsCallback = true;\n            mDatabaseProperties = getMySQLProperties();\n\n            // override pool size if specified in prefs\n            String maxActive = (String) mDatabaseProperties.get(\"maxActive\");\n            if (maxActive != null) {\n                try {\n                    mPoolSize = Integer.parseInt(maxActive);\n                } catch (NumberFormatException nfe) {\n                    ZimbraLog.system.warn(\"exception parsing 'maxActive' pref; defaulting pool size to \" + mPoolSize, nfe);\n                }\n            }\n            ZimbraLog.misc.debug(\"Setting connection pool size to \" + mPoolSize);\n        }\n\n        private static Properties getMySQLProperties() {\n            Properties props = new Properties();\n\n            props.put(\"cacheResultSetMetadata\", \"true\");\n            props.put(\"cachePrepStmts\", \"true\");\n            // props.put(\"cacheCallableStmts\", \"true\");\n            props.put(\"prepStmtCacheSize\", \"25\");        \n            // props.put(\"prepStmtCacheSqlLmiit\", \"256\");\n            props.put(\"autoReconnect\", \"true\");\n            props.put(\"useUnicode\", \"true\");\n            props.put(\"characterEncoding\", \"UTF-8\");\n            props.put(\"dumpQueriesOnException\", \"true\");\n\n            // props.put(\"connectTimeout\", \"0\");    // connect timeout in msecs\n            // props.put(\"initialTimeout\", \"2\");    // time to wait between re-connects\n            // props.put(\"maxReconnects\", \"3\"\");    // max number of reconnects to attempt\n\n            // Set/override MySQL Connector/J connection properties from localconfig.\n            // Localconfig keys with \"zimbra_mysql_connector_\" prefix are used.\n            final String prefix = \"zimbra_mysql_connector_\";\n            for (String key : LC.getAllKeys()) {\n                if (!key.startsWith(prefix))\n                    continue;\n                String prop = key.substring(prefix.length());\n                if (prop.length() > 0 && !prop.equalsIgnoreCase(\"logger\")) {\n                    props.put(prop, LC.get(key));\n                    ZimbraLog.system.info(\"Setting mysql connector property: \" + prop + \"=\" + LC.get(key));\n                }\n            }\n\n            // These properties cannot be set with \"zimbra_mysql_connector_\" keys.\n            props.put(\"user\", LC.zimbra_mysql_user.value());\n            props.put(\"password\", LC.zimbra_mysql_password.value());\n\n            return props;\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "a50d27f0bb38c4cfcdd843f53c1b0037318ecee7",
    "commit_msg": "(split)bug: 29563\n\nFirst pass at SQLite support.  It pretty much works, though disk I/O performance is crappy.  Notes:\n\n  - no FOREIGN KEY support; cascading deletes done by TRIGGER\n  - trigger SQL includes ';', so we use a different statement delimiter in create_database.sql\n  - JDBC driver can't do <sql> ant tasks, so use premade zimbra.db for now\n  - must ATTACH a database before using it (only done by Mailbox and search, so other DB accessors are broken under SQLite for now)\n  - still doing mboxgroups rather than dbfile-per-mailbox\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 104962",
    "original_file": "MySQL.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 8,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.util.ZimbraApplication;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Date;\n\npublic class DbPendingAclPush {\n\n    public static String TABLE_PENDING_ACL_PUSH = \"pending_acl_push\";\n\n    private static boolean supported;\n\n    static {\n         supported = ZimbraApplication.getInstance().supports(DbPendingAclPush.class);\n    }\n\n    public static void queue(Mailbox mbox, int itemId) throws ServiceException {\n        if (!supported)\n            return;\n        if (mbox == null)\n            return;\n        ZimbraLog.mailbox.debug(\"Queuing for ACL push - mailbox %s item %s\", mbox.getId(), itemId);\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\n                    \"INSERT INTO \" + TABLE_PENDING_ACL_PUSH + \" (mailbox_id, item_id, date) VALUES (?, ?, ?)\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, itemId);\n            stmt.setLong(3, System.currentTimeMillis());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\n                    \"Unable to queue for ACL push - mailbox \" + mbox.getId() + \" item \" + itemId, e);\n        } finally {\n            conn.closeQuietly(stmt);\n        }\n    }\n\n    public static Multimap<Integer, Integer> getEntries(Date uptoTime) throws ServiceException {\n        Multimap<Integer, Integer> mboxIdToItemIds = HashMultimap.create();\n        DbConnection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        ZimbraLog.misc.debug(\"Getting entries recorded before %s for ACL push\", uptoTime);\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                    \"SELECT mailbox_id, item_id FROM \" + TABLE_PENDING_ACL_PUSH + \" WHERE date < ?\");\n            stmt.setLong(1, uptoTime.getTime());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                mboxIdToItemIds.put(rs.getInt(1), rs.getInt(2));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get entries recorded before \" + uptoTime + \" for ACL push\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n        return mboxIdToItemIds;\n    }\n\n    public static void deleteEntries(Date uptoTime) throws ServiceException {\n        ZimbraLog.misc.debug(\"Deleting entries for ACL push before %s\", uptoTime);\n        DbConnection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                    \"DELETE FROM \" + TABLE_PENDING_ACL_PUSH + \" WHERE date < ?\");\n            stmt.setLong(1, uptoTime.getTime());\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete UID's\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "ea15827b23f0932cbd1268fdea078cffd79bcf59",
    "commit_msg": "(split)bug: 67380 - SendShareNotificationTest.shareByAdmin unit test failure - java.sql.SQLIntegrityConstraintViolationException\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=67380\n\nCopied from Perforce\n Change: 339120",
    "original_file": "DbPendingAclPush.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 9,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbSearchConstraints.NumericRange;\nimport com.zimbra.cs.db.DbSearchConstraints.StringRange;\nimport com.zimbra.cs.db.DbSearchConstraintsNode.NodeType;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.index.SortBy.SortCriterion;\nimport com.zimbra.cs.index.SortBy.SortDirection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Tag;\n\npublic class DbSearch {\n\n    private static Log sLog = ZimbraLog.index_search;\n\n    public static final class SearchResult {\n        public int    id;\n        public int    indexId;\n        public byte   type;\n        public Object sortkey;\n        public Object extraData;\n\n        public enum ExtraData { NONE, MAIL_ITEM, IMAP_MSG, MODSEQ, PARENT, MODCONTENT };\n\n        public static class SizeEstimate {\n            public SizeEstimate() {}\n            public SizeEstimate(int initialval) { mSizeEstimate = initialval; }\n            public int mSizeEstimate;\n        }\n\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort, boolean inDumpster) throws SQLException, ServiceException {\n            return createResult(rs, sort, ExtraData.NONE, inDumpster);\n        }\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort, ExtraData extra, boolean inDumpster) throws SQLException, ServiceException {\n            SearchResult result = new SearchResult();\n            result.id      = rs.getInt(COLUMN_ID);\n            result.indexId = rs.getInt(COLUMN_INDEXID);\n            result.type    = rs.getByte(COLUMN_TYPE);\n            switch (sort.getCriterion()) {\n                case SUBJECT:\n                case SENDER:\n                case NAME:\n                case NAME_NATURAL_ORDER:\n                    result.sortkey = rs.getString(COLUMN_SORTKEY);\n                    break;\n                case SIZE:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY));\n                    break;\n                case NONE:\n                    // note that there's no sort column in the result set for SORT_NONE\n                    break;\n                default:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY) * 1000L);\n                    break;\n            }\n\n            // note that there's no sort column in the result set for SORT_NONE\n            int offset = sort.getCriterion() == SortCriterion.NONE ? COLUMN_SORTKEY - 1 : COLUMN_SORTKEY;\n            if (extra == ExtraData.MAIL_ITEM) {\n                result.extraData = DbMailItem.constructItem(rs, offset, inDumpster);\n            } else if (extra == ExtraData.IMAP_MSG) {\n                int flags = rs.getBoolean(offset + 2) ? Flag.BITMASK_UNREAD | rs.getInt(offset + 3) : rs.getInt(offset + 3);\n                result.extraData = new ImapMessage(result.id, result.type, rs.getInt(offset + 1), flags, rs.getLong(offset + 4));\n            } else if (extra == ExtraData.MODSEQ || extra == ExtraData.PARENT || extra==ExtraData.MODCONTENT) {\n                int value = rs.getInt(offset + 1);\n                result.extraData = rs.wasNull() ? -1 : value;\n            }\n            return result;\n        }\n\n        @Override public String toString() {\n            return sortkey + \" => (\" + id + \",\" + type + \")\";\n        }\n\n        @Override public int hashCode() {\n            return id;\n        }\n\n        @Override public boolean equals(Object obj) {\n            SearchResult other = (SearchResult) obj;\n            return other.id == id;\n        }\n        \n        private static class SearchResultComparator implements Comparator<SearchResult> {\n            private SortBy mSort;\n            SearchResultComparator(SortBy sort)  { mSort = sort; }\n\n            @Override public int compare(SearchResult o1, SearchResult o2) {\n                switch (mSort.getCriterion()) {\n                    case SIZE:\n                    case DATE:\n                        long date1 = (Long) o1.sortkey;\n                        long date2 = (Long) o2.sortkey;\n                        if (date1 != date2) {\n                            long diff;\n                            if (mSort.getDirection() == SortDirection.DESCENDING) {\n                                diff = date2 - date1;\n                            } else {\n                                diff = date1 - date2;\n                            }\n                            return (diff > 0) ? 1 : -1;\n                        }\n                        // fall through to ID-based comparison below!\n                        break;\n                    case SENDER:\n                    case SUBJECT:\n                    case NAME:\n                    case NAME_NATURAL_ORDER:\n                        String s1 = (String) o1.sortkey;\n                        String s2 = (String) o2.sortkey;\n                        if (!StringUtil.equal(s1, s2)) {\n                            if (mSort.getDirection() == SortDirection.DESCENDING) {\n                                return StringUtil.compareTo(s2, s1);\n                             } else {\n                                return StringUtil.compareTo(s1, s2);\n                             }\n                        }\n                        break;\n                    case ID:\n                    case NONE:\n                        break;\n                    default:\n                        throw new UnsupportedOperationException(\"SearchResultComparator not implemented \" +\n                                                                \" for anything except for DATE and SIZE right now. \" +\n                                                                \" Feel free to fix it!\"); \n                }\n                if (mSort.getDirection() == SortDirection.DESCENDING) {\n                    return o2.id - o1.id;\n                } else {\n                    return o1.id - o2.id;\n                }\n            }\n        }\n        \n        public static Comparator<SearchResult> getComparator(SortBy sort) {\n            return new SearchResultComparator(sort);\n        }\n    }\n\n    // alias the sort column b/c of ambiguity problems (the sort column is included twice in the \n    // result set, and MySQL chokes on the ORDER BY when we do a UNION query (doesn't know\n    // which 2 of the 4 sort columns are the \"right\" ones to use)\n    public static final String SORT_COLUMN_ALIAS = \"sortcol\";\n    \n    /**\n     * @param fieldName\n     * @return TRUE if this field is case-sensitive for search/sort -- ie do we need to\n     *         do an UPPER(fieldName) on it in places?\n     */\n    private static boolean isCaseSensitiveField(String fieldName) {\n        // we need to handle things like \"mi.sender\" for the sender column, etc\n        // so look for the last . in the fieldname, return the string after that.\n        String colNameAfterPeriod; \n        int periodOffset = fieldName.lastIndexOf('.');\n        if (periodOffset <= 0 && periodOffset < (fieldName.length()+1))\n            colNameAfterPeriod = fieldName;\n        else\n            colNameAfterPeriod = fieldName.substring(periodOffset+1);\n        \n        return (colNameAfterPeriod.equals(\"sender\") || \n                        colNameAfterPeriod.equals(\"subject\") ||\n                        colNameAfterPeriod.equals(\"name\")); \n    }\n\n    private static String sortField(SortBy sort, boolean useAlias, boolean includeCollation) {\n        String str;\n        boolean stringVal = false;\n        switch (sort.getCriterion()) {\n            case SENDER:   str = \"mi.sender\";   stringVal = true;  break;\n            case SUBJECT:  str = \"mi.subject\";  stringVal = true;  break;\n            case NAME_NATURAL_ORDER:\n            case NAME:     str = \"mi.name\";     stringVal = true;  break;\n            case ID:       str = \"mi.id\";    break;\n            case SIZE:     str = \"mi.size\";  break;\n            case DATE:\n            default:       str = \"mi.date\";  break; \n            case NONE:     return null;\n        }\n        \n        if (useAlias) {\n            str = SORT_COLUMN_ALIAS; // still need the stringVal setting above!\n        } else {\n            if (stringVal && Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) \n                str = \"UPPER(\" + str + \")\";\n        }\n\n        // tim: back this out for now, but leave code stub here until I deal with it\n        // see bugs 22665, 36579\n        //if (Db.supports(Db.Capability.REQUEST_UTF8_UNICODE_COLLATION) && stringVal && includeCollation) \n        //    str += \" COLLATE utf8_unicode_ci\";\n\n        return str;\n    }\n    \n    /**\n     * generate a column-reference for the sort-by column.  This column reference\n     * goes at the beginning of the SELECT statement (the ORDER BY part is generated\n     * by sortQuery() below)\n     */\n    static String sortKey(SortBy sort) {\n        String field = sortField(sort, false, false);\n        // note that there's no sort column in the result set for SORT_NONE\n        if (field == null)\n            return \"\";\n        return \", \" + field + \" AS \" + SORT_COLUMN_ALIAS;\n    }\n\n    static String sortQuery(SortBy sort) {\n        return sortQuery(sort, false);\n    }\n\n    /**\n     * Generate the ORDER BY part that goes at the end of the select\n     */\n    static String sortQuery(SortBy sort, boolean useAlias) {\n        // note that there's no need for an ORDER BY clause for SORT_NONE\n        if (sort.getCriterion() == SortCriterion.NONE)\n            return \"\";\n\n        String direction = sort.getDirection() == SortDirection.DESCENDING ? \" DESC\" : \"\";\n        StringBuilder statement = new StringBuilder(\" ORDER BY \");\n        statement.append(sortField(sort, useAlias, true)).append(direction);\n        // when two items match in their sort field, let's use item ID as the tie breaker\n        //   (commented out as a result of perf issues -- see bug 50469)\n//        statement.append(\", mi.id\").append(direction);\n        return statement.toString();\n    }\n\n\n    public static int countResults(Connection conn, DbSearchConstraintsNode node, Mailbox mbox, boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // Assemble the search query\n        StringBuilder statement = new StringBuilder(\"SELECT count(*) \");\n        statement.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \"mi\", inDumpster));\n        statement.append(\" WHERE \").append(DbMailItem.IN_THIS_MAILBOX_AND);\n        int num = DebugConfig.disableMailboxGroups ? 0 : 1;\n        \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            num += encodeConstraint(mbox, node, null, false, statement, conn);\n\n            stmt = conn.prepareStatement(statement.toString());\n            int pos = 1;\n            pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n            pos = setSearchVars(stmt, node, pos, null, false);\n\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: \" + statement);\n\n            assert(pos == num + 1); \n            rs = stmt.executeQuery();\n            rs.next();\n            return rs.getInt(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // Indexes on mail_item table\n    private static final String MI_I_MBOX_FOLDER_DATE = \"i_folder_id_date\";\n//    private static final String MI_I_MBOX_ID_PKEY     = \"PRIMARY\";\n    private static final String MI_I_MBOX_PARENT      = \"i_parent_id\";\n    private static final String MI_I_MBOX_INDEX       = \"i_index_id\";\n//    private static final String MI_I_MBOX_DATE        = \"i_date\";\n//    private static final String MI_I_MBOX_TAGS_DATE   = \"i_tags_date\";\n//    private static final String MI_I_MBOX_FLAGS_DATE  = \"i_flags_date\";\n//    private static final String MI_I_MBOX_TYPE        = \"i_type\";\n//    private static final String MI_I_MBOX_UNREAD      = \"i_unread\";\n//    private static final String MI_I_MBOX_MODMETADATA = \"i_mod_metadata\";\n//    private static final String MI_I_MBOX_FOLDER_NAME = \"i_name_folder_id\";\n\n    private static final String NO_HINT = \"\";\n\n    private static String getForceIndexClause(DbSearchConstraintsNode node, SortBy sort, boolean hasLimit) {\n        if (LC.search_disable_database_hints.booleanValue())\n            return NO_HINT;\n\n        if (!Db.supports(Db.Capability.FORCE_INDEX_EVEN_IF_NO_SORT) && sort.getCriterion() == SortCriterion.NONE)\n            return NO_HINT;\n        \n        String index = null;\n\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        DbSearchConstraints constraints = node.getSearchConstraints();\n        if (ntype == DbSearchConstraintsNode.NodeType.LEAF) {\n            if (!constraints.itemIds.isEmpty()) {\n                return \"\";\n            } else if (constraints.convId > 0) {\n                index = MI_I_MBOX_PARENT;\n            } else if (!constraints.indexIds.isEmpty()) {\n                index = MI_I_MBOX_INDEX;\n            } else if (sort.getCriterion() == SortCriterion.DATE && hasLimit) {\n                // Whenever we learn a new case of mysql choosing wrong index, add a case here.\n                if (constraints.isSimpleSingleFolderMessageQuery()) {\n                    // Optimization for folder query\n                    //\n                    // If looking at a single folder and sorting by date with a limit,\n                    // force the use of i_folder_id_date index.  Typical example of\n                    // such a query is the default \"in:Inbox\" search.\n                    index = MI_I_MBOX_FOLDER_DATE;\n                }\n            }\n        }\n\n        return Db.forceIndex(index);\n    }\n\n    // put these into constants so that people can easily tell what is dependent on the positons\n    private static final int COLUMN_ID      = 1;\n    private static final int COLUMN_INDEXID = 2;\n    private static final int COLUMN_TYPE    = 3;\n    private static final int COLUMN_SORTKEY = 4;\n\n    private static final String encodeSelect(Mailbox mbox, SortBy sort, SearchResult.ExtraData extra,\n                                             boolean includeCalTable, DbSearchConstraintsNode node,\n                                             boolean validLIMIT, boolean inDumpster) {\n        /*\n         * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi [, appointment AS ap]\n         *    [FORCE INDEX (...)]\n         *    WHERE mi.mailboxid=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND\n         * \n         *  If you change the first for parameters, you must change the COLUMN_* values above!\n         */\n        StringBuilder select = new StringBuilder(\"SELECT mi.id, mi.index_id, mi.type\").append(sortKey(sort));\n        if (extra == SearchResult.ExtraData.MAIL_ITEM)\n            select.append(\", \" + DbMailItem.DB_FIELDS);\n        else if (extra == SearchResult.ExtraData.IMAP_MSG)\n            select.append(\", mi.imap_id, mi.unread, mi.flags, mi.tags\");\n        else if (extra == SearchResult.ExtraData.MODSEQ)\n            select.append(\", mi.mod_metadata\");\n        else if (extra == SearchResult.ExtraData.PARENT)\n            select.append(\", mi.parent_id\");\n        else if (extra == SearchResult.ExtraData.MODCONTENT)\n            select.append(\", mi.mod_content\");\n\n        select.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \"mi\", inDumpster));\n        if (includeCalTable) \n            select.append(\", \").append(DbMailItem.getCalendarItemTableName(mbox, \"ap\", inDumpster));\n        \n        /*\n         * FORCE INDEX (...)\n         */\n        if (!includeCalTable) // can't force index when selecting from two tables?\n            select.append(getForceIndexClause(node, sort, validLIMIT));\n        \n        /*\n         *  WHERE mi.mailboxId=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND \"\n         */\n        select.append(\" WHERE \");\n        select.append(DbMailItem.getInThisMailboxAnd(mbox.getId(), \"mi\", includeCalTable ? \"ap\" : null));\n        if (includeCalTable)\n            select.append(\" mi.id = ap.item_id AND \");\n        \n        return select.toString();\n    }\n    \n    /**\n     * @param mbox\n     * @param node\n     * @param calTypes\n     * @param inCalTable\n     * @param statement\n     * @param conn\n     * @return Number of constraints encoded \n     * @throws ServiceException\n     */\n    private static final int encodeConstraint(Mailbox mbox, DbSearchConstraintsNode node,\n        byte[] calTypes, boolean inCalTable, StringBuilder statement, Connection conn) \n    throws ServiceException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        int num = 0;\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            boolean first = true;\n            boolean and = ntype == DbSearchConstraintsNode.NodeType.AND;\n            statement.append('(');\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (!first)\n                    statement.append(and ? \" AND \" : \" OR \");\n                num += encodeConstraint(mbox, subnode, calTypes, inCalTable, statement, conn);\n                first = false;\n            }\n            statement.append(\") \");\n            return num;\n        }\n        \n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        c.checkDates();\n        \n        // if there are no possible matches, short-circuit here...\n        TagConstraints tc = TagConstraints.getTagConstraints(mbox, c, conn);\n        if (c.automaticEmptySet() || tc.noMatches) {\n            statement.append(Db.supports(Db.Capability.BOOLEAN_DATATYPE) ?\n                \"FALSE\" : \"0=1\"); \n            return num;\n        }\n        \n        statement.append('(');\n\n        // special-case this one, since there can't be a leading AND here...\n        if (ListUtil.isEmpty(c.types)) {\n            statement.append(\"type NOT IN \" + DbMailItem.NON_SEARCHABLE_TYPES);\n        } else {\n            statement.append(DbUtil.whereIn(\"type\", c.types.size()));\n            num += c.types.size();\n        }\n        \n        num += encode(statement, \"mi.type\", false, c.excludeTypes);\n        num += encode(statement, \"mi.type\", inCalTable, calTypes);\n\n        // if hasTags is NULL then nothing\n        // if hasTags is TRUE then !=0\n        // if hasTags is FALSE then = 0\n        if (c.hasTags != null) {\n            if (c.hasTags.booleanValue())\n                statement.append(\" AND mi.tags != 0\");\n            else\n                statement.append(\" AND mi.tags = 0\");\n        }\n        \n        num += encode(statement, \"mi.tags\", true, tc.searchTagsets);\n        num += encode(statement, \"mi.flags\", true, tc.searchFlagsets);\n        num += encode(statement, \"unread\", true, tc.unread);\n        num += encode(statement, \"mi.folder_id\", true, c.folders);\n        num += encode(statement, \"mi.folder_id\", false, c.excludeFolders);\n        if (c.convId > 0)\n            num += encode(statement, \"mi.parent_id\", true);\n        else\n            num += encode(statement, \"mi.parent_id\", false, c.prohibitedConvIds);\n        num += encode(statement, \"mi.id\", true, c.itemIds);\n        num += encode(statement, \"mi.id\", false, c.prohibitedItemIds);\n        num += encode(statement, \"mi.index_id\", true, c.indexIds);\n        num += encodeRangeWithMinimum(statement, \"mi.date\", c.dates, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_metadata\", c.modified, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_content\", c.modifiedContent, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.size\", c.sizes, 0);\n        num += encodeRange(statement, \"mi.subject\", c.subjectRanges);\n        num += encodeRange(statement, \"mi.sender\", c.senderRanges);\n        \n        Boolean isSoloPart = node.getSearchConstraints().getIsSoloPart();\n        if (isSoloPart != null) {\n            if (isSoloPart.booleanValue()) {\n                statement.append(\" AND mi.parent_id is NULL \");\n            } else {\n                statement.append(\" AND mi.parent_id is NOT NULL \");\n            }\n        }\n        \n        if (c.hasIndexId != null) {\n            if (c.hasIndexId.booleanValue()) {\n                statement.append(\" AND mi.index_id is NOT NULL \");\n            } else {\n                statement.append(\" AND mi.index_id is NULL \");\n            }\n        }\n        \n        if (inCalTable) {\n            num += encodeRangeWithMinimum(statement, \"ap.start_time\", c.calStartDates, 1);\n            num += encodeRangeWithMinimum(statement, \"ap.end_time\", c.calEndDates, 1);\n        }\n\n        statement.append(')');\n        \n        return num;\n    }\n    \n    /**\n     * @return TRUE if some part of this query has a non-appointment select (ie 'type not in (11,15)' non-null \n     */\n    private static final boolean hasMailItemOnlyConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasMailItemOnlyConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasNonAppointmentTypes();\n    }\n    \n    /**\n     * @return TRUE if this constraint needs to do a join with the Appointment table in order to be evaluated\n     */\n    private static final boolean hasAppointmentTableConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasAppointmentTableConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasAppointmentTableConstraints();\n    }\n    \n    \n    static final byte[] APPOINTMENT_TABLE_TYPES = new byte[] { MailItem.TYPE_APPOINTMENT, MailItem.TYPE_TASK };\n\n    public static List<SearchResult> search(List<SearchResult> result, Connection conn, DbSearchConstraints c,\n                                            Mailbox mbox, SortBy sort, SearchResult.ExtraData extra)\n    throws ServiceException {\n        return search(result, conn, c, mbox, sort, extra, false);\n    }\n    \n    public static List<SearchResult> search(List<SearchResult> result, Connection conn, DbSearchConstraints c,\n            Mailbox mbox, SortBy sort, SearchResult.ExtraData extra, boolean inDumpster)\n    throws ServiceException {\n        return search(result, conn, c, mbox, sort, -1, -1, extra, inDumpster);\n    }\n\n    private static <T> List<T> mergeSortedLists(List<T> toRet, List<List<T>> lists, Comparator<? super T> comparator) {\n        for (List<T> l : lists) {\n            toRet.addAll(l);\n        }\n        \n        Collections.sort(toRet, comparator);\n        \n        return toRet;\n    }\n    \n    private static List<SearchResult> intersectSortedLists(List<SearchResult> toRet, List<List<SearchResult>> lists) {\n        if (lists.size() < 0) {\n            return toRet;\n        }\n        //optimize so shortest list is first\n        Collections.sort(lists, new Comparator<List<SearchResult>>() {\n            @Override\n            public int compare(List<SearchResult> l1, List<SearchResult> l2) {\n                return l1.size() - l2.size();\n            }\n        });\n        \n        for (SearchResult result : lists.get(0)) {\n            boolean intersect = true;\n            for (int i = 1; i < lists.size(); i++) {\n                if (!lists.get(i).contains(result)) {\n                    intersect = false;\n                    break;\n                }\n            }\n            if (intersect) {\n                toRet.add(result);\n            }\n        }\n        return toRet;\n    }\n\n    public static List<SearchResult> search(List<SearchResult> result, Connection conn,\n                                            DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                            int offset, int limit, SearchResult.ExtraData extra, boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // this monstrosity for bug 31343\n        if (!Db.supports(Db.Capability.AVOID_OR_IN_WHERE_CLAUSE) || NodeType.OR != node.getNodeType()) {\n            // do it the old way\n            try {\n                return searchInternal(result, conn, node, mbox, sort, offset, limit, extra, inDumpster);\n            } catch (ServiceException se) {\n                boolean splitNodes = false;\n                if (Db.supports(Db.Capability.SQL_PARAM_LIMIT) && (NodeType.LEAF != node.getNodeType())) {\n                    Throwable cause = se;\n                    while (cause != null) {\n                        if (cause instanceof SQLException) {\n                            if (Db.errorMatches((SQLException)cause, Db.Error.TOO_MANY_SQL_PARAMS)) {\n                                sLog.debug(\"Query %s resulted in too many sql params; attempting split clauses into individual queries\", node);\n                                splitNodes = true;\n                                break;\n                            }\n                        }\n                        cause = cause.getCause();\n                    }\n                }\n                if (!splitNodes) {\n                    throw se;\n                }\n            }\n        } \n        // if (where a or b) not supported or if we encountered too many sql params try splitting \n        // run each toplevel OR/AND part as a separate SQL query, then merge\n        // the results in memory\n        List<List<SearchResult>> resultLists = new ArrayList<List<SearchResult>>();\n            \n        for (DbSearchConstraintsNode subNode : node.getSubNodes()) {\n            List<SearchResult> subNodeResults = new ArrayList<SearchResult>();\n            search(subNodeResults, conn, subNode, mbox, sort, offset, limit, extra, inDumpster);\n            resultLists.add(subNodeResults);\n        }\n\n        Comparator<SearchResult> comp = SearchResult.getComparator(sort);\n        if (NodeType.OR == node.getNodeType()) {\n            result = mergeSortedLists(result, resultLists, comp);\n        } else if (NodeType.AND == node.getNodeType()) {\n            result = intersectSortedLists(result, resultLists);\n        } else {\n            throw ServiceException.FAILURE(\"Reached merge/intersect block with something other than OR/AND clause\", null);\n        }\n        return result;\n    }\n        \n    public static List<SearchResult> searchInternal(List<SearchResult> result, Connection conn,\n                                                    DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                                    int offset, int limit, SearchResult.ExtraData extra,\n                                                    boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean hasValidLIMIT = offset >= 0 && limit >= 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder statement = new StringBuilder();\n        int numParams = 0;\n        boolean hasMailItemOnlyConstraints = true;\n        boolean hasAppointmentTableConstraints = hasAppointmentTableConstraints(node);\n        if (hasAppointmentTableConstraints)\n            hasMailItemOnlyConstraints = hasMailItemOnlyConstraints(node);\n        boolean requiresUnion = hasMailItemOnlyConstraints && hasAppointmentTableConstraints;\n        \n        try {\n            if (hasMailItemOnlyConstraints) {\n                if (requiresUnion) {\n                    statement.append(\"(\");\n                }\n                \n                /*\n                 * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi \n                 *    [FORCE INDEX (...)]\n                 *    WHERE mi.mailboxid=? AND\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, false, node, hasValidLIMIT, inDumpster));\n                \n                /*\n                 *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n                 *    ( \n                 *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n                 *       [ AND tags != 0]\n                 *       [ AND tags IN ( ... ) ]\n                 *       [ AND flags IN (...) ] \n                 *       ..etc\n                 *    )   \n                 */\n                numParams += encodeConstraint(mbox, node, \n                    (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), \n                    false, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                }\n            }\n            \n            if (requiresUnion) {\n                /*\n                 * UNION\n                 */\n                statement.append(\" ) UNION ALL (\");\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                /*\n                 * SELECT...again...(this time with \"appointment as ap\")...WHERE...\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, true, node, hasValidLIMIT, inDumpster));\n                numParams += encodeConstraint(mbox, node, APPOINTMENT_TABLE_TYPES, true, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                    \n                    if (requiresUnion) {\n                        statement.append(\")\");\n                    }\n                }\n            }\n            \n            //\n            // TODO FIXME: include COLLATION for sender/subject sort\n            //\n            \n            /*\n             * ORDER BY (sortField) \n             */\n            statement.append(sortQuery(sort, true));\n            \n            /*\n             * LIMIT ?, ? \n             */\n            if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n            }\n\n            /**********************************************************/\n            /* Above here: build statement, below here bind params */\n            /**********************************************************/\n\n            /*\n             * Create the statement and bind all our parameters!\n             */\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: (\"+numParams+\" parameters): \"+statement.toString());\n            \n            if (Db.supports(Db.Capability.SQL_PARAM_LIMIT)) {\n                Db.getInstance().checkParamLimit(numParams);\n            }\n            long startTime = LC.zimbra_slow_logging_enabled.booleanValue() ? System.currentTimeMillis() : 0;\n            \n            stmt = conn.prepareStatement(statement.toString());\n            int param = 1;\n            \n            \n            if (hasMailItemOnlyConstraints) {\n                param = setSearchVars(stmt, node, param, (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), false);\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                param = setSearchVars(stmt, node, param, APPOINTMENT_TABLE_TYPES, true);\n            }\n            \n            /*\n             * Limit query if DB doesn't support LIMIT clause\n             */\n            if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE))\n                stmt.setMaxRows(offset + limit + 1);\n\n            long prepTime = startTime > 0 ? System.currentTimeMillis() - startTime : 0;\n            \n            /*\n             * EXECUTE!\n             */\n            assert(param == numParams+1);\n            rs = stmt.executeQuery();\n            \n            long execTime = startTime > 0 ? System.currentTimeMillis() - startTime - prepTime : 0;\n            \n            /*\n             * Return results\n             */\n            while (rs.next()) {\n                if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                    if (offset-- > 0)\n                        continue;\n                    if (limit-- <= 0)\n                        break;\n                }\n                result.add(SearchResult.createResult(rs, sort, extra, inDumpster));\n            }\n            \n            long fetchTime = startTime > 0 ? System.currentTimeMillis() - startTime - prepTime - execTime: 0;\n            if (prepTime + execTime + fetchTime > LC.zimbra_slow_logging_threshold.longValue()) {\n                sLog.warn(\"Slow SQL (start=%d prep=%d exec=%d fetch=%d rows=%d):\\n\" + statement.toString(),\n                        startTime, prepTime, execTime, fetchTime, result.size());\n            }\n            \n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, byte[] c) throws SQLException {\n        if (c != null && c.length > 0) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, Collection<Byte> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setIntegers(PreparedStatement stmt, int param, Collection<Integer> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (int i: c)\n                stmt.setInt(param++, i);\n        }\n        return param;\n    }\n    \n    private static final int setDateRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.lowest / 1000, Integer.MAX_VALUE)); \n                if (date.highest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.highest / 1000, Integer.MAX_VALUE));\n            }\n        }\n        return param;\n    }\n\n    private static final int setTimestampRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.lowest));\n                if (date.highest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.highest));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setLong(param++, r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setLong(param++, r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setIntRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setInt(param++, (int)r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setInt(param++, (int)r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setStringRange(PreparedStatement stmt, int param, Collection<StringRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (StringRange r: c) { \n                if (r.lowest != null) \n                    stmt.setString(param++, r.lowest.replace(\"\\\\\\\"\", \"\\\"\"));\n                if (r.highest != null)\n                    stmt.setString(param++, r.highest.replace(\"\\\\\\\"\", \"\\\"\"));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongs(PreparedStatement stmt, int param, Collection<Long> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (long l: c)\n                stmt.setLong(param++, l);\n        }\n        return param;\n    }\n\n    private static final int setFolders(PreparedStatement stmt, int param, Collection<Folder> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (Folder f : c) \n                stmt.setInt(param++, f.getId());\n        }\n        return param;\n    }\n\n    private static final int setBooleanAsInt(PreparedStatement stmt, int param, Boolean b) throws SQLException {\n        if (b != null) {\n            stmt.setInt(param++, b.booleanValue() ? 1 : 0);\n        }\n        return param;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @return number of parameters bound (always 0 in this case)\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness) {\n        statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n        return 1;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param o\n     *            if NULL, this function is a NoOp, otherwise puts ? to bind one value\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Object o) {\n        if (o != null) {\n            statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Collection<?> c) {\n        if (!ListUtil.isEmpty(c)) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.size()));\n            return c.size();\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, byte[] c) {\n        if (c != null && c.length > 0) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.length));\n            return c.length;\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @param lowestValue\n     * @return number of parameters bound\n     */\n    private static final int encodeRangeWithMinimum(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.NumericRange> ranges, long lowestValue) {\n        if (ListUtil.isEmpty(ranges))\n            return 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column) ) {\n            column = \"UPPER(\"+column+\")\";\n        }\n\n        int params = 0;\n        for (DbSearchConstraints.NumericRange r : ranges) {\n            boolean lowValid = r.lowest >= lowestValue;\n            boolean highValid = r.highest >= lowestValue;\n            if (!(lowValid || highValid))\n                continue;\n\n            statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n            if (lowValid) {\n                if (r.lowestEqual)\n                    statement.append(\" \" + column + \" >= ?\");\n                else\n                    statement.append(\" \" + column + \" > ?\");\n                params++;\n            }\n            if (highValid) {\n                if (lowValid)\n                    statement.append(\" AND\");\n                if (r.highestEqual)\n                    statement.append(\" \" + column + \" <= ?\");\n                else\n                    statement.append(\" \" + column + \" < ?\");\n                params++;\n            }\n            statement.append(')');\n        }\n        return params;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @return number of parameters bound\n     */\n    private static final int encodeRange(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.StringRange> ranges) {\n        int retVal = 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column)) {\n            column = \"UPPER(\"+column+\")\";\n        }\n        \n        if (!ListUtil.isEmpty(ranges)) {\n            for (DbSearchConstraints.StringRange r : ranges) {\n                statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n                if (r.lowest != null) {\n                    retVal++;\n                    if (r.lowestEqual)\n                        statement.append(\" \" + column + \" >= ?\");\n                    else\n                        statement.append(\" \" + column + \" > ?\");\n                }\n                if (r.highest != null) {\n                    if (r.lowest != null)\n                        statement.append(\" AND\");\n                    retVal++;\n                    if (r.highestEqual)\n                        statement.append(\" \" + column + \" <= ?\");\n                    else\n                        statement.append(\" \" + column + \" < ?\");\n                }\n                statement.append(')');\n            }\n        }\n        return retVal;\n    }\n\n\n    static class TagConstraints {\n        Set<Long> searchTagsets;\n        Set<Long> searchFlagsets;\n        Boolean unread;\n        boolean noMatches;\n\n        static TagConstraints getTagConstraints(Mailbox mbox, DbSearchConstraints c, Connection conn) throws ServiceException {\n            TagConstraints tc = c.tagConstraints = new TagConstraints();\n            if (ListUtil.isEmpty(c.tags) && ListUtil.isEmpty(c.excludeTags))\n                return tc;\n\n            int setFlagMask = 0;\n            long setTagMask = 0;\n\n            if (!ListUtil.isEmpty(c.tags)) {\n                for (Tag tag : c.tags) {\n                    if (tag.getId() == Flag.ID_FLAG_UNREAD) {\n                        tc.unread = Boolean.TRUE; \n                    } else if (tag instanceof Flag) {\n                        setFlagMask |= tag.getBitmask();\n                    } else {\n                        setTagMask |= tag.getBitmask();\n                    }\n                }\n            }\n\n            int flagMask = setFlagMask;\n            long tagMask = setTagMask;\n\n            if (!ListUtil.isEmpty(c.excludeTags)) {\n                for (Tag tag : c.excludeTags) {\n                    if (tag.getId() == Flag.ID_FLAG_UNREAD) {\n                        if (tc.unread == Boolean.TRUE)\n                            tc.noMatches = true;\n                        tc.unread = Boolean.FALSE;\n                    } else if (tag instanceof Flag) {\n                        if ((setFlagMask & tag.getBitmask()) != 0)\n                            tc.noMatches = true;\n                        flagMask |= tag.getBitmask();\n                    } else {\n                        if ((setTagMask & tag.getBitmask()) != 0)\n                            tc.noMatches = true;\n                        tagMask |= tag.getBitmask();\n                    }\n                }\n            }\n\n            // if we know we have no matches (e.g. \"is:flagged and is:unflagged\"), just stop here...\n            if (tc.noMatches)\n                return tc;\n\n            TagsetCache tcFlags = DbMailItem.getFlagsetCache(conn, mbox);\n            TagsetCache tcTags  = DbMailItem.getTagsetCache(conn, mbox);\n            if (setTagMask != 0 || tagMask != 0) {\n                // note that tcTags.getMatchingTagsets() returns null when *all* tagsets match\n                tc.searchTagsets = tcTags.getMatchingTagsets(tagMask, setTagMask);\n                // if no items match the specified tags...\n                if (tc.searchTagsets != null && tc.searchTagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchTagsets = null; // otherwise we encode \"tags IN()\" which MySQL doesn't like\n                }\n            }\n\n            if (setFlagMask != 0 || flagMask != 0) {\n                // note that tcFlags.getMatchingTagsets() returns null when *all* flagsets match\n                tc.searchFlagsets = tcFlags.getMatchingTagsets(flagMask, setFlagMask);\n                // if no items match the specified flags...\n                if (tc.searchFlagsets != null && tc.searchFlagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchFlagsets = null;  // otherwise we encode \"flags IN()\" which MySQL doesn't like\n                }\n            }\n\n            return tc;\n        }\n    }\n    \n    private static int setSearchVars(PreparedStatement stmt, \n        DbSearchConstraintsNode node, int param, \n        byte[] calTypes, boolean inCalTable) throws SQLException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        \n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes())\n                param = setSearchVars(stmt, subnode, param, calTypes, inCalTable);\n            return param;\n        }\n\n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        \n        // if there are no possible matches, short-circuit here...\n        if (c.automaticEmptySet() || c.tagConstraints.noMatches)\n            return param;\n\n        param = setBytes(stmt, param, c.types);\n        param = setBytes(stmt, param, c.excludeTypes);\n        param = setBytes(stmt, param, calTypes);\n        \n        param = setLongs(stmt, param, c.tagConstraints.searchTagsets);\n        param = setLongs(stmt, param, c.tagConstraints.searchFlagsets);\n        param = setBooleanAsInt(stmt, param, c.tagConstraints.unread);\n        param = setFolders(stmt, param, c.folders);\n        param = setFolders(stmt, param, c.excludeFolders);\n        if (c.convId > 0)\n            stmt.setInt(param++, c.convId);\n        else\n            param = setIntegers(stmt, param, c.prohibitedConvIds);\n        param = setIntegers(stmt, param, c.itemIds);\n        param = setIntegers(stmt, param, c.prohibitedItemIds);\n        param = setIntegers(stmt, param, c.indexIds);\n        param = setDateRange(stmt, param, c.dates);\n        param = setLongRangeWithMinimum(stmt, param, c.modified, 1);\n        param = setLongRangeWithMinimum(stmt, param, c.modifiedContent, 1);\n        param = setIntRangeWithMinimum(stmt, param, c.sizes, 0);\n        param = setStringRange(stmt, param, c.subjectRanges);\n        param = setStringRange(stmt, param, c.senderRanges);\n        \n        if (inCalTable) {\n            param = setTimestampRange(stmt, param, c.calStartDates);\n            param = setTimestampRange(stmt, param, c.calEndDates);\n        }\n        \n        return param;\n    }\n\n\n    public static void main(String[] args) throws ServiceException {\n        Mailbox mbox = MailboxManager.getInstance().getMailboxById(1);\n\n        DbSearchConstraints hasTags = new DbSearchConstraints();\n        hasTags.hasTags = true;\n\n        DbSearchConstraints inTrash = new DbSearchConstraints();\n        Set<Folder> folders = new HashSet<Folder>();  folders.add(mbox.getFolderById(null, Mailbox.ID_FOLDER_TRASH));\n        inTrash.folders = folders;\n\n        DbSearchConstraints isUnread = new DbSearchConstraints();\n        Set<Tag> tags = new HashSet<Tag>();  tags.add(mbox.getFlagById(Flag.ID_FLAG_UNREAD));\n        isUnread.tags = tags;\n\n        DbSearchConstraintsInnerNode orClause = DbSearchConstraintsInnerNode.OR();\n        orClause.addSubNode(hasTags);\n        DbSearchConstraintsInnerNode andClause = DbSearchConstraintsInnerNode.AND();\n        andClause.addSubNode(inTrash);\n        andClause.addSubNode(isUnread);\n        orClause.addSubNode(andClause);\n\n        // \"is:unread\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), isUnread, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n        // \"has:tags or (in:trash is:unread)\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), orClause, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "99455af0374ec42e4034680b2c69bf221981355a",
    "commit_msg": "(split)Integrate from ZDESKTOP-721 to HELIX\n\tChange 394702 by dywang@dywang-mac-zd721 on 2012/08/21 14:58:53\n\n       bug: 72299\n\n       Split DB search cononstraints for folders as too many folders\n       involved could hit SQLite's limit on SQLITE_MAX_VARIABLE_NUMBER.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=72299\n\nCopied from Perforce\n Change: 394704",
    "original_file": "DbSearch.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 10,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.taglib.bean;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.cs.mailbox.Contact;\nimport com.zimbra.cs.zclient.ZContact;\nimport com.zimbra.cs.zclient.ZEmailAddress;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\npublic class ZContactBean implements Comparable {\n\n    private ZContact mContact;\n    private String mFileAs;       \n    private boolean mIsGalContact;\n    \n    public ZContactBean(ZContact contact) {\n        mContact = contact;\n    }\n\n    public ZContactBean(ZContact contact, boolean isGalContact) {\n        mContact = contact;\n        mIsGalContact = isGalContact;\n    }\n\n    public boolean getIsGalContact() { return mIsGalContact; }\n\n    public String getId() { return mContact.getId(); }\n    \n    public String getTagIds() { return mContact.getTagIds(); }\n    \n    public String getFlags() { return mContact.getFlags(); }\n    \n    public boolean getHasFlags() { return mContact.hasFlags(); }\n    \n    public boolean getHasTags() { return mContact.hasTags(); }\n    \n    public boolean getIsFlagged() { return mContact.isFlagged(); }\n    \n    public boolean getHasAttachment() { return mContact.hasAttachment(); }\n    \n    public String getFolderId() { return mContact.getFolderId(); }\n\n    public String getRevision() { return mContact.getRevision(); }\n    \n    /**\n     * @return time in msecs\n     */\n    public long getMetaDataChangedDate() { return mContact.getMetaDataChangedDate(); }\n    \n    public Map<String, String> getAttrs() { return mContact.getAttrs(); }\n\n    // fields\n\n    public String getAssistantPhone() { return mContact.getAttrs().get(\"assistantPhone\"); }\n\n    public String getBirthday() { return mContact.getAttrs().get(\"birthday\"); }\n\n    public String getCallbackPhone() { return mContact.getAttrs().get(\"callbackPhone\"); }\n\n    public String getCarPhone() { return mContact.getAttrs().get(\"carPhone\"); }\n\n    public String getCompany() { return mContact.getAttrs().get(\"company\"); }\n\n    public String getCompanyPhone() { return mContact.getAttrs().get(\"companyPhone\"); }\n\n    public String getDescription() { return mContact.getAttrs().get(\"description\"); }\n\n    public String getDepartment() { return mContact.getAttrs().get(\"department\"); }\n\n    public String getEmail() { return mContact.getAttrs().get(\"email\"); }\n\n    public String getEmail2() { return mContact.getAttrs().get(\"email2\"); }\n\n    public String getEmail3() { return mContact.getAttrs().get(\"email3\"); }\n\n    public String getFileAs() { return mContact.getAttrs().get(\"fileAs\"); }\n\n    public String getFirstName() { return mContact.getAttrs().get(\"firstName\"); }\n\n    public String getFullName() { return mContact.getAttrs().get(\"fullName\"); }\n\n    public String getHomeCity() { return mContact.getAttrs().get(\"homeCity\"); }\n\n    public String getHomeCountry() { return mContact.getAttrs().get(\"homeCountry\"); }\n\n    public String getHomeFax() { return mContact.getAttrs().get(\"homeFax\"); }\n\n    public String getHomePhone() { return mContact.getAttrs().get(\"homePhone\"); }\n\n    public String getHomePhone2() { return mContact.getAttrs().get(\"homePhone2\"); }\n\n    public String getHomePostalCode() { return mContact.getAttrs().get(\"homePostalCode\"); }\n\n    public String getHomeState() { return mContact.getAttrs().get(\"homeState\"); }\n\n    public String getHomeStreet() { return mContact.getAttrs().get(\"homeStreet\"); }\n\n    public String getHomeURL() { return mContact.getAttrs().get(\"homeURL\"); }\n\n    public String getInitials() { return mContact.getAttrs().get(\"initials\"); }\n\n    public String getJobTitle() { return mContact.getAttrs().get(\"jobTitle\"); }\n\n    public String getLastName() { return mContact.getAttrs().get(\"lastName\"); }\n\n    public String getMaidenName() { return mContact.getAttrs().get(\"maidenName\"); }\n\n    public String getMiddleName() { return mContact.getAttrs().get(\"middleName\"); }\n\n    public String getMobilePhone() { return mContact.getAttrs().get(\"mobilePhone\"); }\n\n    public String getNamePrefix() { return mContact.getAttrs().get(\"namePrefix\"); }\n\n    public String getNameSuffix() { return mContact.getAttrs().get(\"nameSuffix\"); }\n\n    public String getNickname() { return mContact.getAttrs().get(\"nickname\"); }\n\n    public String getNotes() { return mContact.getAttrs().get(\"notes\"); }\n\n    public String getOffice() { return mContact.getAttrs().get(\"office\"); }\n\n    public String getOtherCity() { return mContact.getAttrs().get(\"otherCity\"); }\n\n    public String getOtherCountry() { return mContact.getAttrs().get(\"otherCountry\"); }\n\n    public String getOtherFax() { return mContact.getAttrs().get(\"otherFax\"); }\n\n    public String getOtherPhone() { return mContact.getAttrs().get(\"otherPhone\"); }\n\n    public String getOtherPostalCode() { return mContact.getAttrs().get(\"otherPostalCode\"); }\n\n    public String getOtherState() { return mContact.getAttrs().get(\"otherState\"); }\n\n    public String getOtherStreet() { return mContact.getAttrs().get(\"otherStreet\"); }\n\n    public String getOtherURL() { return mContact.getAttrs().get(\"otherURL\"); }\n\n    public String getPager() { return mContact.getAttrs().get(\"pager\"); }\n\n    public String getPhoneticFirstName() { return mContact.getAttrs().get(\"phoneticFirstName\"); };\n\n    public String getPhoneticLastName() { return mContact.getAttrs().get(\"phoneticLastName\"); };\n\n    public String getPhoneticCompany() { return mContact.getAttrs().get(\"phoneticCompany\"); };\n\n    public String getTollFree() { return mContact.getAttrs().get(\"tollFree\"); }\n\n    public String getWorkCity() { return mContact.getAttrs().get(\"workCity\"); }\n\n    public String getWorkCountry() { return mContact.getAttrs().get(\"workCountry\"); }\n\n    public String getWorkFax() { return mContact.getAttrs().get(\"workFax\"); }\n\n    public String getWorkPhone() { return mContact.getAttrs().get(\"workPhone\"); }\n\n    public String getWorkPhone2() { return mContact.getAttrs().get(\"workPhone2\"); }\n\n    public String getWorkPostalCode() { return mContact.getAttrs().get(\"workPostalCode\"); }\n\n    public String getWorkState() { return mContact.getAttrs().get(\"workState\"); }\n\n    public String getWorkStreet() { return mContact.getAttrs().get(\"workStreet\"); }\n\n    public String getWorkURL() { return mContact.getAttrs().get(\"workURL\"); }\n\n    public boolean getIsGroup() { return mContact.getIsGroup(); }\n\n    public String getImagePart() { return mContact.getAttachmentPartName(\"image\");}\n\n    /* Comcast specific */\n    public String getHomeAddress() { return mContact.getAttrs().get(\"homeAddress\"); }\n\n    public String getOtherDepartment() { return mContact.getAttrs().get(\"otherDepartment\"); }\n\n    public String getOtherOffice() { return mContact.getAttrs().get(\"otherOffice\"); }\n\n    public String getOtherProfession() { return mContact.getAttrs().get(\"otherProfession\"); }\n    \n    public String getOtherAddress() { return mContact.getAttrs().get(\"otherAddress\"); }\n\n    public String getOtherMgrName() { return mContact.getAttrs().get(\"otherMgrName\"); }\n\n    public String getOtherAsstName() { return mContact.getAttrs().get(\"otherAsstName\"); }\n\n    public String getOtherAnniversary() { return mContact.getAttrs().get(\"anniversary\"); }\n\n    public String getOtherCustom1() { return mContact.getAttrs().get(\"custom1\"); }\n\n    public String getOtherCustom2() { return mContact.getAttrs().get(\"otherCustom2\"); }\n\n    public String getOtherCustom3() { return mContact.getAttrs().get(\"otherCustom3\"); }\n\n    public String getOtherCustom4() { return mContact.getAttrs().get(\"otherCustom4\"); }\n\n    public String getWorkAddress() { return mContact.getAttrs().get(\"workAddress\"); }\n\n    public String getWorkAltPhone() { return mContact.getAttrs().get(\"workAltPhone\"); }\n    \n    public String getWorkMobile() { return mContact.getAttrs().get(\"workMobile\"); }\n\n    public String getIMAddress1() { return mContact.getAttrs().get(\"imAddress1\"); }\n\n    public String getIMAddress2() { return mContact.getAttrs().get(\"imAddress2\"); }\n\n    public String getIMAddress3() { return mContact.getAttrs().get(\"imAddress3\"); }\n\n    public String getWorkEmail2() { return mContact.getAttrs().get(\"workEmail2\"); }\n\n    public String getWorkEmail3() { return mContact.getAttrs().get(\"workEmail3\"); }\n\n    public String getWorkIM1() { return mContact.getAttrs().get(\"workIM1\"); }\n    \n    public String getWorkIM2() { return mContact.getAttrs().get(\"workIM2\"); }\n\n    public String getWorkEmail1() { return mContact.getAttrs().get(\"workEmail1\"); }\n\n    /* end of comcast specific */\n    private static final Pattern sCOMMA = Pattern.compile(\",\");\n    \n    public String[] getGroupMembers() throws ServiceException {\n        String dlist = mContact.getAttrs().get(\"dlist\");\n        if (dlist != null) {\n            try {\n                List<ZEmailAddress> addrs = ZEmailAddress.parseAddresses(dlist, ZEmailAddress.EMAIL_TYPE_TO);\n                List<String> result = new ArrayList<String>(addrs.size());\n                for (ZEmailAddress a : addrs) {\n                    result.add(a.getFullAddressQuoted());\n                }\n                return result.toArray(new String[result.size()]);\n            } catch (ServiceException e) {\n                return sCOMMA.split(dlist);\n            }\n        } else {\n            return new String[0];\n        }\n    }\n\n    public String getGroupMembersPerLine() throws ServiceException {\n        StringBuilder sb = new StringBuilder();\n        for (String addr : getGroupMembers()) {\n            sb.append(addr).append(\"\\n\");\n        }\n        return sb.toString();\n    }\n        \n    public String getDisplayFileAs() {\n        if (mFileAs == null) {\n            try {\n                mFileAs = Contact.getFileAsString(mContact.getAttrs());\n            } catch (ServiceException e) {\n                mFileAs = \"\";\n            }\n        }\n        return mFileAs;\n    }\n    \n    private static final Pattern sCOMMA_OR_SP = Pattern.compile(\"[, ]\");\n    \n    public static boolean anySet(ZContactBean cbean, String s) {\n        if (s == null || s.length() == 0) return false;\n        String[] fields = sCOMMA_OR_SP.split(s);\n        Map<String, String> attrs = cbean.getAttrs();         \n        for (String field: fields) {\n            if (attrs.get(field) != null) return true;\n        }\n        return false;\n    }\n        /**\n     * @return first email from email/2/3 that is set, or an empty string\n     */\n    public String getDisplayEmail() {\n        if (getEmail() != null && getEmail().length() > 0)\n            return getEmail();\n        else if (getEmail2() != null && getEmail2().length() > 0)\n            return getEmail2();\n        else if (getEmail3() != null && getEmail3().length() > 0)\n            return getEmail3();\n        else\n            return \"\";\n    }\n\n    /**\n       *\n       * @return the \"full\" email address suitable for inserting into a To/Cc/Bcc header\n       */\n    public String getFullAddress() {\n        return new ZEmailAddress(getDisplayEmail(), null, getDisplayFileAs(), ZEmailAddress.EMAIL_TYPE_TO).getFullAddress();\n    }\n\n    /**\n     *\n     * @return the gal \"fileAs\" str\n     *\n     */\n    public String getGalFileAsStr() {\n        String fname = getFullName();\n        if (fname == null || fname.length() == 0) {\n            String f = getFirstName();\n            String l = getLastName();\n            StringBuilder sb = new StringBuilder();\n            if (f != null) sb.append(f);\n            if (l != null) {\n                if (sb.length() > 0)\n                    sb.append(' ');\n                sb.append(l);\n            }\n            fname = sb.toString();\n        }\n        return fname;\n    }\n\n    /**\n       *\n       * @return the \"full\" email address suitable for inserting into a To/Cc/Bcc header\n       */\n    public String getGalFullAddress() {\n        return new ZEmailAddress(getDisplayEmail(), null, getGalFileAsStr(), ZEmailAddress.EMAIL_TYPE_TO).getFullAddress();\n    }\n\n    public String getImage() {\n        if (getIsGroup())\n            return \"contacts/ImgGroup.png\";\n        else if (getIsGalContact())\n            return \"startup/ImgGALContact.png\";\n        else\n            return \"contacts/ImgContact.png\";\n    }\n\n    public String getImageAltKey() {\n        if (getIsGroup())\n            return \"ALT_CONTACT_GROUP\";\n        else if (getIsGalContact())\n            return \"ALT_CONTACT_GAL_CONTACT\";\n        else\n            return \"ALT_CONTACT_CONTACT\";\n    }\n\n    public int compareTo(Object obj) {\n        if (!(obj instanceof ZContactBean))\n            return 0;\n        ZContactBean other = (ZContactBean) obj;\n        String name = getIsGalContact() ? getGalFullAddress() : getFullAddress();\n        String oname = other.getIsGalContact() ? other.getGalFullAddress() : other.getFullAddress();\n        return name.compareToIgnoreCase(oname);\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-taglib",
    "commit": "3c1e9f3fd28135111914ef84807a0d65b1b0a784",
    "commit_msg": "bug: 75976 Failed to send message potential XSS\n\nIntegration from helix to main\n\n- Additional Checks for NPE\n- Handling similar case for forward of messages\n\nReviewboard url: https://reviewboard.eng.vmware.com/r/363794/\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=75976\n\nCopied from Perforce\n Change: 389560",
    "original_file": "ZContactBean.java",
    "confidence_score": 0.6
  },
  {
    "serial_no": 11,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009, 2010 Zimbra, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private static final String PRAGMA_JOURNAL_MODE_DEFAULT = \"DELETE\";\n    private static final String PRAGMA_SYNCHRONOUS_DEFAULT  = \"FULL\";\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n    private String journalMode;\n    private String syncMode;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"column id is not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return true;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        cacheSize = LC.sqlite_cache_size.value();\n        if (cacheSize.equals(\"0\"))\n            cacheSize = null;\n        journalMode = LC.sqlite_journal_mode.value();\n        syncMode = LC.sqlite_sync_mode.value();\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" +\n            (cacheSize == null ? \"default\" : cacheSize) + \" cache cache, \" +\n            journalMode + \" journal mode, \" + syncMode + \" sync mode\");\n        super.startup(pool, poolSize);\n    }\n\n    @Override void postCreate(java.sql.Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            pragmas(conn, null);\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(java.sql.Connection conn, String dbname, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        \n        try {\n            String prefix = dbname == null || dbname.equals(\"zimbra\") ? \"\" : dbname + \".\";\n            (stmt = conn.prepareStatement(\"PRAGMA \" + prefix + key +\n                (value == null ? \"\" : \" = \" + value))).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    void pragmas(java.sql.Connection conn, String dbname) throws SQLException {\n        /*\n         * auto_vacuum causes databases to be locked permanently\n         * pragma(conn, dbname, \"auto_vacuum\", \"2\");\n         */\n        pragma(conn, dbname, \"foreign_keys\", \"ON\");\n        if (journalMode != null && !journalMode.equalsIgnoreCase(PRAGMA_JOURNAL_MODE_DEFAULT))\n            pragma(conn, dbname, \"journal_mode\", journalMode);\n        if (syncMode != null && !syncMode.equalsIgnoreCase(PRAGMA_SYNCHRONOUS_DEFAULT))\n            pragma(conn, dbname, \"synchronous\", syncMode);\n        if (cacheSize != null)\n            pragma(conn, dbname, \"cache_size\", cacheSize);\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void optimize(Connection conn, String dbname, int level)\n        throws ServiceException {\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            PreparedStatement stmt = null;\n\n            try {\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(true);\n                if (dbname == null)\n                    dbname = \"zimbra\";\n                registerDatabaseInterest(conn, dbname);\n                if (level > 0 && dbname.endsWith(\"zimbra\")) {\n                    if (level == 2)\n                        (stmt = conn.prepareStatement(\"VACUUM\")).execute();\n                    else\n                        pragma(conn.getConnection(), dbname, \"incremental_vacuum\", null);\n                }\n                (stmt = conn.prepareStatement(\"ANALYZE \" + dbname)).execute();\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(autocommit);\n                ZimbraLog.dbconn.debug(\"sqlite \" +\n                    (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname);\n            } finally {\n                DbPool.quietCloseStatement(stmt);\n            }\n        } catch (Exception e) {\n            throw ServiceException.FAILURE(\"sqlite \" +\n                (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname + \" error\", e);\n        }\n    }\n    \n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n                \n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n            pragmas(conn.getConnection(), dbname);\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.error(\"database \" + dbname + \" attach failed\", e);\n            if (!\"database is already attached\".equals(e.getMessage()))\n                throw e;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n        \n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n        new File(getDatabaseFilename(dbname) + \"-journal\").delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    @Override protected int getInClauseBatchSize() {\n        return 200;\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "87715b0347acc20050252d52d871b93c61789067",
    "commit_msg": "(split)bug: 46058\n\nReinstated localconfig key sqlite_page_size, with 4KB default.  Removed page_size pragma from db.sql and create_database.sql scripts.  With these changes, it's possible to change the page size of newly created databases by changing the value in localconfig and restarting the jetty process.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=46058\n\nCopied from Perforce\n Change: 235935",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 12,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic final class SQLite extends Db {\n\n    private static final String PRAGMA_JOURNAL_MODE_DEFAULT = \"DELETE\";\n    private static final String PRAGMA_SYNCHRONOUS_DEFAULT  = \"FULL\";\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n    private String journalMode;\n    private String pageSize;\n    private String syncMode;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, \"foreign key\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT, \"foreign key\");\n        mErrorCodes.put(Db.Error.TOO_MANY_SQL_PARAMS, \"too many SQL variables\");\n    }\n\n    @Override\n    boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case NON_BMP_CHARACTERS:         return true;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return true;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n            case SQL_PARAM_LIMIT:            return true;\n        }\n        return false;\n    }\n\n    @Override\n    boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override\n    String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override\n    String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override\n    public String bitAND(String expr1, String expr2) {\n        return expr1 + \" & \" + expr2;\n    }\n\n    @Override\n    PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override\n    void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        cacheSize = LC.sqlite_cache_size.value();\n        if (cacheSize.equals(\"0\"))\n            cacheSize = null;\n        journalMode = LC.sqlite_journal_mode.value();\n        pageSize = LC.sqlite_page_size.value();\n        if (pageSize.equals(\"0\"))\n            pageSize = null;\n        syncMode = LC.sqlite_sync_mode.value();\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" +\n            (cacheSize == null ? \"default\" : cacheSize) + \" cache cache, \" +\n            (pageSize == null ? \"default\" : pageSize) + \" page size, \" +\n            journalMode + \" journal mode, \" + syncMode + \" sync mode\");\n        super.startup(pool, poolSize);\n    }\n\n    @Override\n    void postCreate(Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            pragmas(conn, null);\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(Connection conn, String dbname, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n\n        try {\n            String prefix = dbname == null || dbname.equals(\"zimbra\") ? \"\" : dbname + \".\";\n            (stmt = conn.prepareStatement(\"PRAGMA \" + prefix + key +\n                (value == null ? \"\" : \" = \" + value))).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    void pragmas(Connection conn, String dbname) throws SQLException {\n        /*\n         * auto_vacuum causes databases to be locked permanently\n         * pragma(conn, dbname, \"auto_vacuum\", \"2\");\n         */\n        pragma(conn, dbname, \"foreign_keys\", \"ON\");\n        if (journalMode != null && !journalMode.equalsIgnoreCase(PRAGMA_JOURNAL_MODE_DEFAULT))\n            pragma(conn, dbname, \"journal_mode\", journalMode);\n        if (syncMode != null && !syncMode.equalsIgnoreCase(PRAGMA_SYNCHRONOUS_DEFAULT))\n            pragma(conn, dbname, \"synchronous\", syncMode);\n        if (cacheSize != null)\n            pragma(conn, dbname, \"cache_size\", cacheSize);\n        if (pageSize != null)\n            pragma(conn, dbname, \"page_size\", pageSize);\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 6;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(DbConnection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private Connection getInnermostConnection(Connection conn) {\n        Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override\n    public void optimize(DbConnection conn, String dbname, int level)\n        throws ServiceException {\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            PreparedStatement stmt = null;\n\n            try {\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(true);\n                if (dbname == null)\n                    dbname = \"zimbra\";\n                registerDatabaseInterest(conn, dbname);\n                if (level > 0 && dbname.endsWith(\"zimbra\")) {\n                    if (level == 2)\n                        (stmt = conn.prepareStatement(\"VACUUM\")).execute();\n                    else\n                        pragma(conn.getConnection(), dbname, \"incremental_vacuum\", null);\n                }\n                (stmt = conn.prepareStatement(\"ANALYZE \" + dbname)).execute();\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(autocommit);\n                ZimbraLog.dbconn.debug(\"sqlite \" +\n                    (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname);\n            } finally {\n                DbPool.quietCloseStatement(stmt);\n            }\n        } catch (Exception e) {\n            throw ServiceException.FAILURE(\"sqlite \" +\n                (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname + \" error\", e);\n        }\n    }\n\n    @Override\n    public void registerDatabaseInterest(DbConnection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n\n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(DbConnection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n            pragmas(conn.getConnection(), dbname);\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.error(\"database \" + dbname + \" attach failed\", e);\n            if (!\"database is already attached\".equals(e.getMessage()))\n                throw e;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(DbConnection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override\n    public boolean databaseExists(DbConnection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override\n    void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n        new File(getDatabaseFilename(dbname) + \"-journal\").delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\");\n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            if (LC.sqlite_shared_cache_enabled.booleanValue())\n                props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override\n    public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override\n    public String toString() {\n        return \"SQLite\";\n    }\n\n    @Override\n    protected int getInClauseBatchSize() {\n        return 200;\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 13,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Aug 13, 2004\n */\npackage com.zimbra.cs.db;\n\nimport java.io.UnsupportedEncodingException;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.Constants;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.LogFactory;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.TimeoutMap;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.CalendarItem;\nimport com.zimbra.cs.mailbox.Conversation;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.Message;\nimport com.zimbra.cs.mailbox.Note;\nimport com.zimbra.cs.mailbox.SearchFolder;\nimport com.zimbra.cs.mailbox.Tag;\nimport com.zimbra.cs.mailbox.VirtualConversation;\nimport com.zimbra.cs.mailbox.MailItem.PendingDelete;\nimport com.zimbra.cs.mailbox.MailItem.UnderlyingData;\nimport com.zimbra.cs.mailbox.util.TypedIdList;\nimport com.zimbra.cs.pop3.Pop3Message;\nimport com.zimbra.cs.store.MailboxBlob;\nimport com.zimbra.cs.store.StoreManager;\n\npublic class DbMailItem {\n\n    public static final String TABLE_MAIL_ITEM = \"mail_item\";\n    public static final String TABLE_REVISION = \"revision\";\n    public static final String TABLE_APPOINTMENT = \"appointment\";\n    public static final String TABLE_OPEN_CONVERSATION = \"open_conversation\";\n    public static final String TABLE_TOMBSTONE = \"tombstone\";\n\n    private static Log sLog = LogFactory.getLog(DbMailItem.class);\n\n    /** Maps the mailbox id to the set of all tag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by tag. */\n    private static final Map<Long, TagsetCache> sTagsetCache =\n        new TimeoutMap<Long, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    /** Maps the mailbox id to the set of all flag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by flag. */\n    private static final Map<Long, TagsetCache> sFlagsetCache =\n        new TimeoutMap<Long, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    public static final int MAX_SENDER_LENGTH  = 128;\n    public static final int MAX_SUBJECT_LENGTH = 1024;\n    public static final int MAX_TEXT_LENGTH    = 65534;\n    public static final int MAX_MEDIUMTEXT_LENGTH = 16777216;\n\n    public static final String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id = ? AND \";\n    public static final String MAILBOX_ID = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n    public static final String MAILBOX_ID_VALUE = DebugConfig.disableMailboxGroups ? \"\" : \"?, \";\n\n    private static final int RESULTS_STREAMING_MIN_ROWS = 10000; \n    \n    public static final int setMailboxId(PreparedStatement stmt, Mailbox mbox, int pos) throws SQLException {\n        if (!DebugConfig.disableMailboxGroups)\n            stmt.setLong(pos++, mbox.getId());\n        return pos;\n    }\n    \n    public static final String getInThisMailboxAnd(long mboxId, String miAlias, String apAlias) {\n        if (DebugConfig.disableMailboxGroups)\n            return \"\";\n\n        StringBuilder sb = new StringBuilder(miAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        if (apAlias != null) \n            sb.append(apAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        return sb.toString();\n    }\n\n\n    public static void create(Mailbox mbox, UnderlyingData data, String sender) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        if (data == null || data.id <= 0 || data.folderId <= 0 || data.parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item create\", null);\n\n        checkNamingConstraint(mbox, data.folderId, data.name, data.id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getMailItemTableName(mbox) +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"VALUES (\" + MAILBOX_ID_VALUE + \" ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, data.id);\n            stmt.setByte(pos++, data.type);\n            if (data.parentId <= 0)\n                // Messages in virtual conversations are stored with a null parent_id\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, data.parentId);\n            stmt.setInt(pos++, data.folderId);\n            if (data.indexId == null)\n                stmt.setNull(pos++, Types.VARCHAR);\n            else\n                stmt.setString(pos++, data.indexId);\n            if (data.imapId <= 0)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, data.imapId);\n            stmt.setInt(pos++, data.date);\n            stmt.setLong(pos++, data.size);\n            if (data.locator != null)\n                stmt.setString(pos++, data.locator);\n            else\n                stmt.setNull(pos++, Types.VARCHAR);\n            stmt.setString(pos++, data.getBlobDigest());\n            if (data.type == MailItem.TYPE_MESSAGE || data.type == MailItem.TYPE_CHAT || data.type == MailItem.TYPE_FOLDER)\n                stmt.setInt(pos++, data.unreadCount);\n            else\n                stmt.setNull(pos++, Types.BOOLEAN);\n            stmt.setInt(pos++, data.flags);\n            stmt.setLong(pos++, data.tags);\n            stmt.setString(pos++, checkSenderLength(sender));\n            stmt.setString(pos++, checkSubjectLength(data.subject));\n            stmt.setString(pos++, data.name);\n            stmt.setString(pos++, checkMetadataLength(data.metadata));\n            stmt.setInt(pos++, data.modMetadata);\n            if (data.dateChanged > 0)\n                stmt.setInt(pos++, data.dateChanged);\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            stmt.setInt(pos++, data.modContent);\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n\n            // Track the tags and flags for fast lookup later\n            if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).addTagset(data.tags);\n            if (areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(data.flags);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            else\n                throw ServiceException.FAILURE(\"writing new object of type \" + data.type, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static void checkNamingConstraint(Mailbox mbox, int folderId, String name, int modifiedItemId) throws ServiceException {\n        if (name == null || name.equals(\"\"))\n            return;\n        if (Db.supports(Db.Capability.UNIQUE_NAME_INDEX) && !Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON))\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND id <> ? AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, modifiedItemId);\n            stmt.setString(pos++, StringUtil.trimTrailingSpaces(name.toUpperCase()));\n            rs = stmt.executeQuery();\n            if (!rs.next() || rs.getInt(1) > 0)\n                throw MailServiceException.ALREADY_EXISTS(name);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"checking for naming conflicts\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void copy(MailItem item, int id, Folder folder, String indexId, int parentId, String locator, String metadata)\n    throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (id <= 0 || indexId == null || folder == null || parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + table +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + MAILBOX_ID_VALUE +\n                        \" ?, type, ?, ?, ?, ?, date, size, ?, blob_digest, unread,\" +\n                        \" flags, tags, sender, subject, name, ?, ?, ?, ? FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, id);                            // ID\n            if (parentId <= 0)\n                stmt.setNull(pos++, Types.INTEGER);            // PARENT_ID null for messages in virtual convs\n            else\n                stmt.setInt(pos++, parentId);                  //   or, PARENT_ID specified by caller\n            stmt.setInt(pos++, folder.getId());                // FOLDER_ID\n            stmt.setString(pos++, indexId);                       // INDEX_ID\n            stmt.setInt(pos++, id);                            // IMAP_ID is initially the same as ID\n            if (locator != null)\n                stmt.setString(pos++, locator);                // VOLUME_ID specified by caller\n            else\n                stmt.setNull(pos++, Types.VARCHAR);            //   or, no VOLUME_ID\n            stmt.setString(pos++, checkMetadataLength(metadata));  // METADATA\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(id, e);\n            else\n                throw ServiceException.FAILURE(\"copying \" + MailItem.getNameForType(item ) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void icopy(MailItem source, UnderlyingData data, boolean shared) throws ServiceException {\n        Mailbox mbox = source.getMailbox();\n        if (data == null || data.id <= 0 || data.folderId <= 0 || data.parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item i-copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, data.folderId, source.getName(), data.id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            String flags;\n            if (!shared)\n                flags = \"flags\";\n            else if (Db.supports(Db.Capability.BITWISE_OPERATIONS))\n                flags = \"flags | \" + Flag.BITMASK_COPIED;\n            else\n                flags = \"CASE WHEN \" + Db.bitmaskAND(\"flags\", Flag.BITMASK_COPIED) + \" THEN flags ELSE flags + \" + Flag.BITMASK_COPIED + \" END\";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + table +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id +\n                        \" ?, type, parent_id, ?, ?, ?, date, size, ?, blob_digest,\" +\n                        \" unread, \" + flags + \", tags, sender, subject, name, metadata, ?, ?, ? FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, data.id);                       // ID\n            stmt.setInt(pos++, data.folderId);                 // FOLDER_ID\n            stmt.setString(pos++, data.indexId);               // INDEX_ID\n            stmt.setInt(pos++, data.imapId);                   // IMAP_ID\n            if (data.locator != null)\n                stmt.setString(pos++, data.locator);           // VOLUME_ID\n            else\n                stmt.setNull(pos++, Types.TINYINT);            //   or, no VOLUME_ID\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, source.getId());\n            stmt.executeUpdate();\n            stmt.close();\n\n            boolean needsTag = shared && !source.isTagged(Flag.ID_FLAG_COPIED);\n\n            if (needsTag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(source.getInternalFlagBitmask() | Flag.BITMASK_COPIED);\n\n            if (needsTag || source.getParentId() > 0) {\n                boolean altersMODSEQ = source.getParentId() > 0;\n                String updateChangeID = (altersMODSEQ ? \", mod_metadata = ?, change_date = ?\" : \"\");\n                stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = NULL, flags = \" + flags + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                pos = 1;\n                if (altersMODSEQ) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, source.getId());\n                stmt.executeUpdate();\n                stmt.close();\n            }\n\n            if (source instanceof Message && source.getParentId() <= 0)\n                changeOpenTarget(Mailbox.getHash(((Message) source).getNormalizedSubject()), source, data.id);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            else\n                throw ServiceException.FAILURE(\"i-copying \" + MailItem.getNameForType(source) + \": \" + source.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void snapshotRevision(MailItem item, int version) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(version >= 1);\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getRevisionTableName(mbox) +\n                        \"(\" + mailbox_id + \"item_id, version, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id + \"id, ?, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, version);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to copy revision data\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getId(), e);\n            else\n                throw ServiceException.FAILURE(\"saving revision info for \" + MailItem.getNameForType(item) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void purgeRevisions(MailItem item, int highestPurged) throws ServiceException {\n        if (highestPurged <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getRevisionTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ? AND version <= ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.setInt(pos++, highestPurged);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"purging revisions for \" + MailItem.getNameForType(item) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void changeType(MailItem item, byte type) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET type = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, type);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new type for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(MailItem item, Folder folder) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != folder.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            int pos = 1;\n            boolean hasIndexId = false;\n            if (item instanceof Folder) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET parent_id = ?, folder_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                stmt.setInt(pos++, folder.getId());\n            } else if (item instanceof Conversation && !(item instanceof VirtualConversation)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ?\");\n            } else {\n                // set the indexId, in case it changed (moving items out of junk can trigger an index ID change)\n                hasIndexId = true;\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, index_id = ?, mod_metadata = ?, change_date = ? \" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            }\n            stmt.setInt(pos++, folder.getId());\n            if (hasIndexId)\n                if (item.getIndexId() == null)\n                    stmt.setNull(pos++, Types.VARCHAR);\n                else\n                    stmt.setString(pos++, item.getIndexId());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            else\n                throw ServiceException.FAILURE(\"writing new folder data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(List<Message> msgs, Folder folder) throws ServiceException {\n        if (msgs == null || msgs.isEmpty())\n            return;\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            // commented out because at present messages cannot have names (and thus can't have naming conflicts)\n//            if (!Db.supports(Db.Capability.UNIQUE_NAME_INDEX) || Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) {\n//                stmt = conn.prepareStatement(\"SELECT mi.name\" +\n//                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getMailItemTableName(mbox, \"m2\") +\n//                        \" WHERE mi.id IN \" + DbUtil.suitableNumberOfVariables(itemIDs) +\n//                        \" AND mi.name IS NOT NULL and m2.name IS NOT NULL\" +\n//                        \" AND m2.folder_id = ? AND mi.id <> m2.id\" +\n//                        \" AND \" + (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) ? \"UPPER(mi.name) = UPPER(m2.name)\" : \"mi.name = m2.name\") +\n//                        \" AND mi.mailbox_id = ? AND m2.mailbox_id = ?\");\n//                int pos = 1;\n//                for (Message msg : msgs)\n//                    stmt.setInt(pos++, msg.getId());\n//                stmt.setInt(pos++, folder.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                rs = stmt.executeQuery();\n//                if (rs.next())\n//                    throw MailServiceException.ALREADY_EXISTS(rs.getString(1));\n//                rs.close();\n//                stmt.close();\n//            }\n\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            for (int i = 0; i < msgs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), msgs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, msgs.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n//            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n//                throw MailServiceException.ALREADY_EXISTS(msgs.toString(), e);\n//            else\n            throw ServiceException.FAILURE(\"writing new folder data for messages\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void setIndexIds(Mailbox mbox, List<Message> msgs) throws ServiceException {\n        if (msgs == null || msgs.isEmpty())\n            return;\n        \n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < msgs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), msgs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET index_id = id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, msgs.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n//            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n//                throw MailServiceException.ALREADY_EXISTS(msgs.toString(), e);\n//            else\n            throw ServiceException.FAILURE(\"writing new folder data for messages\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n\n    public static void setParent(MailItem child, MailItem parent) throws ServiceException {\n        setParent(new MailItem[] { child }, parent);\n    }\n\n    public static void setParent(MailItem[] children, MailItem parent) throws ServiceException {\n        if (children == null || children.length == 0)\n            return;\n        Mailbox mbox = children[0].getMailbox();\n        if (mbox != parent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < children.length; i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), children.length - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (parent == null || parent instanceof VirtualConversation)\n                    stmt.setNull(pos++, Types.INTEGER);\n                else\n                    stmt.setInt(pos++, parent.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, children[index].getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"adding children to parent \" + (parent == null ? \"NULL\" : parent.getId() + \"\"), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void reparentChildren(MailItem oldParent, MailItem newParent) throws ServiceException {\n        if (oldParent == newParent)\n            return;\n        Mailbox mbox = oldParent.getMailbox();\n        if (mbox != newParent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation = (oldParent instanceof VirtualConversation ? \"id = ?\" : \"parent_id = ?\");\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(oldParent) +\n                        \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + relation);\n            int pos = 1;\n            if (newParent instanceof VirtualConversation)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, newParent.getId());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, oldParent instanceof VirtualConversation ? ((VirtualConversation) oldParent).getMessageId() : oldParent.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new parent for children of item \" + oldParent.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveMetadata(MailItem item, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void persistCounts(MailItem item, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET size = ?, unread = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getUnreadCount());\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, item.getModifiedSequence());\n            if (item.getChangeDate() > 0)\n                stmt.setInt(pos++, (int) (item.getChangeDate() / 1000));\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            stmt.setInt(pos++, item.getSavedSequence());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // need to kill the Note class sooner rather than later\n    public static void saveSubject(Note note) throws ServiceException {\n        Mailbox mbox = note.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(note) +\n                        \" SET date = ?, size = ?, subject = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (note.getDate() / 1000));\n            stmt.setLong(pos++, note.getSize());\n            stmt.setString(pos++, checkSubjectLength(note.getSubject()));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, note.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing subject for mailbox \" + note.getMailboxId() + \", note \" + note.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveName(MailItem item, int folderId, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        String name = item.getName().equals(\"\") ? null : item.getName();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folderId, name, item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n        \tboolean isFolder = item instanceof Folder;\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, flags = ?, name = ?, subject = ?,\" +\n                        \"  folder_id = ?,\" + (isFolder ? \" parent_id = ?,\" : \"\") +\n                        \"  metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, name);\n            stmt.setInt(pos++, folderId);\n            if (isFolder)\n                stmt.setInt(pos++, folderId);\n            stmt.setString(pos++, metadata);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(name, e);\n            else\n                throw ServiceException.FAILURE(\"writing name for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveData(MailItem item, String subject, String sender, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        String name = item.getName().equals(\"\") ? null : item.getName();\n\n        if (item instanceof Conversation)\n            subject = ((Conversation) item).getNormalizedSubject();\n        else if (item instanceof Message)\n            subject = ((Message) item).getNormalizedSubject();\n\n        checkNamingConstraint(mbox, item.getFolderId(), name, item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET type = ?, imap_id = ?, parent_id = ?, date = ?, size = ?, flags = ?,\" +\n                        \"  blob_digest = ?, sender = ?, subject = ?, name = ?, metadata = ?,\" +\n                        \"  mod_metadata = ?, change_date = ?, mod_content = ?, volume_id = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setByte(pos++, item.getType());\n            if (item.getImapUid() >= 0)\n                stmt.setInt(pos++, item.getImapUid());\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            // messages in virtual conversations are stored with a null parent_id\n            if (item.getParentId() <= 0)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, item.getParentId());\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, item.getDigest());\n            stmt.setString(pos++, checkSenderLength(sender));\n            stmt.setString(pos++, checkSubjectLength(subject));\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            if (item.getLocator() != null)\n                stmt.setString(pos++, item.getLocator());\n            else\n                stmt.setNull(pos++, Types.TINYINT);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n\n            // Update the flagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(item.getInternalFlagBitmask());\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            else\n                throw ServiceException.FAILURE(\"rewriting row data for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveBlobInfo(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET size = ?, blob_digest = ?, volume_id = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setLong(pos++, item.getSize());\n            stmt.setString(pos++, item.getDigest());\n            if (item.getLocator() != null)\n                stmt.setString(pos++, item.getLocator());\n            else\n                stmt.setNull(pos++, Types.TINYINT);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating blob info for mailbox \" + mbox.getId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void openConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getConversationTableName(item) +\n                        \"(\" + mailbox_id + \"hash, conv_id)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(item) +\n                            \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, item.getId());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setString(pos++, hash);\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating open conversation association for hash \" + hash, nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing open conversation association for hash \" + hash, e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void closeConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(item) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ? AND conv_id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversation association for hash \" + hash, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes rows from <tt>open_conversation</tt> whose items are older than\n     * the given date.\n     * \n     * @param mbox the mailbox\n     * @param beforeDate the cutoff date in seconds\n     */\n    public static void closeOldConversations(Mailbox mbox, int beforeDate) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ZimbraLog.purge.debug(\"Closing conversations dated before %d.\", beforeDate);\n        try {\n            String mailboxJoin = (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = open_conversation.mailbox_id\");\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(mbox) +\n                \" WHERE \" + IN_THIS_MAILBOX_AND + \"conv_id IN (\" +\n                \"  SELECT id FROM \" + getMailItemTableName(mbox, \"mi\") +\n                \"  WHERE mi.id = open_conversation.conv_id\" +\n                   mailboxJoin +\n                \"  AND date < ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, beforeDate); \n            int numRows = stmt.executeUpdate();\n            if (numRows > 0) {\n                ZimbraLog.purge.info(\"Closed %d conversations dated before %d.\", numRows, beforeDate);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversations dated before \" + beforeDate, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void changeOpenTarget(String hash, MailItem oldTarget, int newTargetId) throws ServiceException {\n        Mailbox mbox = oldTarget.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(oldTarget) +\n                        \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ? AND conv_id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, newTargetId);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, oldTarget.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"switching open conversation association for item \" + oldTarget.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveDate(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET date = ?, mod_metadata = ?, change_date = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveImapUid(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET imap_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, item.getImapUid());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(MailItem item, Tag tag, boolean add) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != tag.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n        if (tag.getId() == Flag.ID_FLAG_UNREAD)\n            throw ServiceException.FAILURE(\"unread state must be updated with alterUnread()\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAG_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = (add ? \"NOT \" : \"\") + Db.bitmaskAND(column);\n\n            String relation;\n            if (item instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (item instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (item instanceof Folder)          relation = \"folder_id = ?\";\n            else if (item instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (item instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                      relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                    \" SET \" + primaryUpdate + updateChangeID +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND \" + relation);\n\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            if (altersModseq) {\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n            }\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, tag.getBitmask());\n            if (item instanceof Tag)\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            else if (item instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            else\n                stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(item.getInternalFlagBitmask());\n            else if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).addTagset(item.getTagBitmask());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(Tag tag, List<Integer> itemIDs, boolean add)\n    throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty())\n            return;\n        Mailbox mbox = tag.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAG_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = (add ? \"NOT \" : \"\") + Db.bitmaskAND(column);\n\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                            \" SET \" + primaryUpdate + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND id IN \" + DbUtil.suitableNumberOfVariables(count));\n\n                int pos = 1;\n                stmt.setLong(pos++, tag.getBitmask());\n                if (altersModseq) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setLong(pos++, tag.getBitmask());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, itemIDs.get(index));\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n            else if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for \" + itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void clearTag(Tag tag) throws ServiceException {\n        Mailbox mbox = tag.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                        \" SET tags = tags - ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + Db.bitmaskAND(\"tags\"));\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.executeUpdate();\n\n            if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).applyMask(tag.getTagBitmask(), false);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"clearing all references to tag \" + tag.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Sets the <code>unread</code> column for the specified <code>MailItem</code>.\n     * If the <code>MailItem</code> is a <code>Conversation</code>, <code>Tag</code>\n     * or <code>Folder</code>, sets the <code>unread</code> column for all related items.\n     */\n    public static void alterUnread(MailItem item, boolean unread)\n    throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation;\n            if (item instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (item instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (item instanceof Folder)          relation = \"folder_id = ?\";\n            else if (item instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (item instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                      relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ? AND \" + relation +\n                        \"  AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE));\n            int pos = 1;\n            stmt.setInt(pos++, unread ? 1 : 0);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, unread ? 0 : 1);\n            if (item instanceof Tag)\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            else if (item instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            else\n                stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterUnread(Mailbox mbox, List<Integer> itemIDs, boolean unread)\n    throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ?\" +\n                            \"  AND id IN \" + DbUtil.suitableNumberOfVariables(count) +\n                            \"  AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE));\n                int pos = 1;\n                stmt.setInt(pos++, unread ? 1 : 0);\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, unread ? 0 : 1);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, itemIDs.get(index));\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for \" +\n                itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all conversations affected by a folder deletion.  For all conversations\n     * that have messages in the given folder, updates their message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     * \n     * @param folder the folder that is being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Folder folder, Set<Integer> candidates) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) + \", \" +\n                            \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(folder) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                            \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.TYPE_CONVERSATION);\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.executeUpdate();\n                stmt.close();\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, folder.getId());\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    List<Integer> convIDs = update.getValue();\n                    for (int i = 0; i < convIDs.size(); i += Db.getINClauseBatchSize()) {\n                        int count = Math.min(Db.getINClauseBatchSize(), convIDs.size() - i);\n                        stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                                \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count) +\n                                \"  AND type = \" + MailItem.TYPE_CONVERSATION);\n                        pos = 1;\n                        stmt.setInt(pos++, update.getKey());\n                        stmt.setInt(pos++, mbox.getOperationChangeID());\n                        stmt.setInt(pos++, mbox.getOperationTimestamp());\n                        pos = setMailboxId(stmt, mbox, pos);\n                        for (int index = i; index < i + count; index++)\n                            stmt.setInt(pos++, convIDs.get(index));\n                        stmt.executeUpdate();\n                        stmt.close();\n                    }\n                }\n            }\n\n            return getPurgedConversations(mbox, candidates);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations crossing folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all affected conversations when a <code>List</code> of <code>MailItem</code>s\n     * is deleted.  Updates each conversation's message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     * \n     * @param mbox the mailbox\n     * @param ids of the items being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Mailbox mbox, List<Integer> ids, Set<Integer> candidates) throws ServiceException {\n        if (ids == null)\n            return null;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n                    int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                    stmt = conn.prepareStatement(\"UPDATE \" + table + \", \" +\n                                \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(mbox) +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count) + \"AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                                \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.TYPE_CONVERSATION);\n                    int pos = 1;\n                    pos = setMailboxId(stmt, mbox, pos);\n                    for (int index = i; index < i + count; index++)\n                        stmt.setInt(pos++, ids.get(index));\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(ids) + \"AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int id : ids)\n                    stmt.setInt(pos++, id);\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(update.getValue()) +\n                            \" AND type = \" + MailItem.TYPE_CONVERSATION);\n                    pos = 1;\n                    stmt.setInt(pos++, update.getKey());\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    for (int convId : update.getValue())\n                        stmt.setInt(pos++, convId);\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations touching \" +\n                ids.size() + \" items: \" + getIdListForLogging(ids), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return getPurgedConversations(mbox, candidates);\n    }\n\n    private static List<Integer> getPurgedConversations(Mailbox mbox, Set<Integer> candidates) throws ServiceException {\n        if (candidates == null || candidates.isEmpty())\n            return null;\n        List<Integer> purgedConvs = new ArrayList<Integer>();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // note: be somewhat careful making changes here, as <tt>i</tt> and <tt>it</tt> operate separately\n            Iterator<Integer> it = candidates.iterator();\n            for (int i = 0; i < candidates.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), candidates.size() - i);\n                stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count) + \"AND size <= 0\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n                rs = stmt.executeQuery();\n\n                while (rs.next())\n                    purgedConvs.add(rs.getInt(1));\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            return purgedConvs;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting list of purged conversations\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes the specified <code>MailItem</code> from the <code>mail_item</code>\n     * table.  If the object is a <code>Folder</code> or <code>Conversation</code>,\n     * deletes any corresponding messages.  Does not delete subfolders.\n     */\n    public static void delete(MailItem item) throws ServiceException {\n        deleteContents(item);\n        if (item instanceof VirtualConversation)\n            return;\n\n        List<Integer> ids = new ArrayList<Integer>();\n        ids.add(item.getId());\n        delete(item.getMailbox(), ids);\n    }\n\n    /**\n     * Deletes <code>MailItem</code>s with the specified ids from the <code>mail_item</code>\n     * table.  Assumes that there is no data referencing the specified id's.\n     */\n    public static void delete(Mailbox mbox, List<Integer> ids) throws ServiceException {\n        // trim out any non-persisted items\n        if (ids == null || ids.size() == 0)\n            return;\n        List<Integer> targets = new ArrayList<Integer>();\n        for (int id : ids) {\n            if (id > 0)\n                targets.add(id);\n        }\n        if (targets.size() == 0)\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        for (int i = 0; i < targets.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), targets.size() - i);\n                stmt = conn.prepareStatement(\"DELETE FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, targets.get(index));\n                stmt.executeUpdate();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"deleting \" + ids.size() + \" item(s): \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        }\n    }\n\n    public static void deleteContents(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        String target;\n        if (item instanceof VirtualConversation)  target = \"id = ?\";\n        else if (item instanceof Conversation)    target = \"parent_id = ?\";\n        else if (item instanceof SearchFolder)    return;\n        else if (item instanceof Folder)          target = \"folder_id = ?\";\n        else                                      return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getMailItemTableName(item) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + target + \" AND type NOT IN \" + FOLDER_TYPES);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting contents for \" + MailItem.getNameForType(item) + \" \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void writeTombstones(Mailbox mbox, TypedIdList tombstones) throws ServiceException {\n        if (tombstones == null || tombstones.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        for (Map.Entry<Byte, List<Integer>> entry : tombstones) {\n            byte type = entry.getKey();\n            if (type == MailItem.TYPE_CONVERSATION || type == MailItem.TYPE_VIRTUAL_CONVERSATION)\n                continue;\n            StringBuilder ids = new StringBuilder();\n            for (Integer id : entry.getValue()) {\n                ids.append(ids.length() == 0 ? \"\" : \",\").append(id);\n\n                // catch overflows of TEXT values; since all chars are ASCII, no need to convert to UTF-8 for length check beforehand\n                if (ids.length() > MAX_TEXT_LENGTH - 50) {\n                    writeTombstone(mbox, type, ids.toString());\n                    ids.setLength(0);\n                }\n            }\n\n            writeTombstone(mbox, type, ids.toString());\n        }\n    }\n\n    private static void writeTombstone(Mailbox mbox, byte type, String ids) throws ServiceException {\n        if (ids == null || ids.equals(\"\"))\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getTombstoneTableName(mbox) +\n                        \"(\" + mailbox_id + \"sequence, date, type, ids)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setByte(pos++, type);\n            stmt.setString(pos++, ids);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing tombstones for \" + MailItem.getNameForType(type) + \"(s): \" + ids, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList readTombstones(Mailbox mbox, long lastSync) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        TypedIdList tombstones = new TypedIdList();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT type, ids FROM \" + getTombstoneTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"sequence > ? AND ids IS NOT NULL\" +\n                        \" ORDER BY sequence\");\n            Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                byte type = rs.getByte(1);\n                String row = rs.getString(2);\n                if (row == null || row.equals(\"\"))\n                    continue;\n                for (String entry : row.split(\",\")) {\n                    try {\n                        tombstones.add(type, Integer.parseInt(entry));\n                    } catch (NumberFormatException nfe) {\n                        ZimbraLog.sync.warn(\"unparseable TOMBSTONE entry: \" + entry);\n                    }\n                }\n            }\n            return tombstones;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"reading tombstones since change: \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes tombstones dated earlier than the given timestamp.\n     * \n     * @param mbox the mailbox\n     * @param beforeDate timestamp in seconds\n     * @return the number of tombstones deleted\n     */\n    public static int purgeTombstones(Mailbox mbox, int beforeDate)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        \n        try {\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + getTombstoneTableName(mbox) +\n                \" WHERE \" + IN_THIS_MAILBOX_AND + \"date < ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, beforeDate);\n            int numRows = stmt.executeUpdate();\n            if (numRows > 0) {\n                ZimbraLog.mailbox.info(\"Purged %d tombstones dated before %d.\", numRows, beforeDate);\n            }\n            return numRows;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"purging tombstones with date before \" + beforeDate, null);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    private static final String FOLDER_TYPES         = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ')';\n    private static final String FOLDER_AND_TAG_TYPES = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ',' + MailItem.TYPE_TAG + ')';\n    private static final String MESSAGE_TYPES        = \"(\" + MailItem.TYPE_MESSAGE + ',' + MailItem.TYPE_CHAT + ')';\n    private static final String DOCUMENT_TYPES       = \"(\" + MailItem.TYPE_DOCUMENT + ',' + MailItem.TYPE_WIKI + ')';\n    private static final String CALENDAR_TYPES       = \"(\" + MailItem.TYPE_APPOINTMENT + ',' + MailItem.TYPE_TASK + ')';\n\n    static final String NON_SEARCHABLE_TYPES = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ',' + MailItem.TYPE_TAG + ',' + MailItem.TYPE_CONVERSATION + ')';\n\n    private static String typeConstraint(byte type) {\n        if (type == MailItem.TYPE_FOLDER)\n            return FOLDER_TYPES;\n        else if (type == MailItem.TYPE_MESSAGE)\n            return MESSAGE_TYPES;\n        else if (type == MailItem.TYPE_DOCUMENT)\n            return DOCUMENT_TYPES;\n        else\n            return \"(\" + type + ')';\n    }\n\n\n    public static Mailbox.MailboxData getFoldersAndTags(Mailbox mbox, Map<UnderlyingData, Long> folderData, Map<UnderlyingData, Long> tagData, boolean reload)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox, \"mi\");\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS + \" FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + FOLDER_AND_TAG_TYPES);\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (MailItem.isAcceptableType(MailItem.TYPE_FOLDER, data.type))\n                    folderData.put(data, -1L);\n                else if (MailItem.isAcceptableType(MailItem.TYPE_TAG, data.type))\n                    tagData.put(data, -1L);\n\n                rs.getInt(CI_UNREAD);\n                reload |= rs.wasNull();\n            }\n            rs.close();\n\n            for (UnderlyingData data : folderData.keySet()) {\n                if (data.parentId != data.folderId) {\n                    // we had a small folder data inconsistency issue, so resolve it here\n                    //   rather than returning it up to the caller\n                    stmt.close();\n                    stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = folder_id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                    int pos = 1;\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setInt(pos++, data.id);\n                    stmt.executeUpdate();\n\n                    data.parentId = data.folderId;\n                    ZimbraLog.mailbox.info(\"correcting PARENT_ID column for \" + MailItem.getNameForType(data.type) + \" \" + data.id);\n                }\n            }\n\n            if (!reload)\n                return null;\n\n            Map<Integer, UnderlyingData> lookup = new HashMap<Integer, UnderlyingData>(folderData.size() + tagData.size());\n\n            // going to recalculate counts, so discard any existing counts...\n            for (Map.Entry<UnderlyingData, Long> entry : folderData.entrySet()) {\n                UnderlyingData data = entry.getKey();\n                lookup.put(data.id, data);\n                data.size = data.unreadCount = 0;\n                entry.setValue(0L);\n            }\n\n            for (UnderlyingData data : tagData.keySet()) {\n                lookup.put(data.id, data);\n                data.size = data.unreadCount = 0;\n            }\n\n            rs.close();\n            stmt.close();\n\n            Mailbox.MailboxData mbd = new Mailbox.MailboxData();\n            stmt = conn.prepareStatement(\"SELECT folder_id, type, tags, COUNT(*), SUM(unread), SUM(size)\" +\n                        \" FROM \" + table + \" WHERE \" + IN_THIS_MAILBOX_AND + \"type NOT IN \" + NON_SEARCHABLE_TYPES +\n                        \" GROUP BY folder_id, type, tags\");\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                byte type  = rs.getByte(2);\n                int count  = rs.getInt(4);\n                int unread = rs.getInt(5);\n                long size  = rs.getLong(6);\n\n                if (type == MailItem.TYPE_CONTACT)\n                    mbd.contacts += count;\n                mbd.size += size;\n\n                UnderlyingData data = lookup.get(rs.getInt(1));\n                assert(data != null);\n                data.unreadCount += unread;\n                data.size += count;\n                Long folderSize = folderData.get(data);\n                folderData.put(data, folderSize == null ? size : folderSize + size);\n\n                long tags = rs.getLong(3);\n                for (int i = 0; tags != 0 && i < MailItem.MAX_TAG_COUNT - 1; i++) {\n                    if ((tags & (1L << i)) != 0) {\n                        data = lookup.get(i + MailItem.TAG_ID_OFFSET);\n                        if (data != null)\n                            data.unreadCount += unread;\n                        // could track cumulative count if desired...\n                        tags &= ~(1L << i);\n                    }\n                }\n            }\n\n            rs.close();\n            stmt.close();\n\n            stmt = conn.prepareStatement(\"SELECT mi.folder_id, SUM(rev.size)\" +\n                        \" FROM \" + table + \", \" + getRevisionTableName(mbox, \"rev\") +\n                        \" WHERE mi.id = rev.item_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND rev.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\") + \n                        \" GROUP BY folder_id\");\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = lookup.get(rs.getInt(1));\n                assert(data != null);\n                Long folderSize = folderData.get(data);\n                folderData.put(data, folderSize == null ? rs.getLong(2) : folderSize + rs.getLong(2));\n            }\n\n            return mbd;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching folder data for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByType(Mailbox mbox, byte type, SortBy sort) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(mbox, \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + typeConstraint(type) + DbSearch.sortQuery(sort));\n            if (type == MailItem.TYPE_MESSAGE)\n                Db.getInstance().enableStreaming(stmt);\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n            while (rs.next())\n                result.add(constructItem(rs));\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n\n            if (type == MailItem.TYPE_CONVERSATION)\n                completeConversations(mbox, result);\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items of type \" + type, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent) throws ServiceException {\n        return getByParent(parent, SortBy.DATE_DESCENDING);\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent, SortBy sort) throws ServiceException {\n        Mailbox mbox = parent.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(parent.getMailbox(), \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ? \" + DbSearch.sortQuery(sort));\n            if (parent.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, parent.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (Mailbox.isCachedType(data.type))\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching children of item \" + parent.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getUnreadMessages(MailItem relativeTo) throws ServiceException {\n        Mailbox mbox = relativeTo.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String relation;\n            if (relativeTo instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (relativeTo instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (relativeTo instanceof Folder)          relation = \"folder_id = ?\";\n            else if (relativeTo instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (relativeTo instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                            relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(relativeTo.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread > 0 AND \" + relation + \" AND type NOT IN \" + NON_SEARCHABLE_TYPES);\n            if (relativeTo.getUnreadCount() > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (relativeTo instanceof Tag)\n                stmt.setLong(pos++, ((Tag) relativeTo).getBitmask());\n            else if (relativeTo instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) relativeTo).getMessageId());\n            else\n                stmt.setInt(pos++, relativeTo.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (Mailbox.isCachedType(data.type))\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching unread messages for item \" + relativeTo.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByFolder(Folder folder, byte type, SortBy sort) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + typeConstraint(type) +\n                        DbSearch.sortQuery(sort));\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS && type == MailItem.TYPE_MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items in folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getById(Mailbox mbox, int id, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, id);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailItem.noSuchItem(id, type);\n            UnderlyingData data = constructItem(rs);\n            if (!MailItem.isAcceptableType(type, data.type))\n                throw MailItem.noSuchItem(id, type);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + id, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByImapId(Mailbox mbox, int imapId, int folderId) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND imap_id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, imapId);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            UnderlyingData data = constructItem(rs);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + imapId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getById(Mailbox mbox, Collection<Integer> ids, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n        if (ids.isEmpty())\n            return result;\n        List<UnderlyingData> conversations = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        Iterator<Integer> it = ids.iterator();\n        for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                            \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    UnderlyingData data = constructItem(rs);\n                    if (!MailItem.isAcceptableType(type, data.type))\n                        throw MailItem.noSuchItem(data.id, type);\n                    else if (Mailbox.isCachedType(data.type))\n                        throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                    if (data.type == MailItem.TYPE_CONVERSATION)\n                        conversations.add(data);\n                    result.add(data);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"fetching \" + ids.size() + \" items: \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n        }\n\n        if (!conversations.isEmpty())\n            completeConversations(mbox, conversations);\n        return result;\n    }\n\n    public static UnderlyingData getByName(Mailbox mbox, int folderId, String name, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + typeConstraint(type) +\n                        \" AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setString(pos++, name.toUpperCase());\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailItem.noSuchItem(-1, type);\n            UnderlyingData data = constructItem(rs);\n            if (!MailItem.isAcceptableType(type, data.type))\n                throw MailItem.noSuchItem(data.id, type);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item by name ('\" + name + \"' in folder \" + folderId + \")\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByHash(Mailbox mbox, String hash) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getConversationTableName(mbox, \"oc\") +\n                        \" WHERE oc.hash = ? AND mi.id = oc.conv_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND oc.mailbox_id = ? AND mi.mailbox_id = oc.mailbox_id\"));\n            int pos = 1;\n            stmt.setString(pos++, hash);\n            pos = setMailboxId(stmt, mbox, pos);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                return null;\n            UnderlyingData data = constructItem(rs);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching conversation for hash \" + hash, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static Pair<List<Integer>,TypedIdList> getModifiedItems(Mailbox mbox, byte type, long lastSync, Set<Integer> visible)\n    throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<Integer> modified = new ArrayList<Integer>();\n        TypedIdList missed = new TypedIdList();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = type == MailItem.TYPE_UNKNOWN ? \"type NOT IN \" + NON_SEARCHABLE_TYPES : \"type IN \" + typeConstraint(type);\n            stmt = conn.prepareStatement(\"SELECT id, type, folder_id\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"mod_metadata > ? AND \" + typeConstraint +\n                        \" ORDER BY mod_metadata, id\");\n            if (type == MailItem.TYPE_MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                if (visible == null || visible.contains(rs.getInt(3)))\n                    modified.add(rs.getInt(1));\n                else\n                    missed.add(rs.getByte(2), rs.getInt(1));\n            }\n\n            return new Pair<List<Integer>,TypedIdList>(modified, missed);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting items modified since \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void completeConversation(Mailbox mbox, UnderlyingData data) throws ServiceException {\n        completeConversations(mbox, Arrays.asList(data));\n    }\n\n    private static void completeConversations(Mailbox mbox, List<UnderlyingData> convData) throws ServiceException {\n        if (convData == null || convData.isEmpty())\n            return;\n        for (UnderlyingData data : convData) {\n            if (data.type != MailItem.TYPE_CONVERSATION)\n                throw ServiceException.FAILURE(\"attempting to complete a non-conversation\", null);\n        }\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Map<Integer, UnderlyingData> conversations = new HashMap<Integer, UnderlyingData>(Db.getINClauseBatchSize() * 3 / 2);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        for (int i = 0; i < convData.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), convData.size() - i);\n                stmt = conn.prepareStatement(\"SELECT parent_id, unread, flags, tags\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++) {\n                    UnderlyingData data = convData.get(index);\n                    stmt.setInt(pos++, data.id);\n                    conversations.put(data.id, data);\n                    // don't assume that the UnderlyingData structure was new...\n                    data.tags = data.flags = data.unreadCount = 0;\n                }\n                rs = stmt.executeQuery();\n\n                while (rs.next()) {\n                    UnderlyingData data = conversations.get(rs.getInt(1));\n                    assert(data != null);\n                    data.unreadCount += rs.getInt(2);\n                    data.flags       |= rs.getInt(3);\n                    data.tags        |= rs.getLong(4);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"completing conversation data\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n\n            conversations.clear();\n        }\n    }\n\n    private static final String LEAF_NODE_FIELDS = \"id, size, type, unread, folder_id, parent_id, blob_digest,\" +\n                                                   \" mod_content, mod_metadata, flags, index_id, volume_id\";\n\n    private static final int LEAF_CI_ID           = 1;\n    private static final int LEAF_CI_SIZE         = 2;\n    private static final int LEAF_CI_TYPE         = 3;\n    private static final int LEAF_CI_IS_UNREAD    = 4;\n    private static final int LEAF_CI_FOLDER_ID    = 5;\n    private static final int LEAF_CI_PARENT_ID    = 6;\n    private static final int LEAF_CI_BLOB_DIGEST  = 7;\n    private static final int LEAF_CI_MOD_CONTENT  = 8;\n    private static final int LEAF_CI_MOD_METADATA = 9;\n    private static final int LEAF_CI_FLAGS        = 10;\n    private static final int LEAF_CI_INDEX_ID     = 11;\n    private static final int LEAF_CI_VOLUME_ID    = 12;\n\n    public static PendingDelete getLeafNodes(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n        int folderId = folder.getId();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type NOT IN \" + FOLDER_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            rs = stmt.executeQuery();\n\n            info.rootId = folderId;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            \n            // make sure that the folder is in the list of deleted item ids\n            info.itemIds.add(folder.getType(), folderId);\n\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items within item \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static PendingDelete getLeafNodes(Mailbox mbox, List<Folder> folders, int before, boolean globalMessages,\n                                             Boolean unread, boolean useChangeDate)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String constraint;\n            String dateColumn = (useChangeDate ? \"change_date\" : \"date\");\n            if (globalMessages)\n                constraint = dateColumn + \" < ? AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE);\n            else\n                constraint = dateColumn + \" < ? AND type NOT IN \" + NON_SEARCHABLE_TYPES +\n                             \" AND folder_id IN\" + DbUtil.suitableNumberOfVariables(folders);\n            if (unread != null)\n                constraint += \" AND unread = ?\";\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + constraint);\n            if (globalMessages || getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, before);\n            if (!globalMessages) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            if (unread != null)\n                stmt.setBoolean(pos++, unread);\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    private static int getTotalFolderSize(Collection<Folder> folders) {\n        int totalSize = 0;\n        if (folders != null) {\n            for (Folder folder : folders) {\n                totalSize += folder.getSize();\n            }\n        }\n        return totalSize;\n    }\n\n    public static PendingDelete getImapDeleted(Mailbox mbox, Set<Folder> folders) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n        if (folders != null && folders.isEmpty())\n            return info;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // figure out the set of FLAGS bitmasks containing the \\Deleted flag\n            Set<Long> flagsets = getFlagsetCache(conn, mbox).getMatchingTagsets(Flag.BITMASK_DELETED, Flag.BITMASK_DELETED);\n            if (flagsets != null && flagsets.isEmpty())\n                return info;\n\n            String flagconstraint = flagsets == null ? \"\" : \" AND flags IN\" + DbUtil.suitableNumberOfVariables(flagsets);\n            String folderconstraint = folders == null ? \"\" : \" AND folder_id IN\" + DbUtil.suitableNumberOfVariables(folders);\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + IMAP_TYPES + flagconstraint + folderconstraint);\n            if (getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (flagsets != null) {\n                for (long flags : flagsets)\n                    stmt.setInt(pos++, (int) flags);\n            }\n            if (folders != null) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of \\\\Deleted items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class LocationCount {\n        public int count;\n        public long size;\n        public LocationCount(int c, long sz)              { count = c;  size = sz; }\n        public LocationCount(LocationCount lc)            { count = lc.count;  size = lc.size; }\n        public LocationCount increment(int c, long sz)    { count += c;  size += sz;  return this; }\n        public LocationCount increment(LocationCount lc)  { count += lc.count;  size += lc.size;  return this; }\n    }\n\n    /**\n     * Accumulates <tt>PendingDelete</tt> info for the given <tt>ResultSet</tt>.\n     * @return a <tt>List</tt> of all versioned items, to be used in a subsequent call to\n     * {@link DbMailItem#accumulateLeafRevisions}, or an empty list.\n     */\n    private static List<Integer> accumulateLeafNodes(PendingDelete info, Mailbox mbox, ResultSet rs) throws SQLException, ServiceException {\n        StoreManager sm = StoreManager.getInstance();\n        List<Integer> versioned = new ArrayList<Integer>();\n\n        while (rs.next()) {\n            // first check to make sure we don't have a modify conflict\n            int revision = rs.getInt(LEAF_CI_MOD_CONTENT);\n            int modMetadata = rs.getInt(LEAF_CI_MOD_METADATA);\n            if (!mbox.checkItemChangeID(modMetadata, revision)) {\n                info.incomplete = true;\n                continue;\n            }\n\n            int id = rs.getInt(LEAF_CI_ID);\n            long size = rs.getLong(LEAF_CI_SIZE);\n            byte type = rs.getByte(LEAF_CI_TYPE);\n\n            Integer item = new Integer(id);\n            info.itemIds.add(type, item);\n            info.size += size;\n            \n            if (rs.getBoolean(LEAF_CI_IS_UNREAD))\n                info.unreadIds.add(item);\n\n            boolean isMessage = false;\n            switch (type) {\n                case MailItem.TYPE_CONTACT:  info.contacts++;  break;\n                case MailItem.TYPE_CHAT:\n                case MailItem.TYPE_MESSAGE:  isMessage = true;    break;\n            }\n\n            // record deleted virtual conversations and modified-or-deleted real conversations\n            if (isMessage) {\n                int parentId = rs.getInt(LEAF_CI_PARENT_ID);\n                if (rs.wasNull() || parentId <= 0)\n                    info.itemIds.add(MailItem.TYPE_VIRTUAL_CONVERSATION, -id);\n                else\n                    info.modifiedIds.add(parentId);\n            }\n\n            Integer folderId = rs.getInt(LEAF_CI_FOLDER_ID);\n            LocationCount count = info.messages.get(folderId);\n            if (count == null)\n                info.messages.put(folderId, new LocationCount(1, size));\n            else\n                count.increment(1, size);\n\n            String blobDigest = rs.getString(LEAF_CI_BLOB_DIGEST);\n            if (blobDigest != null) {\n                info.blobDigests.add(blobDigest);\n                String locator = rs.getString(LEAF_CI_VOLUME_ID);\n                try {\n                    MailboxBlob mblob = sm.getMailboxBlob(mbox, id, revision, locator);\n                    if (mblob == null)\n                        sLog.warn(\"missing blob for id: \" + id + \", change: \" + revision);\n                    else\n                        info.blobs.add(mblob);\n                } catch (Exception e1) { }\n            }\n\n            int flags = rs.getInt(LEAF_CI_FLAGS);\n            if ((flags & Flag.BITMASK_VERSIONED) != 0) {\n                versioned.add(id);\n            }\n\n            String indexId = rs.getString(LEAF_CI_INDEX_ID);\n            boolean indexed = !rs.wasNull();\n            if (indexed) {\n                if (info.sharedIndex == null)\n                    info.sharedIndex = new HashSet<String>();\n                boolean shared = (flags & Flag.BITMASK_COPIED) != 0;\n                if (!shared)  info.indexIds.add(indexId);\n                else          info.sharedIndex.add(indexId);\n            }\n        }\n        return versioned;\n    }\n\n    private static void accumulateLeafRevisions(PendingDelete info, Mailbox mbox, List<Integer> versioned) throws ServiceException {\n        if (versioned == null || versioned.size() == 0) {\n            return;\n        }\n        Connection conn = mbox.getOperationConnection();\n        StoreManager sm = StoreManager.getInstance();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.id, mi.folder_id, rev.size, rev.mod_content, rev.volume_id, rev.blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getRevisionTableName(mbox, \"rev\") +\n                    \" WHERE mi.id = rev.item_id AND mi.id IN \" + DbUtil.suitableNumberOfVariables(versioned) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\"));\n            int pos = 1;\n            for (int vid : versioned)\n                stmt.setInt(pos++, vid);\n            pos = setMailboxId(stmt, mbox, pos);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                Integer folderId = rs.getInt(2);\n                LocationCount count = info.messages.get(folderId);\n                if (count == null)\n                    info.messages.put(folderId, new LocationCount(0, rs.getLong(3)));\n                else\n                    count.increment(0, rs.getLong(3));\n\n                String blobDigest = rs.getString(6);\n                if (blobDigest != null) {\n                    info.blobDigests.add(blobDigest);\n                    try {\n                        MailboxBlob mblob = sm.getMailboxBlob(mbox, rs.getInt(1), rs.getInt(4), rs.getString(5));\n                        if (mblob == null)\n                            sLog.error(\"missing blob for id: \" + rs.getInt(1) + \", change: \" + rs.getInt(4));\n                        else\n                            info.blobs.add(mblob);\n                    } catch (Exception e1) { }\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting version deletion info for items: \" + versioned, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Returns the blob digest for the item with the given id, or <tt>null</tt>\n     * if either the id doesn't exist in the table or there is no associated blob.\n     */\n    public static String getBlobDigest(Mailbox mbox, int itemId) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, itemId);\n            rs = stmt.executeQuery();\n\n            return rs.next() ? rs.getString(1) : null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"unable to get blob digest for id \" + itemId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void resolveSharedIndex(Mailbox mbox, PendingDelete info) throws ServiceException {\n        if (info.sharedIndex == null || info.sharedIndex.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<String> indexIDs = new ArrayList<String>(info.sharedIndex);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            for (int i = 0; i < indexIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), indexIDs.size() - i);\n                stmt = conn.prepareStatement(\"SELECT index_id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"index_id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setString(pos++, indexIDs.get(index));\n                rs = stmt.executeQuery();\n                while (rs.next())\n                    info.sharedIndex.remove(rs.getInt(1));\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            info.indexIds.addAll(info.sharedIndex);\n            info.sharedIndex.clear();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"resolving shared index entries: \" + info.rootId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String IMAP_FIELDS = \"mi.id, mi.type, mi.imap_id, mi.unread, mi.flags, mi.tags\";\n    private static final String IMAP_TYPES = \"(\" + MailItem.TYPE_MESSAGE + \",\" + MailItem.TYPE_CHAT + ',' + MailItem.TYPE_CONTACT + \")\";\n\n    public static List<ImapMessage> loadImapFolder(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<ImapMessage> result = new ArrayList<ImapMessage>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + IMAP_FIELDS +\n                        \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                int flags = rs.getBoolean(4) ? Flag.BITMASK_UNREAD | rs.getInt(5) : rs.getInt(5);\n                result.add(new ImapMessage(rs.getInt(1), rs.getByte(2), rs.getInt(3), flags, rs.getLong(6)));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading IMAP folder data: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static int countImapRecent(Folder folder, int uidCutoff) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(folder.getMailbox()) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES +\n                        \" AND (imap_id IS NULL OR imap_id = 0 OR imap_id > ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            stmt.setInt(pos++, uidCutoff);\n            rs = stmt.executeQuery();\n\n            return (rs.next() ? rs.getInt(1) : 0);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"counting IMAP \\\\Recent messages: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String POP3_FIELDS = \"mi.id, mi.size, mi.blob_digest\";\n    private static final String POP3_TYPES = \"(\" + MailItem.TYPE_MESSAGE + \")\";\n\n    public static List<Pop3Message> loadPop3Folder(Folder folder, Date popSince) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long popDate = popSince == null ? -1 : Math.max(popSince.getTime(), -1);\n        List<Pop3Message> result = new ArrayList<Pop3Message>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String dateConstraint = popDate < 0 ? \"\" : \" AND date > ?\";\n            stmt = conn.prepareStatement(\"SELECT \" + POP3_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + POP3_TYPES +\n                        \" AND NOT \" + Db.bitmaskAND(\"flags\", Flag.BITMASK_DELETED) + dateConstraint);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            if (popDate >= 0)\n                stmt.setInt(pos++, (int) (popDate / 1000L));\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(new Pop3Message(rs.getInt(1), rs.getLong(2), rs.getString(3)));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading POP3 folder data: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getRevisionInfo(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<UnderlyingData> dlist = new ArrayList<UnderlyingData>();\n        if (!item.isTagged(Flag.ID_FLAG_VERSIONED))\n            return dlist;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + REVISION_FIELDS + \" FROM \" + getRevisionTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ?\" +\n                        \" ORDER BY version\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                dlist.add(constructRevision(rs, item));\n            return dlist;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting old revisions for item: \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<Integer> listByFolder(Folder folder, byte type, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean allTypes = type == MailItem.TYPE_UNKNOWN;\n        List<Integer> result = new ArrayList<Integer>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            if (type == MailItem.TYPE_MESSAGE && folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (!allTypes)\n                stmt.setByte(pos++, type);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList listByFolder(Folder folder, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        TypedIdList result = new TypedIdList();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT id, type FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getByte(2), rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    // these columns are specified by DB_FIELDS, below\n    public static final int CI_ID          = 1;\n    public static final int CI_TYPE        = 2;\n    public static final int CI_PARENT_ID   = 3;\n    public static final int CI_FOLDER_ID   = 4;\n    public static final int CI_INDEX_ID    = 5;\n    public static final int CI_IMAP_ID     = 6;\n    public static final int CI_DATE        = 7;\n    public static final int CI_SIZE        = 8;\n    public static final int CI_VOLUME_ID   = 9;\n    public static final int CI_BLOB_DIGEST = 10;\n    public static final int CI_UNREAD      = 11;\n    public static final int CI_FLAGS       = 12;\n    public static final int CI_TAGS        = 13;\n//  public static final int CI_SENDER      = 14;\n    public static final int CI_SUBJECT     = 14;\n    public static final int CI_NAME        = 15;\n    public static final int CI_METADATA    = 16;\n    public static final int CI_MODIFIED    = 17;\n    public static final int CI_MODIFY_DATE = 18;\n    public static final int CI_SAVED       = 19;\n\n    static final String DB_FIELDS = \"mi.id, mi.type, mi.parent_id, mi.folder_id, mi.index_id, \" +\n                                    \"mi.imap_id, mi.date, mi.size, mi.volume_id, mi.blob_digest, \" +\n                                    \"mi.unread, mi.flags, mi.tags, mi.subject, mi.name, \" +\n                                    \"mi.metadata, mi.mod_metadata, mi.change_date, mi.mod_content\";\n    \n\n    private static UnderlyingData constructItem(ResultSet rs) throws SQLException {\n        return constructItem(rs, 0);\n    }\n\n    static UnderlyingData constructItem(ResultSet rs, int offset) throws SQLException {\n        UnderlyingData data = new UnderlyingData();\n        data.id          = rs.getInt(CI_ID + offset);\n        data.type        = rs.getByte(CI_TYPE + offset);\n        data.parentId    = rs.getInt(CI_PARENT_ID + offset);\n        data.folderId    = rs.getInt(CI_FOLDER_ID + offset);\n        data.indexId     = rs.getString(CI_INDEX_ID + offset);\n        if (rs.wasNull())\n            data.indexId = null;\n        data.imapId      = rs.getInt(CI_IMAP_ID + offset);\n        if (rs.wasNull())\n            data.imapId = -1;\n        data.date        = rs.getInt(CI_DATE + offset);\n        data.size        = rs.getLong(CI_SIZE + offset);\n        data.locator    = rs.getString(CI_VOLUME_ID + offset);\n        data.setBlobDigest(rs.getString(CI_BLOB_DIGEST + offset));\n        data.unreadCount = rs.getInt(CI_UNREAD + offset);\n        data.flags       = rs.getInt(CI_FLAGS + offset);\n        data.tags        = rs.getLong(CI_TAGS + offset);\n        data.subject     = rs.getString(CI_SUBJECT + offset);\n        data.name        = rs.getString(CI_NAME + offset);\n        data.metadata    = rs.getString(CI_METADATA + offset);\n        data.modMetadata = rs.getInt(CI_MODIFIED + offset);\n        data.modContent  = rs.getInt(CI_SAVED + offset);\n        data.dateChanged = rs.getInt(CI_MODIFY_DATE + offset);\n        // make sure to handle NULL column values\n        if (data.parentId == 0)     data.parentId = -1;\n        if (data.dateChanged == 0)  data.dateChanged = -1;\n        return data;\n    }\n\n    private static final String REVISION_FIELDS = \"date, size, volume_id, blob_digest, name, \" +\n                                                  \"metadata, mod_metadata, change_date, mod_content\";\n\n    private static UnderlyingData constructRevision(ResultSet rs, MailItem item) throws SQLException {\n        UnderlyingData data = new UnderlyingData();\n        data.id          = item.getId();\n        data.type        = item.getType();\n        data.parentId    = item.getParentId();\n        data.folderId    = item.getFolderId();\n        data.indexId     = null;\n        data.imapId      = -1;\n        data.date        = rs.getInt(1);\n        data.size        = rs.getLong(2);\n        data.locator    = rs.getString(3);\n        data.setBlobDigest(rs.getString(4));\n        data.unreadCount = item.getUnreadCount();\n        data.flags       = item.getInternalFlagBitmask() | Flag.BITMASK_UNCACHED;\n        data.tags        = item.getTagBitmask();\n        data.subject     = item.getSubject();\n        data.name        = rs.getString(5);\n        data.metadata    = rs.getString(6);\n        data.modMetadata = rs.getInt(7);\n        data.dateChanged = rs.getInt(8);\n        data.modContent  = rs.getInt(9);\n        // make sure to handle NULL column values\n        if (data.parentId <= 0)     data.parentId = -1;\n        if (data.dateChanged == 0)  data.dateChanged = -1;\n        return data;\n    }\n\n    //////////////////////////////////////\n    // CALENDAR STUFF BELOW HERE!\n    //////////////////////////////////////\n\n    public static UnderlyingData getCalendarItem(Mailbox mbox, String uid) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE ci.uid = ? AND mi.id = ci.item_id AND mi.type IN \" + CALENDAR_TYPES +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\"));\n\n            int pos = 1;\n            stmt.setString(pos++, uid);\n            pos = setMailboxId(stmt, mbox, pos);\n            rs = stmt.executeQuery();\n\n            if (rs.next())\n                return constructItem(rs);\n            return null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Return all of the Invite records within the range start&lt;=Invites&lt;end.  IE \"Give me all the \n     * invites between 7:00 and 9:00\" will return you everything from 7:00 to 8:59:59.99\n     * @param start\n     * @param end\n     * @param folderId \n     * @return list of invites\n     */\n    public static List<UnderlyingData> getCalendarItems(Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds) \n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, DB_FIELDS, mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getCalendarItems(Mailbox mbox, List<String> uids) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n        try {\n            for (int i = 0; i < uids.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), uids.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET index_id = id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE mi.id = ci.item_id AND mi.type IN \" + CALENDAR_TYPES +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\") +\n                \t\t\" AND ci.uid IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                \tstmt.setString(pos++, uids.get(index));\n                rs = stmt.executeQuery();\n                while (rs.next())\n                    result.add(constructItem(rs));\n                stmt.close();\n                stmt = null;\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static TypedIdList listCalendarItems(Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds) \n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, \"mi.id, mi.type\", mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            TypedIdList result = new TypedIdList();\n            while (rs.next())\n                result.add(rs.getByte(2), rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"listing calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static PreparedStatement calendarItemStatement(Connection conn, String fields,\n            Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds)\n    throws SQLException {\n        boolean folderSpecified = folderId != Mailbox.ID_AUTO_INCREMENT;\n\n        String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n        String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n        String typeList = (type == MailItem.TYPE_UNKNOWN ? CALENDAR_TYPES : typeConstraint(type));\n\n        String excludeFolderPart = \"\";\n        if (excludeFolderIds != null && excludeFolderIds.length > 0) \n            excludeFolderPart = \" AND folder_id NOT IN\" + DbUtil.suitableNumberOfVariables(excludeFolderIds);\n\n        PreparedStatement stmt = conn.prepareStatement(\"SELECT \" + fields +\n                    \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE mi.id = ci.item_id\" + endConstraint + startConstraint + \" AND mi.type IN \" + typeList +\n                    (DebugConfig.disableMailboxGroups? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\") +\n                    (folderSpecified ? \" AND folder_id = ?\" : \"\") + excludeFolderPart);\n\n        int pos = 1;\n        if (end > 0)\n            stmt.setTimestamp(pos++, new Timestamp(end));\n        if (start > 0)\n            stmt.setTimestamp(pos++, new Timestamp(start));\n        pos = setMailboxId(stmt, mbox, pos);\n        if (folderSpecified)\n            stmt.setInt(pos++, folderId);\n        if (excludeFolderIds != null) {\n            for (int id : excludeFolderIds)\n                stmt.setInt(pos++, id);\n        }\n\n        return stmt;\n    }\n\n    public static List<Integer> getItemListByDates(Mailbox mbox, byte type, long start, long end, int folderId, boolean descending) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean allTypes = type == MailItem.TYPE_UNKNOWN;\n        List<Integer> result = new ArrayList<Integer>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" AND date > ? AND date < ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (!allTypes)\n                stmt.setByte(pos++, type);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, (int)(start / 1000));\n            stmt.setInt(pos++, (int)(end / 1000));\n\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"finding items between dates\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void addToCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing invite to calendar item table: UID=\" + calItem.getUid(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static long MAX_DATE = new GregorianCalendar(9999, 1, 1).getTimeInMillis();\n\n    public static void updateInCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getCalendarItemTableName(mbox) +\n                            \" SET item_id = ?, start_time = ?, end_time = ? WHERE \" + IN_THIS_MAILBOX_AND + \"uid = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, calItem.getId());\n                    stmt.setTimestamp(pos++, startTs);\n                    stmt.setTimestamp(pos++, endTs);\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setString(pos++, calItem.getUid());\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating data in calendar item table \" + calItem.getUid(), nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing invite to calendar item table \" + calItem.getUid(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<CalendarItem.CalendarMetadata> getCalendarItemMetadata(Folder folder, long start, long end) throws ServiceException {\n    \tMailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<CalendarItem.CalendarMetadata> result = new ArrayList<CalendarItem.CalendarMetadata>();\n\n    \tConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n            String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n            String folderConstraint = \" AND mi.folder_id = ?\";\n            stmt = conn.prepareStatement(\"SELECT mi.mailbox_id, mi.id, ci.uid, mi.mod_metadata, mi.mod_content, ci.start_time, ci.end_time\" + \n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getCalendarItemTableName(mbox, \"ci\") +\n                        \" WHERE mi.mailbox_id = ci.mailbox_id AND mi.id = ci.item_id\" + \n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? \") +\n                        startConstraint + endConstraint + folderConstraint);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (start > 0)\n                stmt.setTimestamp(pos++, new Timestamp(start));\n            if (end > 0)\n                stmt.setTimestamp(pos++, new Timestamp(end));\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n            \tresult.add(new CalendarItem.CalendarMetadata(\n            \t\t\trs.getInt(1),\n            \t\t\trs.getInt(2),\n            \t\t\trs.getString(3),\n            \t\t\trs.getInt(4),\n            \t\t\trs.getInt(5),\n            \t\t\trs.getTimestamp(6).getTime(),\n            \t\t\trs.getTimestamp(7).getTime()));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching CalendarItem Metadata for mbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n        return result;\n    }\n\n\n    public static void consistencyCheck(MailItem item, UnderlyingData data, String metadata) throws ServiceException {\n        if (item.getId() <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.sender, \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw ServiceException.FAILURE(\"consistency check failed: \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" not found in DB\", null);\n\n            UnderlyingData dbdata = constructItem(rs, 1);\n            String dbsender = rs.getString(1);\n\n            String dataBlobDigest = data.getBlobDigest(), dbdataBlobDigest = dbdata.getBlobDigest();\n            String dataSender = item.getSortSender(), dbdataSender = dbsender == null ? \"\" : dbsender;\n            String failures = \"\";\n\n            if (data.id != dbdata.id)                    failures += \" ID\";\n            if (data.type != dbdata.type)                failures += \" TYPE\";\n            if (data.folderId != dbdata.folderId)        failures += \" FOLDER_ID\";\n            if (data.indexId != dbdata.indexId)          failures += \" INDEX_ID\";\n            if (data.imapId != dbdata.imapId)            failures += \" IMAP_ID\";\n            if (data.locator != dbdata.locator)        failures += \" VOLUME_ID\";\n            if (data.date != dbdata.date)                failures += \" DATE\";\n            if (data.size != dbdata.size)                failures += \" SIZE\";\n            if (dbdata.type != MailItem.TYPE_CONVERSATION) {\n                if (data.unreadCount != dbdata.unreadCount)  failures += \" UNREAD\";\n                if (data.flags != dbdata.flags)              failures += \" FLAGS\";\n                if (data.tags != dbdata.tags)                failures += \" TAGS\";\n            }\n            if (data.modMetadata != dbdata.modMetadata)  failures += \" MOD_METADATA\";\n            if (data.dateChanged != dbdata.dateChanged)  failures += \" CHANGE_DATE\";\n            if (data.modContent != dbdata.modContent)    failures += \" MOD_CONTENT\";\n            if (Math.max(data.parentId, -1) != dbdata.parentId)  failures += \" PARENT_ID\";\n            if (dataBlobDigest != dbdataBlobDigest && (dataBlobDigest == null || !dataBlobDigest.equals(dbdataBlobDigest)))  failures += \" BLOB_DIGEST\";\n            if (dataSender != dbdataSender && (dataSender == null || !dataSender.equalsIgnoreCase(dbdataSender)))  failures += \" SENDER\";\n            if (data.subject != dbdata.subject && (data.subject == null || !data.subject.equals(dbdata.subject)))  failures += \" SUBJECT\";\n            if (data.name != dbdata.name && (data.name == null || !data.name.equals(dbdata.name)))                 failures += \" NAME\";\n            if (metadata != dbdata.metadata && (metadata == null || !metadata.equals(dbdata.metadata)))            failures += \" METADATA\";\n\n            if (item instanceof Folder && dbdata.folderId != dbdata.parentId)  failures += \" FOLDER!=PARENT\";\n\n            if (!failures.equals(\"\"))\n                throw ServiceException.FAILURE(\"consistency check failed: \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" differs from DB at\" + failures, null);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL VARCHAR(128) column (128 characters) by truncating the string\n     *  if necessary.\n     * \n     * @param sender  The string to check (can be null).\n     * @return The passed-in String, truncated to 128 chars. */\n    public static String checkSenderLength(String sender) {\n        if (sender == null || sender.length() <= MAX_SENDER_LENGTH)\n            return sender;\n        return sender.substring(0, MAX_SENDER_LENGTH);\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL VARCHAR(1024) column (1024 characters).\n     * \n     * @param subject  The string to check (can be null).\n     * @return The passed-in String.\n     * @throws ServiceException <code>service.FAILURE</code> if the\n     *         parameter would be silently truncated when inserted. */\n    public static String checkSubjectLength(String subject) throws ServiceException {\n        if (subject == null || subject.length() <= MAX_SUBJECT_LENGTH)\n            return subject;\n        throw ServiceException.FAILURE(\"subject too long\", null);\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL MEDIUMTEXT column (16,777,216 bytes) after conversion to UTF-8.\n     * \n     * @param metadata  The string to check (can be null).\n     * @return The passed-in String.\n     * @throws ServiceException <code>service.FAILURE</code> if the\n     *         parameter would be silently truncated when inserted. */\n    public static String checkMetadataLength(String metadata) throws ServiceException {\n        if (metadata == null)\n            return null;\n        int len = metadata.length();\n        if (len > MAX_MEDIUMTEXT_LENGTH / 4) {  // every char uses 4 bytes in worst case\n            if (StringUtil.isAsciiString(metadata)) {\n                if (len > MAX_MEDIUMTEXT_LENGTH)\n                    throw ServiceException.FAILURE(\"metadata too long\", null);\n            } else {\n                try {\n                    if (metadata.getBytes(\"utf-8\").length > MAX_MEDIUMTEXT_LENGTH)\n                        throw ServiceException.FAILURE(\"metadata too long\", null);\n                } catch (UnsupportedEncodingException uee) { }\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the name of the table that stores {@link MailItem} data.  The table name is qualified\n     * by the name of the database (e.g. <tt>mailbox1.mail_item</tt>).\n     */\n    public static String getMailItemTableName(long mailboxId, long groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(Mailbox mbox, String alias) {\n        return getMailItemTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on old revisions of {@link MailItem}s.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.mail_item</tt>).\n     */\n    public static String getRevisionTableName(long mailboxId, long groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_REVISION);\n    }\n    public static String getRevisionTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_REVISION);\n    }\n    public static String getRevisionTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_REVISION);\n    }\n    public static String getRevisionTableName(Mailbox mbox, String alias) {\n        return getRevisionTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores {@link CalendarItem} data.  The table name is qualified\n     * by the name of the database (e.g. <tt>mailbox1.appointment</tt>).\n     */\n    public static String getCalendarItemTableName(long mailboxId, long groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_APPOINTMENT);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_APPOINTMENT);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox, String alias) {\n        return getCalendarItemTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that maps subject hashes to {@link Conversation} ids.  The table \n     * name is qualified by the name of the database (e.g. <tt>mailbox1.open_conversation</tt>).\n     */\n    public static String getConversationTableName(long mailboxId, long groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox, String alias) {\n        return getConversationTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on deleted items for the purpose of sync.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.tombstone</tt>).\n     */\n    public static String getTombstoneTableName(long mailboxId, long groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_TOMBSTONE);\n    }\n    public static String getTombstoneTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_TOMBSTONE);\n    }\n\n\n    /** If the database doesn't support row-level locking, try to synchronize\n     *  database accesses on the Mailbox object to avoid having read/write\n     *  conflicts with Mailbox write transactions.  In the case where the DB\n     *  <u>does</u> support row-level locking, synchronizing on a local\n     *  <code>Object</code> shouldn't add problematic overhead. */\n    public static Object getSynchronizer(Mailbox mbox) {\n        return Db.supports(Db.Capability.ROW_LEVEL_LOCKING) ? new Object() : mbox;\n    }\n\n\n    private static boolean areTagsetsLoaded(Mailbox mbox) {\n        synchronized (sTagsetCache) {\n            return sTagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getTagsetCache(Connection conn, Mailbox mbox) throws ServiceException {\n        long mailboxId = mbox.getId();\n        Long id = new Long(mailboxId);\n        TagsetCache tagsets = null;\n\n        synchronized (sTagsetCache) {\n            tagsets = sTagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the tagset cache for a single mailbox outside the\n        // synchronized block.\n        if (tagsets == null) {\n            ZimbraLog.cache.info(\"Loading tagset cache\");\n            tagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" tags\");\n            tagsets.addTagsets(DbMailbox.getDistinctTagsets(conn, mbox));\n\n            synchronized (sTagsetCache) {\n                sTagsetCache.put(id, tagsets);\n            }\n        }\n\n        return tagsets;\n    }\n\n    private static boolean areFlagsetsLoaded(Mailbox mbox) {\n        synchronized(sFlagsetCache) {\n            return sFlagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getFlagsetCache(Connection conn, Mailbox mbox) throws ServiceException {\n        long mailboxId = mbox.getId();\n        Long id = new Long(mailboxId);\n        TagsetCache flagsets = null;\n\n        synchronized (sFlagsetCache) {\n            flagsets = sFlagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the flagset cache for a single mailbox outside the\n        // synchronized block.\n        if (flagsets == null) {\n            ZimbraLog.cache.info(\"Loading flagset cache\");\n            flagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" flags\");\n            flagsets.addTagsets(DbMailbox.getDistinctFlagsets(conn, mbox));\n\n            synchronized (sFlagsetCache) {\n                sFlagsetCache.put(id, flagsets);\n            }\n        }\n\n        return flagsets;\n    }\n    \n    /**\n     * Returns a comma-separated list of ids for logging.  If the <tt>String</tt> is\n     * more than 200 characters long, cuts off the list and appends &quot...&quot.\n     */\n    private static String getIdListForLogging(Collection<Integer> ids) {\n        if (ids == null)\n            return null;\n        StringBuilder idList = new StringBuilder();\n        boolean firstTime = true;\n        for (Integer id : ids) {\n            if (firstTime)\n                firstTime = false;\n            else\n                idList.append(',');\n            idList.append(id);\n            if (idList.length() > 200) {\n                idList.append(\"...\");\n                break;\n            }\n        }\n        return idList.toString();\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "613db7155197e7c87dd61deb3ba7970e9784717c",
    "commit_msg": "(split)bug: 41970 convert all x IN (y) clauses to x = y for sqlite perf\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=41970\n\nCopied from Perforce\n Change: 215777",
    "original_file": "DbMailItem.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 14,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.service.admin;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.regex.Pattern;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.soap.AdminConstants;\nimport com.zimbra.common.soap.Element;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.account.Server;\nimport com.zimbra.cs.account.Provisioning.ServerBy;\nimport com.zimbra.cs.account.accesscontrol.AdminRight;\nimport com.zimbra.soap.ZimbraSoapContext;\n\n/**\n * <GetLoggerStatsRequest>\n *   <!-- when hostname and stats are specified, fetch stats -->\n *   <hostname hn=\"hostname\"/> <!-- optional, will list hosts otherwise -->\n *   <stats name=\"stat_group\" [limit=\"1\"]><!-- optional, will list stat groups if host specified and stats unspecified,\n *                                 will fetch given group for all hosts if hostname not specified\n *                                 if limit=X is specified, then the backend will attempt to limit the results to under\n *                                 500 records -->\n *     <values>\n *       <stat name=\"col1\"/> <!-- optional, request specific counters only -->\n *       <stat name=\"col2\"/>\n *       <stat name=\"col...\"/>\n *     </values>\n *   </stats>\n *   <stats name=\"stat_group\">1</stats><!-- optional, used in conjunction with hostname, list counters for\n *                                          the specified hostname and stat group -->\n *   <startTime time=\"ts\"/><!-- optional, defaults to last day, both must be specified otherwise -->\n *   <endTime time=\"ts\"/><!-- these are invalid if hostname and stats are not specified -->\n * </GetLoggerStatsRequest>\n * \n * <GetLoggerStatsResponse>\n *   <hostname hn=\"hn\"/>\n *   <hostname hn=\"...\"/> <!-- list hosts case -->\n *   \n *   <hostname hn=\"hn\"> <!-- list stat groups case -->\n *     <stats name=\"group1\"/>\n *     <stats name=\"group...\"/>\n *   </hostname>\n *   \n *   <hostname hn=\"hn\"> <!-- list columns case -->\n *     <stats name=\"group...\">\n *       <values>\n *         <stat name=\"col1\"/>\n *         <stat name=\"col2\"/>\n *         <stat name=\"col...\"/>\n *       </values>\n *     </stats>\n *   </hostname>\n *   \n *   <hostname hn=\"hn\"> <!-- stats case -->\n *     <stats name=\"group...\">\n *       <values t=\"ts\">\n *         <stat name=\"col1\" value=\"X\"/>\n *         <stat name=\"col2\" value=\"Y\"/>\n *         <stat name=\"col3\" value=\"Z\"/>\n *       </values>\n *       <values t=\"ts + N\">\n *         <stat name=\"col1\" value=\"X\"/>\n *         <stat name=\"col2\" value=\"Y\"/>\n *         <stat name=\"col3\" value=\"Z\"/>\n *       </values>\n *     </stats>\n *   </hostname>\n *   \n * </GetLoggerStatsResponse>\n * @author pfnguyen\n */\npublic class GetLoggerStats extends AdminDocumentHandler {\n    \n    private final static String ZMRRDFETCH = LC.zimbra_home.value() + \"/libexec/zmrrdfetch\";\n    private static final Pattern SPLIT_PATTERN = Pattern.compile(\"\\\\\\\"?\\\\s*,\\\\s*\\\\\\\"?\");\n\n    @Override\n    public Element handle(Element request, Map<String, Object> context) throws ServiceException {\n        ZimbraSoapContext zsc = getZimbraSoapContext(context);\n        \n        checkRight(zsc, context, null, AdminRight.PR_SYSTEM_ADMIN_ONLY);\n        \n        // this command can only execute on the monitor host, so proxy if necessary\n        Provisioning prov = Provisioning.getInstance();\n        String monitorHost = prov.getConfig().getAttr(Provisioning.A_zimbraLogHostname);\n        if (monitorHost == null || monitorHost.trim().equals(\"\"))\n            throw ServiceException.FAILURE(\"zimbraLogHostname is not configured\", null);\n        Server monitorServer = prov.get(ServerBy.name, monitorHost);\n        if (monitorServer == null)\n            throw ServiceException.FAILURE(\"could not find zimbraLogHostname server: \" + monitorServer, null);\n        if (!prov.getLocalServer().getId().equalsIgnoreCase(monitorServer.getId()))\n            return proxyRequest(request, context, monitorServer);\n        \n        Element response = zsc.createElement(AdminConstants.GET_LOGGER_STATS_RESPONSE);\n        boolean loggerEnabled = false;\n        Server local = prov.getLocalServer();\n        String[] services = local.getMultiAttr(Provisioning.A_zimbraServiceEnabled);\n        if (services != null) {\n            for (int i = 0; i < services.length && !loggerEnabled; i++) {\n                loggerEnabled = \"logger\".equals(services[i]);\n            }\n        }\n        if (loggerEnabled) {\n            Element host = request.getOptionalElement(AdminConstants.E_HOSTNAME);\n            Element stats = request.getOptionalElement(AdminConstants.E_STATS);\n            Element start = request.getOptionalElement(AdminConstants.E_START_TIME);\n            Element end = request.getOptionalElement(AdminConstants.E_END_TIME);\n            Element values = null;\n            HashSet<String> counters = null;\n            if (stats != null) {\n                values = stats.getOptionalElement(AdminConstants.E_VALUES);\n                if (values != null) {\n                    List<Element> counterList = values.listElements(AdminConstants.E_STAT);\n                    if (counterList.size() > 0)\n                        counters = new HashSet<String>(counterList.size());\n                    for (Element e : counterList) {\n                        counters.add(e.getAttribute(AdminConstants.A_NAME));\n                    }\n                }\n            }\n            \n            if (host == null && stats == null) {\n                // list hosts\n                fetchHostnames(response);\n            } else if (host != null && stats == null) {\n                // list groups for host\n                fetchGroupNames(response, host.getAttribute(AdminConstants.A_HOSTNAME));\n            } else if (stats != null && host == null) {\n                String limitStr = stats.getAttribute(AdminConstants.A_LIMIT, null);\n                boolean limit = limitStr != null && !\"no\".equalsIgnoreCase(limitStr) &&\n                        !\"false\".equalsIgnoreCase(limitStr) && !\"0\".equalsIgnoreCase(limitStr);\n                    \n                // fetch stats for all hosts\n                String startTime = null;\n                String endTime   = null;\n                if (start != null || end != null) {\n                    if (start == null || end == null)\n                        throw ServiceException.FAILURE(\"both start and end must be specified\", null);\n                    \n                    startTime = start.getAttribute(AdminConstants.A_TIME);\n                    endTime   = end.getAttribute(AdminConstants.A_TIME);\n                    fetchColumnData(response, counters,\n                            stats.getAttribute(AdminConstants.A_NAME),\n                            startTime, endTime, limit);\n                } else {\n                    fetchColumnData(response, counters,\n                            stats.getAttribute(AdminConstants.A_NAME), limit);\n                }\n            } else if (stats != null && host != null) {\n                \n                String statsText = stats.getText();\n                if (statsText != null && statsText.trim().length() > 0) {\n                    // list counters\n                    fetchColumnNames(response,\n                            host.getAttribute(AdminConstants.A_HOSTNAME),\n                            stats.getAttribute(AdminConstants.A_NAME));\n                } else {\n                    \n                    String limitStr = stats.getAttribute(AdminConstants.A_LIMIT, null);\n                    boolean limit = limitStr != null && !\"no\".equalsIgnoreCase(limitStr) &&\n                           !\"false\".equalsIgnoreCase(limitStr) && !\"0\".equalsIgnoreCase(limitStr);\n                    \n                    // fetch stats for host\n                    String startTime = null;\n                    String endTime   = null;\n\n                    if (start != null || end != null) {\n                        if (start == null || end == null)\n                            throw ServiceException.FAILURE(\"both start and end must be specified\", null);\n\n                        startTime = start.getAttribute(AdminConstants.A_TIME);\n                        endTime   = end.getAttribute(AdminConstants.A_TIME);\n                        fetchColumnData(response, counters,\n                                host.getAttribute(AdminConstants.A_HOSTNAME),\n                                stats.getAttribute(AdminConstants.A_NAME),\n                                startTime, endTime, limit);\n                    } else {\n                        fetchColumnData(response, counters,\n                                host.getAttribute(AdminConstants.A_HOSTNAME),\n                                stats.getAttribute(AdminConstants.A_NAME), limit);\n                    }\n                }\n            } else {\n                throw ServiceException.FAILURE(\"Unknown query combination\", null);\n            }\n        } else {\n            response.addElement(AdminConstants.E_NOTE).setText(\"Logger is not enabled\");\n        }\n        \n        return response;\n    }\n    \n    static void fetchHostnames(Element response) throws ServiceException {\n        Iterator<String> results = execfetch(\"-n\");\n        \n        while (results.hasNext()) {\n            Element host = response.addElement(AdminConstants.E_HOSTNAME);\n            host.addAttribute(AdminConstants.A_HOSTNAME, results.next());\n        }\n    }\n    static void fetchGroupNames(Element response, String hostname) throws ServiceException {\n        Iterator<String> results = execfetch(\"-l\", \"-h\", hostname);\n        Element host = response.addElement(AdminConstants.E_HOSTNAME);\n        host.addAttribute(AdminConstants.A_HOSTNAME, hostname);\n        while (results.hasNext()) {\n            Element stats = host.addElement(AdminConstants.E_STATS);\n            stats.addAttribute(AdminConstants.A_NAME, results.next());\n        }\n    }\n    static void fetchColumnNames(Element response, String hostname, String group) throws ServiceException {\n        Iterator<String> results = execfetch(\"-l\", \"-h\", hostname, \"-f\", group);\n        Element host = response.addElement(AdminConstants.E_HOSTNAME);\n        host.addAttribute(AdminConstants.A_HOSTNAME, hostname);\n        Element stats = host.addElement(AdminConstants.E_STATS);\n        stats.addAttribute(AdminConstants.A_NAME, group);\n        Element values = stats.addElement(AdminConstants.E_VALUES);\n        while (results.hasNext()) {\n            String result = results.next();\n            String name   = result;\n            int idx = result.indexOf(\" :: \");\n            Element stat = values.addElement(AdminConstants.E_STAT);\n            if (idx != -1) {\n                name = result.substring(0, idx);\n                String unit = result.substring(idx + 4);\n                stat.addAttribute(AdminConstants.A_TYPE, unit);\n            }\n            stat.addAttribute(AdminConstants.A_NAME, name);\n        }\n    }\n    static void fetchColumnData(Element response, Set<String> counters, String group,\n            String start, String end, boolean limit)\n    throws ServiceException {\n        Iterator<String> results;\n        if (limit)\n            results = execfetch(\"-c\", \"-f\", group, \"-s\", start, \"-e\", end);\n        else\n            results = execfetch(\"-f\", group, \"-s\", start, \"-e\", end);\n        populateResponseData(response, counters, group, results);\n    }\n    static void fetchColumnData(Element response, Set<String> counters, String hostname, String group,\n            String start, String end, boolean limit)\n    throws ServiceException {\n        Iterator<String> results;\n        if (limit) {\n            results = execfetch(\"-c\", \"-h\", hostname, \"-f\", group,\n                    \"-s\", start, \"-e\", end);\n        } else {\n            results = execfetch(\"-h\", hostname, \"-f\", group,\n                    \"-s\", start, \"-e\", end);\n        }\n        populateResponseData(response, counters, hostname, group, results);\n    }\n    static void fetchColumnData(Element response, Set<String> counters, String group, boolean limit)\n    throws ServiceException {\n        Iterator<String> results;\n        if (limit)\n            results = execfetch(\"-c\", \"-f\", group);\n        else\n            results = execfetch(\"-f\", group);\n        populateResponseData(response, counters, group, results);\n    }\n    static void fetchColumnData(Element response, Set<String> counters, String hostname, String group, boolean limit)\n    throws ServiceException {\n        Iterator<String> results;\n        if (limit)\n            results = execfetch(\"-c\", \"-h\", hostname, \"-f\", group);\n        else\n            results = execfetch(\"-h\", hostname, \"-f\", group);\n        populateResponseData(response, counters, hostname, group, results);\n    }\n    \n    static void populateResponseData(Element response, Set<String> counters,\n            String hostname, String group, Iterator<String> results)\n    throws ServiceException {\n        if (!results.hasNext())\n            return;\n        \n        String line = results.next();\n        String[] columns = SPLIT_PATTERN.split(line);\n        \n        Element host = response.addElement(AdminConstants.E_HOSTNAME);\n        host.addAttribute(AdminConstants.A_HOSTNAME, hostname);\n        Element stats = host.addElement(AdminConstants.E_STATS);\n        stats.addAttribute(AdminConstants.A_NAME, group);\n        while (results.hasNext()) {\n            line = results.next();\n            String[] data = SPLIT_PATTERN.split(line);\n            \n            boolean rowHasData = false;\n            for (int i = 1, j = data.length; i < j; i++)\n                rowHasData = rowHasData || (data[i] != null && !data[i].trim().equals(\"\"));\n            if (rowHasData) {\n                Element values = stats.addElement(AdminConstants.E_VALUES);\n                values.addAttribute(AdminConstants.A_T, data[0]);\n                for (int i = 1, j = data.length; i < j; i++) {\n                    if (counters != null && counters.size() > 0 && !counters.contains(columns[i]))\n                        continue;\n                    Element stat = values.addElement(AdminConstants.E_STAT);\n                    stat.addAttribute(AdminConstants.A_NAME, columns[i]);\n                    if (data[i] != null)\n                        stat.addAttribute(AdminConstants.A_VALUE, data[i]);\n                }\n            }\n        }\n        \n    }\n    static void populateResponseData(Element response, Set<String> counters, String group, Iterator<String> results)\n    throws ServiceException {\n        Element host = null;\n        Element stats = null;\n        String[] columns = null;\n        String line;\n        \n        boolean needColumns = false;\n        while (results.hasNext()) {\n            line = results.next();\n            if (\"\".equals(line.trim())) continue;\n            if (line.startsWith(\"Host: \")) {\n                String hostname = line.substring(line.indexOf(\" \") + 1);\n                \n                host = response.addElement(AdminConstants.E_HOSTNAME);\n                host.addAttribute(AdminConstants.A_HOSTNAME, hostname);\n                \n                stats = host.addElement(AdminConstants.E_STATS);\n                stats.addAttribute(AdminConstants.A_NAME, group);\n                \n                needColumns = true;\n                continue;\n            }\n            \n            if (needColumns) {\n                columns = SPLIT_PATTERN.split(line);\n                needColumns = false;\n                continue;\n            }\n            \n            String[] data = SPLIT_PATTERN.split(line);\n            \n            boolean rowHasData = false;\n            for (int i = 1, j = data.length; i < j; i++)\n                rowHasData = rowHasData || (data[i] != null && !data[i].trim().equals(\"\"));\n            if (rowHasData) {\n                Element values = stats.addElement(AdminConstants.E_VALUES);\n                values.addAttribute(AdminConstants.A_T, data[0]);\n                for (int i = 1, j = data.length; i < j; i++) {\n                    if (counters != null && counters.size() > 0 && !counters.contains(columns[i]))\n                        continue;\n                    Element stat = values.addElement(AdminConstants.E_STAT);\n                    stat.addAttribute(AdminConstants.A_NAME, columns[i]);\n                    if (data[i] != null)\n                        stat.addAttribute(AdminConstants.A_VALUE, data[i]);\n                }\n            }\n        }\n        \n    }\n\n    static Iterator<String> execfetch(String... args) throws ServiceException {\n        BufferedReader in = null;\n        try {\n            ArrayList<String> cmdline = new ArrayList<String>();\n            cmdline.add(ZMRRDFETCH);\n            cmdline.addAll(Arrays.asList(args));\n            ProcessBuilder pb = new ProcessBuilder(cmdline);\n            final Process p = pb.start();\n            in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n            final BufferedReader inbr = in;\n            \n            // there is a stream leak here if not read until the end\n            return new Iterator<String>() {\n                String line;\n                boolean isClosed = false;\n\n                public boolean hasNext() {\n                    try {\n                        line = inbr.readLine();\n                    }\n                    catch (IOException e) {\n                        ZimbraLog.soap.error(\"GetLoggerStats IOE\", e);\n                        line = null;\n                    }\n                    \n                    if (line == null) {\n                        try {\n                            inbr.close();\n                            isClosed = true;\n                        }\n                        catch (IOException e) { } // ignore\n                    }\n                    return line != null;\n                }\n\n                public String next() {\n                    if (!isClosed && line == null) {\n                        try {\n                            inbr.close();\n                        }\n                        catch (IOException e) { } // ignore\n                        throw new IllegalStateException(\"hasNext not called\");\n                    }\n                    if (isClosed)\n                        throw new IllegalStateException(\"no more results\");\n                    String l = line;\n                    line = null;\n                    return l;\n                }\n\n                public void remove() { throw new UnsupportedOperationException(\"remove\"); }\n                \n            };\n        }\n        catch (IOException e) {\n            throw ServiceException.FAILURE(\"Unable to read logger stats\", e);\n        }\n    }\n\n    @Override\n    public void docRights(List<AdminRight> relatedRights, List<String> notes) {\n        notes.add(AdminRightCheckPoint.Notes.SYSTEM_ADMINS_ONLY);\n    }\n}\n",
    "vulnerability_type": "Command Injection",
    "repo": "zm-mailbox",
    "commit": "d6541de95dba02012001c46e18ea39060a4d5e1e",
    "commit_msg": "(split)bug:40637\n\nzmlogger: spawn off a lightweight server to handle zmrrdfetch requests\n\nGetLoggerStats.java: invoke the server in zmlogger (localhost socket) instead of forking zmrrdfetch using ProcessBuilder\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=40637\n\nCopied from Perforce\n Change: 213676",
    "original_file": "GetLoggerStats.java",
    "confidence_score": 0.6
  },
  {
    "serial_no": 15,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\nimport org.apache.commons.pool.impl.GenericObjectPool;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private static final String PRAGMA_JOURNAL_MODE_DEFAULT = \"DELETE\";\n    private static final String PRAGMA_SYNCHRONOUS_DEFAULT  = \"FULL\";\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n    private String journalMode;\n    private String pageSize;\n    private String syncMode;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, \"foreign key\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT, \"foreign key\");\n        mErrorCodes.put(Db.Error.TOO_MANY_SQL_PARAMS, \"too many SQL variables\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case NON_BMP_CHARACTERS:         return true;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return true;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n            case SQL_PARAM_LIMIT:            return true;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        cacheSize = LC.sqlite_cache_size.value();\n        if (cacheSize.equals(\"0\"))\n            cacheSize = null;\n        journalMode = LC.sqlite_journal_mode.value();\n        pageSize = LC.sqlite_page_size.value();\n        if (pageSize.equals(\"0\"))\n            pageSize = null;\n        syncMode = LC.sqlite_sync_mode.value();\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" +\n            (cacheSize == null ? \"default\" : cacheSize) + \" cache cache, \" +\n            (pageSize == null ? \"default\" : pageSize) + \" page size, \" +\n            journalMode + \" journal mode, \" + syncMode + \" sync mode\");\n        super.startup(pool, poolSize);\n    }\n\n    @Override void postCreate(java.sql.Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            pragmas(conn, null);\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(java.sql.Connection conn, String dbname, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        \n        try {\n            String prefix = dbname == null || dbname.equals(\"zimbra\") ? \"\" : dbname + \".\";\n            (stmt = conn.prepareStatement(\"PRAGMA \" + prefix + key +\n                (value == null ? \"\" : \" = \" + value))).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    void pragmas(java.sql.Connection conn, String dbname) throws SQLException {\n        /*\n         * auto_vacuum causes databases to be locked permanently\n         * pragma(conn, dbname, \"auto_vacuum\", \"2\");\n         */\n        pragma(conn, dbname, \"foreign_keys\", \"ON\");\n        if (journalMode != null && !journalMode.equalsIgnoreCase(PRAGMA_JOURNAL_MODE_DEFAULT))\n            pragma(conn, dbname, \"journal_mode\", journalMode);\n        if (syncMode != null && !syncMode.equalsIgnoreCase(PRAGMA_SYNCHRONOUS_DEFAULT))\n            pragma(conn, dbname, \"synchronous\", syncMode);\n        if (cacheSize != null)\n            pragma(conn, dbname, \"cache_size\", cacheSize);\n        if (pageSize != null)\n            pragma(conn, dbname, \"page_size\", pageSize);\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 6;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void optimize(Connection conn, String dbname, int level)\n        throws ServiceException {\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            PreparedStatement stmt = null;\n\n            try {\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(true);\n                if (dbname == null)\n                    dbname = \"zimbra\";\n                registerDatabaseInterest(conn, dbname);\n                if (level > 0 && dbname.endsWith(\"zimbra\")) {\n                    if (level == 2)\n                        (stmt = conn.prepareStatement(\"VACUUM\")).execute();\n                    else\n                        pragma(conn.getConnection(), dbname, \"incremental_vacuum\", null);\n                }\n                (stmt = conn.prepareStatement(\"ANALYZE \" + dbname)).execute();\n                ZimbraLog.dbconn.debug(\"sqlite \" +\n                    (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname);\n            } finally {\n                if (!autocommit) {\n                    try {\n                        conn.getConnection().setAutoCommit(autocommit);\n                    } catch (SQLException sqle) {\n                        ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                        DbPool.quietClose(conn);\n                        throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                    }\n                }\n\n                DbPool.quietCloseStatement(stmt);\n            }\n        } catch (Exception e) {\n            throw ServiceException.FAILURE(\"sqlite \" +\n                (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname + \" error\", e);\n        }\n    }\n    \n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n                \n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n            pragmas(conn.getConnection(), dbname);\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.error(\"database \" + dbname + \" attach failed\", e);\n            if (!\"database is already attached\".equals(e.getMessage()))\n                throw e;\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors \" + dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.quietCloseStatement(stmt);\n        }\n        \n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) throws ServiceException {\n        PreparedStatement stmt = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit) {\n                conn.getConnection().setAutoCommit(true);\n            }\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n            return true;\n        } catch (SQLException e) {\n            if (!deleted.containsKey(dbname)) { \n                ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n                return false;\n            } else {\n                return true;\n            }\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private ConcurrentMap<String,Boolean> deleted = new ConcurrentHashMap<String, Boolean>();\n\n    @Override\n    void deleteDatabaseFile(Connection conn, String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        try {\n            detachDatabase(conn, dbname);\n        } catch (ServiceException se) {\n            ZimbraLog.dbconn.warn(\"failed to detach while deleting\");\n        }\n        deleted.put(dbname,true);\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n        new File(getDatabaseFilename(dbname) + \"-journal\").delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n            whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_GROW; //we use a small pool. we can easily starve when any code requires more than one connection to complete a single operation\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            if (LC.sqlite_shared_cache_enabled.booleanValue())\n                props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    @Override protected int getInClauseBatchSize() {\n        return 200;\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "aa3118574a4305282e8d851fb56710f7ee24d6de",
    "commit_msg": "(split)bug: 67729\n\nHandle AND clause with too many parameters for SQLite. Optimize default folder search in:folder1 to avoid query on all visible folders.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=67729\n\nCopied from Perforce\n Change: 341461",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 16,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2005, 2006, 2007, 2008 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.cs.db.DbPool.Connection;\n\n/**\n * <code>DbUtil</code> contains some database utility methods and\n * automates the task of running SQL statements.  It\n * wraps the JDBC <code>Connection</code>and <code>PreparedStatement</code>\n * classes and frees the caller from having to handle <code>SQLException</code>\n * and allocate and deallocate database resources.<p>\n * \n * Query results are read entirely into memory and returned in the form of a\n * {@link com.zimbra.cs.db.DbResults} object.  This improves concurrency,\n * but potentially increases memory consumption.  Code that deals with\n * large result sets should use the JDBC API's directly.\n * \n * @author bburtin\n */\npublic class DbUtil {\n\n    public static final int INTEGER_TRUE = 1;\n    public static final int INTEGER_FALSE = 0;\n    \n    public static final int getBooleanIntValue(boolean b) {\n        return b ? INTEGER_TRUE : INTEGER_FALSE;\n    }\n    \n    private static final Pattern PAT_ESCAPED_QUOTES1 = Pattern.compile(\"\\\\\\\\'\");\n    private static final Pattern PAT_ESCAPED_QUOTES2 = Pattern.compile(\"''\");\n    private static final Pattern PAT_STRING_CONSTANT = Pattern.compile(\"'[^']+'\");\n    private static final Pattern PAT_INTEGER_CONSTANT = Pattern.compile(\"\\\\d+\");\n    private static final Pattern PAT_NULL_CONSTANT = Pattern.compile(\"NULL\");\n    private static final Pattern PAT_BEGIN_SPACE = Pattern.compile(\"^\\\\s+\");\n    private static final Pattern PAT_TRAILING_SPACE = Pattern.compile(\"\\\\s+$\");\n    private static final Pattern PAT_MULTIPLE_SPACES = Pattern.compile(\"\\\\s+\");\n    private static final Pattern PAT_IN_CLAUSE = Pattern.compile(\"IN \\\\([^\\\\)]+\\\\)\", Pattern.DOTALL);\n\n    /**\n     * Converts a <tt>java.util.Date</tt> to a <tt>java.sql.Timestamp</tt>.\n     * If the date is <tt>null</tt>, returns <tt>null</tt>.\n     */\n    public static Timestamp dateToTimestamp(Date date) {\n        return date == null ? null : new Timestamp(date.getTime());\n    }\n\n    /**\n     * Converts a  <tt>java.sql.Timestamp</tt> to a <tt>java.util.Date</tt>.\n     * If the timestamp is <tt>null</tt>, returns <tt>null</tt>.\n     */\n    public static Date timestampToDate(Timestamp timestamp) {\n        return timestamp == null ? null : new Date(timestamp.getTime());\n    }\n\n    /**\n     * Converts the given <code>SQL</code> string to a normalized version.\n     * Strips out any numbers, string constants and extra whitespace.  Flattens\n     * the contents of <code>IN</code> clauses.\n     */\n    public static String normalizeSql(String sql) {\n        Matcher matcher = PAT_ESCAPED_QUOTES1.matcher(sql);\n        sql = matcher.replaceAll(\"\");\n        matcher = PAT_ESCAPED_QUOTES2.matcher(sql);\n        sql = matcher.replaceAll(\"XXX\");\n        matcher = PAT_STRING_CONSTANT.matcher(sql);\n        sql = matcher.replaceAll(\"XXX\");\n        matcher = PAT_INTEGER_CONSTANT.matcher(sql);\n        sql = matcher.replaceAll(\"XXX\");\n        matcher = PAT_NULL_CONSTANT.matcher(sql);\n        sql = matcher.replaceAll(\"XXX\");\n        matcher = PAT_BEGIN_SPACE.matcher(sql);\n        sql = matcher.replaceAll(\"\");\n        matcher = PAT_TRAILING_SPACE.matcher(sql);\n        sql = matcher.replaceAll(\"\");\n        matcher = PAT_MULTIPLE_SPACES.matcher(sql);\n        sql = matcher.replaceAll(\" \");\n        matcher = PAT_IN_CLAUSE.matcher(sql);\n        sql = matcher.replaceAll(\"IN (...)\");\n        return sql;\n    }\n\n    /**\n     * Executes the specified query using the specified connection.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(Connection conn, String query, Object[] params)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        DbResults results = null;\n        \n        try {\n            stmt = conn.prepareStatement(query);\n            \n            if (params != null) {\n                for (int i = 0; i < params.length; i++)\n                    stmt.setObject(i + 1, params[i]);\n            }\n            ResultSet rs = stmt.executeQuery();\n            results = new DbResults(rs);\n        } catch (SQLException e) {\n            String message = \"SQL: '\" + query + \"'\";\n            throw ServiceException.FAILURE(message, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n        \n        return results;\n    }\n    \n    /**\n     * Executes the specified query using a connection from the connection pool.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(Connection conn, String query, Object param)\n    throws ServiceException {\n        Object[] params = { param };\n        return executeQuery(conn, query, params);\n    }\n    \n    /**\n     * Executes the specified query using the specified connection.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(Connection conn, String query)\n    throws ServiceException {\n        return executeQuery(conn, query, null);\n    }\n    \n    /**\n     * Executes the specified query using a connection from the connection pool.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(String query, Object[] params)\n    throws ServiceException {\n        Connection conn = null;\n        try {\n            conn = DbPool.getConnection();\n            return executeQuery(conn, query, params);\n        } finally {\n            DbPool.quietClose(conn);\n        }\n    }\n    \n    /**\n     * Executes the specified query using a connection from the connection pool.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(String query, Object param)\n    throws ServiceException {\n        Object[] params = { param };\n        return executeQuery(query, params);\n    }\n    \n    /**\n     * Executes the specified query using a connection from the connection pool.\n     * \n     * @throws ServiceException if the query cannot be executed or an error\n     * occurs while retrieving results\n     */\n    public static DbResults executeQuery(String query)\n    throws ServiceException {\n        return executeQuery(query, null);\n    }\n    \n    /**\n     * Executes the specified update using the specified connection.\n     * \n     * @return the number of rows affected\n     * @throws ServiceException if the update cannot be executed\n     */\n    public static int executeUpdate(Connection conn, String sql, Object[] params)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        int numRows = 0;\n        \n        try {\n            stmt = conn.prepareStatement(sql);\n            \n            if (params != null) {\n                for (int i = 0; i < params.length; i++) {\n                    stmt.setObject(i + 1, params[i]);\n                }\n            }\n            numRows = stmt.executeUpdate();\n        } catch (SQLException e) {\n            String message = \"SQL: '\" + sql + \"'\";\n            throw ServiceException.FAILURE(message, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n        \n        return numRows;\n    }\n    \n    /**\n     * Executes the specified update using the specified connection.\n     * \n     * @return the number of rows affected\n     * @throws ServiceException if the update cannot be executed\n     */\n    public static int executeUpdate(Connection conn, String sql, Object param)\n    throws ServiceException {\n        Object[] params = { param };\n        return executeUpdate(conn, sql, params);\n    }\n    \n    /**\n     * Executes the specified update using the specified connection.\n     * \n     * @return the number of rows affected\n     * @throws ServiceException if the update cannot be executed\n     */\n    public static int executeUpdate(Connection conn, String sql)\n    throws ServiceException {\n        return executeUpdate(conn, sql, null);\n    }\n    \n    /**\n     * Executes the specified update using a connection from the connection pool.\n     * \n     * @return the number of rows affected\n     * @throws ServiceException if the update cannot be executed\n     */\n    public static int executeUpdate(String sql, Object[] params)\n    throws ServiceException {\n        Connection conn = DbPool.getConnection();\n        try {\n            int numRows = executeUpdate(conn, sql, params);\n            conn.commit();\n            return numRows;\n        } finally {\n            DbPool.quietClose(conn);\n        }\n    }\n    \n    /**\n     * Executes the specified update using a connection from the connection pool.\n     * \n     * @return the number of rows affected\n     * @throws ServiceException if the update cannot be executed\n     */\n    public static int executeUpdate(String sql, Object param)\n    throws ServiceException {\n        Object[] params = { param };\n        return executeUpdate(sql, params);\n    }\n    \n    public static int executeUpdate(String sql)\n    throws ServiceException {\n        return executeUpdate(sql, null);\n    }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>, which\n     * contains as many question marks as the number of elements in the\n     * given array.  Used for generating SQL IN clauses.\n     */\n    public static String suitableNumberOfVariables(byte[] array)        { return DbUtil.suitableNumberOfVariables(array.length); }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>, which\n     * contains as many question marks as the number of elements in the\n     * given array.  Used for generating SQL IN clauses.\n     */\n    public static String suitableNumberOfVariables(short[] array)         { return DbUtil.suitableNumberOfVariables(array.length); }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>, which\n     * contains as many question marks as the number of elements in the\n     * given array.  Used for generating SQL IN clauses.\n     */\n    public static String suitableNumberOfVariables(int[] array)         { return DbUtil.suitableNumberOfVariables(array.length); }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>, which\n     * contains as many question marks as the number of elements in the\n     * given array.  Used for generating SQL IN clauses.\n     */\n    public static String suitableNumberOfVariables(Object[] array)      { return DbUtil.suitableNumberOfVariables(array.length); }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>, which\n     * contains as many question marks as the number of elements in the\n     * given array.  Used for generating SQL IN clauses.\n     */\n    public static String suitableNumberOfVariables(Collection c)        { return DbUtil.suitableNumberOfVariables(c.size()); }\n\n    /**\n     * Returns a string with the form <code>(?, ?, ?, ...)</code>.\n     * Used for generating SQL IN clauses.\n     * @param size the number of question marks\n     */\n    public static String suitableNumberOfVariables(int size) {\n        StringBuilder sb = new StringBuilder(\" (\");\n        for (int i = 0; i < size; i++)\n            sb.append(i == 0 ? \"?\" : \", ?\");\n        return sb.append(\")\").toString();\n    }\n    \n    /**\n     * Executes all SQL statements in the specified SQL script.  Statements are\n     * separated by semicolons.\n     * \n     * @param conn the database connection to use for executing the SQL statements\n     * @param scriptReader the source of the SQL script file. The reader is closed\n     * when this method returns.\n     */\n    public static void executeScript(DbPool.Connection conn, Reader scriptReader)\n    throws IOException, ServiceException, SQLException {\n        PreparedStatement stmt = null;\n        String[] statements = parseScript(scriptReader);\n        try {\n            for (String sql : statements) {\n                stmt = conn.prepareStatement(sql);\n                stmt.execute();\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            DbPool.quietRollback(conn);\n            throw e;\n        } \n    }\n    \n    /**\n     * Parses a SQL script into separate SQL statements, separated by semicolons.\n     * Removes comments that begin with <code>--</code> or <code>#</code>.\n     */\n    public static String[] parseScript(Reader scriptReader)\n    throws IOException {\n        StringBuilder buf = new StringBuilder();\n        BufferedReader br = new BufferedReader(scriptReader);\n        String line;\n        while ((line = br.readLine()) != null) {\n            line = removeComments(line);\n            buf.append(line);\n            line = line.trim();\n            if (line.length() == 0) {\n                // ignore comments or blank lines\n                continue;\n            }\n            buf.append('\\n');\n        }\n        br.close();\n        String script = buf.toString();\n        return script.split(\"\\\\s*\" + Db.getInstance().scriptCommandDelimiter() + \"\\\\s*\");\n    }\n\n    /**\n     * Removes trailing comments.  Comments begin with <code>--</code> or <code>#</code>.\n     * @return <code>sqlLine</code> without trailing comments\n     */\n    public static String removeComments(String sqlLine) {\n        // remove comments that start with \"#\" or \"--\"\n        int commentIndex = sqlLine.indexOf(\"--\");\n        int hashIndex = sqlLine.indexOf('#');\n        if (hashIndex >= 0) {\n            if (commentIndex >= 0) {\n                commentIndex = Math.min(commentIndex, hashIndex);\n            } else {\n                commentIndex = hashIndex;\n            }\n        }\n        if (commentIndex != -1) {\n            sqlLine = sqlLine.substring(0, commentIndex);\n        }\n        return sqlLine;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6713e51587bf06470b5d7e638845cd245bc7baad",
    "commit_msg": "(split)bug: 35710 more sqlite/derby build issues\nzimbra.db is now created dynamically during server startup\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=35710\n\nCopied from Perforce\n Change: 212005",
    "original_file": "DbUtil.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 17,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Aug 13, 2004\n */\npackage com.zimbra.cs.db;\n\nimport java.io.UnsupportedEncodingException;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.Constants;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.LogFactory;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.TimeoutMap;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.CalendarItem;\nimport com.zimbra.cs.mailbox.Conversation;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxBlob;\nimport com.zimbra.cs.mailbox.Message;\nimport com.zimbra.cs.mailbox.Note;\nimport com.zimbra.cs.mailbox.SearchFolder;\nimport com.zimbra.cs.mailbox.Tag;\nimport com.zimbra.cs.mailbox.VirtualConversation;\nimport com.zimbra.cs.mailbox.MailItem.PendingDelete;\nimport com.zimbra.cs.mailbox.MailItem.UnderlyingData;\nimport com.zimbra.cs.mailbox.util.TypedIdList;\nimport com.zimbra.cs.pop3.Pop3Message;\nimport com.zimbra.cs.store.StoreManager;\n\npublic class DbMailItem {\n\n    public static final String TABLE_MAIL_ITEM = \"mail_item\";\n    public static final String TABLE_REVISION = \"revision\";\n    public static final String TABLE_APPOINTMENT = \"appointment\";\n    public static final String TABLE_OPEN_CONVERSATION = \"open_conversation\";\n    public static final String TABLE_TOMBSTONE = \"tombstone\";\n\n    private static Log sLog = LogFactory.getLog(DbMailItem.class);\n\n    /** Maps the mailbox id to the set of all tag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by tag. */\n    private static final Map<Integer, TagsetCache> sTagsetCache =\n        new TimeoutMap<Integer, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    /** Maps the mailbox id to the set of all flag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by flag. */\n    private static final Map<Integer, TagsetCache> sFlagsetCache =\n        new TimeoutMap<Integer, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    public static final int MAX_SENDER_LENGTH  = 128;\n    public static final int MAX_SUBJECT_LENGTH = 1024;\n    public static final int MAX_TEXT_LENGTH    = 65534;\n    public static final int MAX_MEDIUMTEXT_LENGTH = 16777216;\n\n    public static final String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id = ? AND \";\n    public static final String MAILBOX_ID = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n    public static final String MAILBOX_ID_VALUE = DebugConfig.disableMailboxGroups ? \"\" : \"?, \";\n    private static final int RESULTS_STREAMING_MIN_ROWS = 10000; \n    \n    static final int setMailboxId(PreparedStatement stmt, Mailbox mbox, int pos) throws SQLException {\n        if (!DebugConfig.disableMailboxGroups)\n            stmt.setInt(pos++, mbox.getId());\n        return pos;\n    }\n    \n    public static final String getInThisMailboxAnd(int mboxId, String miAlias, String apAlias) {\n        if (DebugConfig.disableMailboxGroups)\n            return \"\";\n\n        StringBuilder sb = new StringBuilder(miAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        if (apAlias != null) \n            sb.append(apAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        return sb.toString();\n    }\n\n\n    public static void create(Mailbox mbox, UnderlyingData data, String sender) throws ServiceException {\n        if (data == null || data.id <= 0 || data.folderId <= 0 || data.parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item create\", null);\n\n        checkNamingConstraint(mbox, data.folderId, data.name, data.id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getMailItemTableName(mbox) +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"VALUES (\" + MAILBOX_ID_VALUE +\n                        \" ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, data.id);\n            stmt.setByte(pos++, data.type);\n            if (data.parentId <= 0)\n                // Messages in virtual conversations are stored with a null parent_id\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, data.parentId);\n            stmt.setInt(pos++, data.folderId);\n            if (data.indexId == null)\n                stmt.setNull(pos++, Types.VARCHAR);\n            else\n                stmt.setString(pos++, data.indexId);\n            if (data.imapId <= 0)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, data.imapId);\n            stmt.setInt(pos++, data.date);\n            stmt.setLong(pos++, data.size);\n            if (data.volumeId >= 0)\n                stmt.setShort(pos++, data.volumeId);\n            else\n                stmt.setNull(pos++, Types.TINYINT);\n            stmt.setString(pos++, data.getBlobDigest());\n            if (data.type == MailItem.TYPE_MESSAGE || data.type == MailItem.TYPE_CHAT || data.type == MailItem.TYPE_FOLDER)\n                stmt.setInt(pos++, data.unreadCount);\n            else\n                stmt.setNull(pos++, Types.BOOLEAN);\n            stmt.setInt(pos++, data.flags);\n            stmt.setLong(pos++, data.tags);\n            stmt.setString(pos++, checkSenderLength(sender));\n            stmt.setString(pos++, checkSubjectLength(data.subject));\n            stmt.setString(pos++, data.name);\n            stmt.setString(pos++, checkMetadataLength(data.metadata));\n            stmt.setInt(pos++, data.modMetadata);\n            if (data.dateChanged > 0)\n                stmt.setInt(pos++, data.dateChanged);\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            stmt.setInt(pos++, data.modContent);\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n\n            // Track the tags and flags for fast lookup later\n            if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).addTagset(data.tags);\n            if (areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(data.flags);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            else\n                throw ServiceException.FAILURE(\"writing new object of type \" + data.type, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static void checkNamingConstraint(Mailbox mbox, int folderId, String name, int modifiedItemId) throws ServiceException {\n        if (name == null || name.equals(\"\"))\n            return;\n        if (Db.supports(Db.Capability.UNIQUE_NAME_INDEX) && !Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON))\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND id <> ? AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, modifiedItemId);\n            stmt.setString(pos++, StringUtil.trimTrailingSpaces(name.toUpperCase()));\n            rs = stmt.executeQuery();\n            if (!rs.next() || rs.getInt(1) > 0)\n                throw MailServiceException.ALREADY_EXISTS(name);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"checking for naming conflicts\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void copy(MailItem item, int id, Folder folder, String indexId, int parentId, short volumeId, String metadata)\n    throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (id <= 0 || indexId == null || folder == null || parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item copy\", null);\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + table +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + MAILBOX_ID_VALUE +\n                        \" ?, type, ?, ?, ?, ?, date, size, ?, blob_digest, unread,\" +\n                        \" flags, tags, sender, subject, name, ?, ?, ?, ? FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, id);                            // ID\n            if (parentId <= 0)\n                stmt.setNull(pos++, Types.INTEGER);            // PARENT_ID null for messages in virtual convs\n            else\n                stmt.setInt(pos++, parentId);                  //   or, PARENT_ID specified by caller\n            stmt.setInt(pos++, folder.getId());                // FOLDER_ID\n            stmt.setString(pos++, indexId);                       // INDEX_ID\n            stmt.setInt(pos++, id);                            // IMAP_ID is initially the same as ID\n            if (volumeId >= 0)\n                stmt.setShort(pos++, volumeId);                // VOLUME_ID specified by caller\n            else\n                stmt.setNull(pos++, Types.TINYINT);            //   or, no VOLUME_ID\n            stmt.setString(pos++, checkMetadataLength(metadata));  // METADATA\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(id, e);\n            else\n                throw ServiceException.FAILURE(\"copying \" + MailItem.getNameForType(item ) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void icopy(MailItem source, UnderlyingData data, boolean shared) throws ServiceException {\n        Mailbox mbox = source.getMailbox();\n        if (data == null || data.id <= 0 || data.folderId <= 0 || data.parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item i-copy\", null);\n\n        checkNamingConstraint(mbox, data.folderId, source.getName(), data.id);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            String flags;\n            if (!shared)\n                flags = \"flags\";\n            else if (Db.supports(Db.Capability.BITWISE_OPERATIONS))\n                flags = \"flags | \" + Flag.BITMASK_COPIED;\n            else\n                flags = \"CASE WHEN \" + Db.bitmaskAND(\"flags\", Flag.BITMASK_COPIED) + \" THEN flags ELSE flags + \" + Flag.BITMASK_COPIED + \" END\";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + table +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id +\n                        \" ?, type, parent_id, ?, ?, ?, date, size, ?, blob_digest,\" +\n                        \" unread, \" + flags + \", tags, sender, subject, name, metadata, ?, ?, ? FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, data.id);                       // ID\n            stmt.setInt(pos++, data.folderId);                 // FOLDER_ID\n            stmt.setString(pos++, data.indexId);               // INDEX_ID\n            stmt.setInt(pos++, data.imapId);                   // IMAP_ID\n            if (data.volumeId >= 0)\n                stmt.setShort(pos++, data.volumeId);           // VOLUME_ID\n            else\n                stmt.setNull(pos++, Types.TINYINT);            //   or, no VOLUME_ID\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, source.getId());\n            stmt.executeUpdate();\n            stmt.close();\n\n            boolean needsTag = shared && !source.isTagged(Flag.ID_FLAG_COPIED);\n\n            if (needsTag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(source.getInternalFlagBitmask() | Flag.BITMASK_COPIED);\n\n            if (needsTag || source.getParentId() > 0) {\n                boolean altersMODSEQ = source.getParentId() > 0;\n                String updateChangeID = (altersMODSEQ ? \", mod_metadata = ?, change_date = ?\" : \"\");\n                stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = NULL, flags = \" + flags + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                pos = 1;\n                if (altersMODSEQ) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.setInt(pos++, source.getId());\n                stmt.executeUpdate();\n                stmt.close();\n            }\n\n            if (source instanceof Message && source.getParentId() <= 0)\n                changeOpenTarget(Mailbox.getHash(((Message) source).getNormalizedSubject()), source, data.id);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            else\n                throw ServiceException.FAILURE(\"i-copying \" + MailItem.getNameForType(source) + \": \" + source.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void snapshotRevision(MailItem item, int version) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        assert(version >= 1);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getRevisionTableName(mbox) +\n                        \"(\" + mailbox_id + \"item_id, version, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id + \"id, ?, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, version);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to copy revision data\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getId(), e);\n            else\n                throw ServiceException.FAILURE(\"saving revision info for \" + MailItem.getNameForType(item) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void purgeRevisions(MailItem item, int highestPurged) throws ServiceException {\n        if (highestPurged <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getRevisionTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ? AND version <= ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.setInt(pos++, highestPurged);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"purging revisions for \" + MailItem.getNameForType(item) + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void changeType(MailItem item, byte type) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET type = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, type);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new type for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(MailItem item, Folder folder) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != folder.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            int pos = 1;\n            boolean hasIndexId = false;\n            if (item instanceof Folder) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET parent_id = ?, folder_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                stmt.setInt(pos++, folder.getId());\n            } else if (item instanceof Conversation && !(item instanceof VirtualConversation)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ?\");\n            } else {\n                // set the indexId, in case it changed (moving items out of junk can trigger an index ID change)\n                hasIndexId = true;\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, index_id = ?, mod_metadata = ?, change_date = ? \" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            }\n            stmt.setInt(pos++, folder.getId());\n            if (hasIndexId)\n                if (item.getIndexId() == null)\n                    stmt.setNull(pos++, Types.VARCHAR);\n                else\n                    stmt.setString(pos++, item.getIndexId());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            else\n                throw ServiceException.FAILURE(\"writing new folder data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(List<Message> msgs, Folder folder) throws ServiceException {\n        if (msgs == null || msgs.isEmpty())\n            return;\n        Mailbox mbox = folder.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            // commented out because at present messages cannot have names (and thus can't have naming conflicts)\n//            if (!Db.supports(Db.Capability.UNIQUE_NAME_INDEX) || Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) {\n//                stmt = conn.prepareStatement(\"SELECT mi.name\" +\n//                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getMailItemTableName(mbox, \"m2\") +\n//                        \" WHERE mi.id IN \" + DbUtil.suitableNumberOfVariables(itemIDs) +\n//                        \" AND mi.name IS NOT NULL and m2.name IS NOT NULL\" +\n//                        \" AND m2.folder_id = ? AND mi.id <> m2.id\" +\n//                        \" AND \" + (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) ? \"UPPER(mi.name) = UPPER(m2.name)\" : \"mi.name = m2.name\") +\n//                        \" AND mi.mailbox_id = ? AND m2.mailbox_id = ?\");\n//                int pos = 1;\n//                for (Message msg : msgs)\n//                    stmt.setInt(pos++, msg.getId());\n//                stmt.setInt(pos++, folder.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                rs = stmt.executeQuery();\n//                if (rs.next())\n//                    throw MailServiceException.ALREADY_EXISTS(rs.getString(1));\n//                rs.close();\n//                stmt.close();\n//            }\n\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            for (int i = 0; i < msgs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), msgs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, msgs.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n//            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n//                throw MailServiceException.ALREADY_EXISTS(msgs.toString(), e);\n//            else\n            throw ServiceException.FAILURE(\"writing new folder data for messages\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void setIndexIds(Mailbox mbox, List<Message> msgs) throws ServiceException {\n        if (msgs == null || msgs.isEmpty())\n            return;\n        \n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < msgs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), msgs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET index_id = id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, msgs.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n//            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n//                throw MailServiceException.ALREADY_EXISTS(msgs.toString(), e);\n//            else\n            throw ServiceException.FAILURE(\"writing new folder data for messages\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n\n    public static void setParent(MailItem child, MailItem parent) throws ServiceException {\n        setParent(new MailItem[] { child }, parent);\n    }\n\n    public static void setParent(MailItem[] children, MailItem parent) throws ServiceException {\n        if (children == null || children.length == 0)\n            return;\n        Mailbox mbox = children[0].getMailbox();\n        if (mbox != parent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < children.length; i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), children.length - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (parent == null || parent instanceof VirtualConversation)\n                    stmt.setNull(pos++, Types.INTEGER);\n                else\n                    stmt.setInt(pos++, parent.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, children[index].getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"adding children to parent \" + (parent == null ? \"NULL\" : parent.getId() + \"\"), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void reparentChildren(MailItem oldParent, MailItem newParent) throws ServiceException {\n        if (oldParent == newParent)\n            return;\n        Mailbox mbox = oldParent.getMailbox();\n        if (mbox != newParent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation = (oldParent instanceof VirtualConversation ? \"id = ?\" : \"parent_id = ?\");\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(oldParent) +\n                        \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + relation);\n            int pos = 1;\n            if (newParent instanceof VirtualConversation)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, newParent.getId());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, oldParent instanceof VirtualConversation ? ((VirtualConversation) oldParent).getMessageId() : oldParent.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new parent for children of item \" + oldParent.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveMetadata(MailItem item, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void persistCounts(MailItem item, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET size = ?, unread = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getUnreadCount());\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, item.getModifiedSequence());\n            if (item.getChangeDate() > 0)\n                stmt.setInt(pos++, (int) (item.getChangeDate() / 1000));\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            stmt.setInt(pos++, item.getSavedSequence());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // need to kill the Note class sooner rather than later\n    public static void saveSubject(Note note) throws ServiceException {\n        Mailbox mbox = note.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(note) +\n                        \" SET date = ?, size = ?, subject = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (note.getDate() / 1000));\n            stmt.setLong(pos++, note.getSize());\n            stmt.setString(pos++, checkSubjectLength(note.getSubject()));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, note.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing subject for mailbox \" + note.getMailboxId() + \", note \" + note.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveName(MailItem item, int folderId, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        String name = item.getName().equals(\"\") ? null : item.getName();\n\n        checkNamingConstraint(mbox, folderId, name, item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n        \tboolean isFolder = item instanceof Folder;\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, flags = ?, name = ?, subject = ?,\" +\n                        \"  folder_id = ?,\" + (isFolder ? \" parent_id = ?,\" : \"\") +\n                        \"  metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, name);\n            stmt.setInt(pos++, folderId);\n            if (isFolder)\n                stmt.setInt(pos++, folderId);\n            stmt.setString(pos++, metadata);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(name, e);\n            else\n                throw ServiceException.FAILURE(\"writing name for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveData(MailItem item, String subject, String sender, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        String name = item.getName().equals(\"\") ? null : item.getName();\n\n        if (item instanceof Conversation)\n            subject = ((Conversation) item).getNormalizedSubject();\n        else if (item instanceof Message)\n            subject = ((Message) item).getNormalizedSubject();\n\n        checkNamingConstraint(mbox, item.getFolderId(), name, item.getId());\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET type = ?, imap_id = ?, parent_id = ?, date = ?, size = ?, flags = ?,\" +\n                        \"  blob_digest = ?, sender = ?, subject = ?, name = ?, metadata = ?,\" +\n                        \"  mod_metadata = ?, change_date = ?, mod_content = ?, volume_id = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setByte(pos++, item.getType());\n            if (item.getImapUid() >= 0)\n                stmt.setInt(pos++, item.getImapUid());\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            // messages in virtual conversations are stored with a null parent_id\n            if (item.getParentId() <= 0)\n                stmt.setNull(pos++, Types.INTEGER);\n            else\n                stmt.setInt(pos++, item.getParentId());\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, item.getDigest());\n            stmt.setString(pos++, checkSenderLength(sender));\n            stmt.setString(pos++, checkSubjectLength(subject));\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            short vol = item.getVolumeId();\n            if (vol > 0)\n                stmt.setShort(pos++, item.getVolumeId());\n            else\n                stmt.setNull(pos++, Types.TINYINT);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n\n            // Update the flagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(item.getInternalFlagBitmask());\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            else\n                throw ServiceException.FAILURE(\"rewriting row data for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void openConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getConversationTableName(item) +\n                        \"(\" + mailbox_id + \"hash, conv_id)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(item) +\n                            \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, item.getId());\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    stmt.setString(pos++, hash);\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating open conversation association for hash \" + hash, nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing open conversation association for hash \" + hash, e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void closeConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(item) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ? AND conv_id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversation association for hash \" + hash, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes rows from <tt>open_conversation</tt> whose items are older than\n     * the specified number of of milliseconds.\n     */\n    public static void closeOldConversations(Mailbox mbox, long timeoutMillis) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        long cutoff = (System.currentTimeMillis() - timeoutMillis) / 1000;\n        try {\n            String mailboxJoin = (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = open_conversation.mailbox_id\");\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(mbox) +\n                \" WHERE \" + IN_THIS_MAILBOX_AND + \"conv_id IN (\" +\n                \"  SELECT id FROM \" + getMailItemTableName(mbox, \"mi\") +\n                \"  WHERE mi.id = open_conversation.conv_id\" +\n                   mailboxJoin +\n                \"  AND date < ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups) {\n                stmt.setInt(pos++, mbox.getId());\n            }\n            ZimbraLog.purge.debug(\"Closing conversations dated before %d.\", cutoff);\n            stmt.setLong(pos++, cutoff); \n            int numRows = stmt.executeUpdate();\n            if (numRows > 0) {\n                ZimbraLog.purge.info(\"Closed %d conversations dated before %d.\", numRows, cutoff);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversations dated before \" + cutoff, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void changeOpenTarget(String hash, MailItem oldTarget, int newTargetId) throws ServiceException {\n        Mailbox mbox = oldTarget.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(oldTarget) +\n                        \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ? AND conv_id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, newTargetId);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, oldTarget.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"switching open conversation association for item \" + oldTarget.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveDate(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET date = ?, mod_metadata = ?, change_date = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveImapUid(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET imap_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, item.getImapUid());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(MailItem item, Tag tag, boolean add) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != tag.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n        if (tag.getId() == Flag.ID_FLAG_UNREAD)\n            throw ServiceException.FAILURE(\"unread state must be updated with alterUnread()\", null);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAG_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = (add ? \"NOT \" : \"\") + Db.bitmaskAND(column);\n\n            String relation;\n            if (item instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (item instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (item instanceof Folder)          relation = \"folder_id = ?\";\n            else if (item instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (item instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                      relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                    \" SET \" + primaryUpdate + updateChangeID +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND \" + relation);\n\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            if (altersModseq) {\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n            }\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setLong(pos++, tag.getBitmask());\n            if (item instanceof Tag)\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            else if (item instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            else\n                stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(item.getInternalFlagBitmask());\n            else if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).addTagset(item.getTagBitmask());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(Tag tag, List<Integer> itemIDs, boolean add)\n    throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty())\n            return;\n        Mailbox mbox = tag.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAG_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = (add ? \"NOT \" : \"\") + Db.bitmaskAND(column);\n\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                            \" SET \" + primaryUpdate + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND id IN \" + DbUtil.suitableNumberOfVariables(count));\n\n                int pos = 1;\n                stmt.setLong(pos++, tag.getBitmask());\n                if (altersModseq) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.setLong(pos++, tag.getBitmask());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, itemIDs.get(index));\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n            else if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for \" + itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void clearTag(Tag tag) throws ServiceException {\n        Mailbox mbox = tag.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                        \" SET tags = tags - ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + Db.bitmaskAND(\"tags\"));\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.executeUpdate();\n\n            if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).applyMask(tag.getTagBitmask(), false);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"clearing all references to tag \" + tag.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Sets the <code>unread</code> column for the specified <code>MailItem</code>.\n     * If the <code>MailItem</code> is a <code>Conversation</code>, <code>Tag</code>\n     * or <code>Folder</code>, sets the <code>unread</code> column for all related items.\n     */\n    public static void alterUnread(MailItem item, boolean unread)\n    throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation;\n            if (item instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (item instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (item instanceof Folder)          relation = \"folder_id = ?\";\n            else if (item instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (item instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                      relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ? AND \" + relation +\n                        \"  AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE));\n            int pos = 1;\n            stmt.setInt(pos++, unread ? 1 : 0);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, unread ? 0 : 1);\n            if (item instanceof Tag)\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            else if (item instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            else\n                stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterUnread(Mailbox mbox, List<Integer> itemIDs, boolean unread)\n    throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty())\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ?\" +\n                            \"  AND id IN \" + DbUtil.suitableNumberOfVariables(count) +\n                            \"  AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE));\n                int pos = 1;\n                stmt.setInt(pos++, unread ? 1 : 0);\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.setInt(pos++, unread ? 0 : 1);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, itemIDs.get(index));\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for \" +\n                itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all conversations affected by a folder deletion.  For all conversations\n     * that have messages in the given folder, updates their message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     * \n     * @param folder the folder that is being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Folder folder, Set<Integer> candidates) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) + \", \" +\n                            \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(folder) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                            \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.TYPE_CONVERSATION);\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.executeUpdate();\n                stmt.close();\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                stmt.setInt(pos++, folder.getId());\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    List<Integer> convIDs = update.getValue();\n                    for (int i = 0; i < convIDs.size(); i += Db.getINClauseBatchSize()) {\n                        int count = Math.min(Db.getINClauseBatchSize(), convIDs.size() - i);\n                        stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                                \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count) +\n                                \"  AND type = \" + MailItem.TYPE_CONVERSATION);\n                        pos = 1;\n                        stmt.setInt(pos++, update.getKey());\n                        stmt.setInt(pos++, mbox.getOperationChangeID());\n                        stmt.setInt(pos++, mbox.getOperationTimestamp());\n                        if (!DebugConfig.disableMailboxGroups)\n                            stmt.setInt(pos++, mbox.getId());\n                        for (int index = i; index < i + count; index++)\n                            stmt.setInt(pos++, convIDs.get(index));\n                        stmt.executeUpdate();\n                        stmt.close();\n                    }\n                }\n            }\n\n            return getPurgedConversations(mbox, candidates);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations crossing folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all affected conversations when a <code>List</code> of <code>MailItem</code>s\n     * is deleted.  Updates each conversation's message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     * \n     * @param mbox the mailbox\n     * @param ids of the items being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Mailbox mbox, List<Integer> ids, Set<Integer> candidates) throws ServiceException {\n        if (ids == null)\n            return null;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n                    int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                    stmt = conn.prepareStatement(\"UPDATE \" + table + \", \" +\n                                \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(mbox) +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count) + \"AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                                \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.TYPE_CONVERSATION);\n                    int pos = 1;\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    for (int index = i; index < i + count; index++)\n                        stmt.setInt(pos++, ids.get(index));\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(ids) + \"AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int id : ids)\n                    stmt.setInt(pos++, id);\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(update.getValue()) +\n                            \" AND type = \" + MailItem.TYPE_CONVERSATION);\n                    pos = 1;\n                    stmt.setInt(pos++, update.getKey());\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    for (int convId : update.getValue())\n                        stmt.setInt(pos++, convId);\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations touching \" +\n                ids.size() + \" items: \" + getIdListForLogging(ids), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return getPurgedConversations(mbox, candidates);\n    }\n\n    private static List<Integer> getPurgedConversations(Mailbox mbox, Set<Integer> candidates) throws ServiceException {\n        if (candidates == null || candidates.isEmpty())\n            return null;\n        List<Integer> purgedConvs = new ArrayList<Integer>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // note: be somewhat careful making changes here, as <tt>i</tt> and <tt>it</tt> operate separately\n            Iterator<Integer> it = candidates.iterator();\n            for (int i = 0; i < candidates.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), candidates.size() - i);\n                stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count) + \"AND size <= 0\");\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n                rs = stmt.executeQuery();\n\n                while (rs.next())\n                    purgedConvs.add(rs.getInt(1));\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            return purgedConvs;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting list of purged conversations\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes the specified <code>MailItem</code> from the <code>mail_item</code>\n     * table.  If the object is a <code>Folder</code> or <code>Conversation</code>,\n     * deletes any corresponding messages.  Does not delete subfolders.\n     */\n    public static void delete(MailItem item) throws ServiceException {\n        deleteContents(item);\n        if (item instanceof VirtualConversation)\n            return;\n\n        List<Integer> ids = new ArrayList<Integer>();\n        ids.add(item.getId());\n        delete(item.getMailbox(), ids);\n    }\n\n    /**\n     * Deletes <code>MailItem</code>s with the specified ids from the <code>mail_item</code>\n     * table.  Assumes that there is no data referencing the specified id's.\n     */\n    public static void delete(Mailbox mbox, List<Integer> ids) throws ServiceException {\n        // trim out any non-persisted items\n        if (ids == null || ids.size() == 0)\n            return;\n        List<Integer> targets = new ArrayList<Integer>();\n        for (int id : ids)\n            if (id > 0)\n                targets.add(id);\n        if (targets.size() == 0)\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        for (int i = 0; i < targets.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), targets.size() - i);\n                stmt = conn.prepareStatement(\"DELETE FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN\" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, targets.get(index));\n                stmt.executeUpdate();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"deleting \" + ids.size() + \" item(s): \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        }\n    }\n\n    public static void deleteContents(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        String target;\n        if (item instanceof VirtualConversation)  target = \"id = ?\";\n        else if (item instanceof Conversation)    target = \"parent_id = ?\";\n        else if (item instanceof SearchFolder)    return;\n        else if (item instanceof Folder)          target = \"folder_id = ?\";\n        else                                      return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getMailItemTableName(item) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + target + \" AND type NOT IN \" + FOLDER_TYPES);\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting contents for \" + MailItem.getNameForType(item) + \" \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void writeTombstones(Mailbox mbox, TypedIdList tombstones) throws ServiceException {\n        if (tombstones == null || tombstones.isEmpty())\n            return;\n\n        for (Map.Entry<Byte, List<Integer>> entry : tombstones) {\n            byte type = entry.getKey();\n            if (type == MailItem.TYPE_CONVERSATION || type == MailItem.TYPE_VIRTUAL_CONVERSATION)\n                continue;\n            StringBuilder ids = new StringBuilder();\n            for (Integer id : entry.getValue()) {\n                ids.append(ids.length() == 0 ? \"\" : \",\").append(id);\n\n                // catch overflows of TEXT values; since all chars are ASCII, no need to convert to UTF-8 for length check beforehand\n                if (ids.length() > MAX_TEXT_LENGTH - 50) {\n                    writeTombstone(mbox, type, ids.toString());\n                    ids.setLength(0);\n                }\n            }\n\n            writeTombstone(mbox, type, ids.toString());\n        }\n    }\n\n    private static void writeTombstone(Mailbox mbox, byte type, String ids) throws ServiceException {\n        if (ids == null || ids.equals(\"\"))\n            return;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getTombstoneTableName(mbox) +\n                        \"(\" + mailbox_id + \"sequence, date, type, ids)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setByte(pos++, type);\n            stmt.setString(pos++, ids);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing tombstones for \" + MailItem.getNameForType(type) + \"(s): \" + ids, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList readTombstones(Mailbox mbox, long lastSync) throws ServiceException {\n        TypedIdList tombstones = new TypedIdList();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT type, ids FROM \" + getTombstoneTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"sequence > ? AND ids IS NOT NULL\" +\n                        \" ORDER BY sequence\");\n            Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                byte type = rs.getByte(1);\n                String row = rs.getString(2);\n                if (row == null || row.equals(\"\"))\n                    continue;\n                for (String entry : row.split(\",\")) {\n                    try {\n                        tombstones.add(type, Integer.parseInt(entry));\n                    } catch (NumberFormatException nfe) {\n                        ZimbraLog.sync.warn(\"unparseable TOMBSTONE entry: \" + entry);\n                    }\n                }\n            }\n            return tombstones;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"reading tombstones since change: \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String FOLDER_TYPES         = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ')';\n    private static final String FOLDER_AND_TAG_TYPES = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ',' + MailItem.TYPE_TAG + ')';\n    private static final String MESSAGE_TYPES        = \"(\" + MailItem.TYPE_MESSAGE + ',' + MailItem.TYPE_CHAT + ')';\n    private static final String DOCUMENT_TYPES       = \"(\" + MailItem.TYPE_DOCUMENT + ',' + MailItem.TYPE_WIKI + ')';\n    private static final String CALENDAR_TYPES       = \"(\" + MailItem.TYPE_APPOINTMENT + ',' + MailItem.TYPE_TASK + ')';\n\n    static final String NON_SEARCHABLE_TYPES = \"(\" + MailItem.TYPE_FOLDER + ',' + MailItem.TYPE_SEARCHFOLDER + ',' + MailItem.TYPE_MOUNTPOINT + ',' + MailItem.TYPE_TAG + ',' + MailItem.TYPE_CONVERSATION + ')';\n\n    private static String typeConstraint(byte type) {\n        if (type == MailItem.TYPE_FOLDER)\n            return FOLDER_TYPES;\n        else if (type == MailItem.TYPE_MESSAGE)\n            return MESSAGE_TYPES;\n        else if (type == MailItem.TYPE_DOCUMENT)\n            return DOCUMENT_TYPES;\n        else\n            return \"(\" + type + ')';\n    }\n\n\n    public static Mailbox.MailboxData getFoldersAndTags(Mailbox mbox, Map<UnderlyingData, Long> folderData, Map<UnderlyingData, Long> tagData, boolean reload)\n    throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox, \"mi\");\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS + \" FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + FOLDER_AND_TAG_TYPES);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (MailItem.isAcceptableType(MailItem.TYPE_FOLDER, data.type))\n                    folderData.put(data, -1L);\n                else if (MailItem.isAcceptableType(MailItem.TYPE_TAG, data.type))\n                    tagData.put(data, -1L);\n\n                rs.getInt(CI_UNREAD);\n                reload |= rs.wasNull();\n            }\n            rs.close();\n\n            for (UnderlyingData data : folderData.keySet()) {\n                if (data.parentId != data.folderId) {\n                    // we had a small folder data inconsistency issue, so resolve it here\n                    //   rather than returning it up to the caller\n                    stmt.close();\n                    stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = folder_id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                    int pos = 1;\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    stmt.setInt(pos++, data.id);\n                    stmt.executeUpdate();\n\n                    data.parentId = data.folderId;\n                    ZimbraLog.mailbox.info(\"correcting PARENT_ID column for \" + MailItem.getNameForType(data.type) + \" \" + data.id);\n                }\n            }\n\n            if (!reload)\n                return null;\n\n            Map<Integer, UnderlyingData> lookup = new HashMap<Integer, UnderlyingData>(folderData.size() + tagData.size());\n\n            // going to recalculate counts, so discard any existing counts...\n            for (Map.Entry<UnderlyingData, Long> entry : folderData.entrySet()) {\n                UnderlyingData data = entry.getKey();\n                lookup.put(data.id, data);\n                data.size = data.unreadCount = 0;\n                entry.setValue(0L);\n            }\n\n            for (UnderlyingData data : tagData.keySet()) {\n                lookup.put(data.id, data);\n                data.size = data.unreadCount = 0;\n            }\n\n            rs.close();\n            stmt.close();\n\n            Mailbox.MailboxData mbd = new Mailbox.MailboxData();\n            stmt = conn.prepareStatement(\"SELECT folder_id, type, tags, COUNT(*), SUM(unread), SUM(size)\" +\n                        \" FROM \" + table + \" WHERE \" + IN_THIS_MAILBOX_AND + \"type NOT IN \" + NON_SEARCHABLE_TYPES +\n                        \" GROUP BY folder_id, type, tags\");\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                byte type  = rs.getByte(2);\n                int count  = rs.getInt(4);\n                int unread = rs.getInt(5);\n                long size  = rs.getLong(6);\n\n                if (type == MailItem.TYPE_CONTACT)\n                    mbd.contacts += count;\n                mbd.size += size;\n\n                UnderlyingData data = lookup.get(rs.getInt(1));\n                assert(data != null);\n                data.unreadCount += unread;\n                data.size += count;\n                Long folderSize = folderData.get(data);\n                folderData.put(data, folderSize == null ? size : folderSize + size);\n\n                long tags = rs.getLong(3);\n                for (int i = 0; tags != 0 && i < MailItem.MAX_TAG_COUNT - 1; i++) {\n                    if ((tags & (1L << i)) != 0) {\n                        data = lookup.get(i + MailItem.TAG_ID_OFFSET);\n                        if (data != null)\n                            data.unreadCount += unread;\n                        // could track cumulative count if desired...\n                        tags &= ~(1L << i);\n                    }\n                }\n            }\n\n            rs.close();\n            stmt.close();\n\n            stmt = conn.prepareStatement(\"SELECT mi.folder_id, SUM(rev.size)\" +\n                        \" FROM \" + table + \", \" + getRevisionTableName(mbox, \"rev\") +\n                        \" WHERE mi.id = rev.item_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND rev.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\") + \n                        \" GROUP BY folder_id\");\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = lookup.get(rs.getInt(1));\n                assert(data != null);\n                Long folderSize = folderData.get(data);\n                folderData.put(data, folderSize == null ? rs.getLong(2) : folderSize + rs.getLong(2));\n            }\n\n            return mbd;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching folder data for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByType(Mailbox mbox, byte type, SortBy sort) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(mbox, \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + typeConstraint(type) + DbSearch.sortQuery(sort));\n            if (type == MailItem.TYPE_MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next())\n                result.add(constructItem(rs));\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n\n            if (type == MailItem.TYPE_CONVERSATION)\n                completeConversations(mbox, result);\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items of type \" + type, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent) throws ServiceException {\n        return getByParent(parent, SortBy.DATE_DESCENDING);\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent, SortBy sort) throws ServiceException {\n        Mailbox mbox = parent.getMailbox();\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(parent.getMailbox(), \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ? \" + DbSearch.sortQuery(sort));\n            if (parent.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, parent.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (Mailbox.isCachedType(data.type))\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching children of item \" + parent.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getUnreadMessages(MailItem relativeTo) throws ServiceException {\n        Mailbox mbox = relativeTo.getMailbox();\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String relation;\n            if (relativeTo instanceof VirtualConversation)  relation = \"id = ?\";\n            else if (relativeTo instanceof Conversation)    relation = \"parent_id = ?\";\n            else if (relativeTo instanceof Folder)          relation = \"folder_id = ?\";\n            else if (relativeTo instanceof Flag)            relation = Db.bitmaskAND(\"flags\");\n            else if (relativeTo instanceof Tag)             relation = Db.bitmaskAND(\"tags\");\n            else                                            relation = \"id = ?\";\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(relativeTo.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread > 0 AND \" + relation + \" AND type NOT IN \" + NON_SEARCHABLE_TYPES);\n            if (relativeTo.getUnreadCount() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            if (relativeTo instanceof Tag)\n                stmt.setLong(pos++, ((Tag) relativeTo).getBitmask());\n            else if (relativeTo instanceof VirtualConversation)\n                stmt.setInt(pos++, ((VirtualConversation) relativeTo).getMessageId());\n            else\n                stmt.setInt(pos++, relativeTo.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (Mailbox.isCachedType(data.type))\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching unread messages for item \" + relativeTo.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByFolder(Folder folder, byte type, SortBy sort) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        Mailbox mbox = folder.getMailbox();\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + typeConstraint(type) +\n                        DbSearch.sortQuery(sort));\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS && type == MailItem.TYPE_MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items in folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getById(Mailbox mbox, int id, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, id);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailItem.noSuchItem(id, type);\n            UnderlyingData data = constructItem(rs);\n            if (!MailItem.isAcceptableType(type, data.type))\n                throw MailItem.noSuchItem(id, type);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + id, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByImapId(Mailbox mbox, int imapId, int folderId) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND imap_id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, imapId);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            UnderlyingData data = constructItem(rs);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + imapId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getById(Mailbox mbox, Collection<Integer> ids, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n        if (ids.isEmpty())\n            return result;\n        List<UnderlyingData> conversations = new ArrayList<UnderlyingData>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        Iterator<Integer> it = ids.iterator();\n        for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                            \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    UnderlyingData data = constructItem(rs);\n                    if (!MailItem.isAcceptableType(type, data.type))\n                        throw MailItem.noSuchItem(data.id, type);\n                    else if (Mailbox.isCachedType(data.type))\n                        throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                    if (data.type == MailItem.TYPE_CONVERSATION)\n                        conversations.add(data);\n                    result.add(data);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"fetching \" + ids.size() + \" items: \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n        }\n\n        if (!conversations.isEmpty())\n            completeConversations(mbox, conversations);\n        return result;\n    }\n\n    public static UnderlyingData getByName(Mailbox mbox, int folderId, String name, byte type) throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + typeConstraint(type) +\n                        \" AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folderId);\n            stmt.setString(pos++, name.toUpperCase());\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw MailItem.noSuchItem(-1, type);\n            UnderlyingData data = constructItem(rs);\n            if (!MailItem.isAcceptableType(type, data.type))\n                throw MailItem.noSuchItem(data.id, type);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item by name ('\" + name + \"' in folder \" + folderId + \")\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByHash(Mailbox mbox, String hash) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getConversationTableName(mbox, \"oc\") +\n                        \" WHERE oc.hash = ? AND mi.id = oc.conv_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND oc.mailbox_id = ? AND mi.mailbox_id = oc.mailbox_id\"));\n            int pos = 1;\n            stmt.setString(pos++, hash);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                return null;\n            UnderlyingData data = constructItem(rs);\n            if (data.type == MailItem.TYPE_CONVERSATION)\n                completeConversation(mbox, data);\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching conversation for hash \" + hash, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static Pair<List<Integer>,TypedIdList> getModifiedItems(Mailbox mbox, byte type, long lastSync, Set<Integer> visible)\n    throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        List<Integer> modified = new ArrayList<Integer>();\n        TypedIdList missed = new TypedIdList();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = type == MailItem.TYPE_UNKNOWN ? \"type NOT IN \" + NON_SEARCHABLE_TYPES : \"type IN \" + typeConstraint(type);\n            stmt = conn.prepareStatement(\"SELECT id, type, folder_id\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"mod_metadata > ? AND \" + typeConstraint +\n                        \" ORDER BY mod_metadata, id\");\n            if (type == MailItem.TYPE_MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                if (visible == null || visible.contains(rs.getInt(3)))\n                    modified.add(rs.getInt(1));\n                else\n                    missed.add(rs.getByte(2), rs.getInt(1));\n            }\n\n            return new Pair<List<Integer>,TypedIdList>(modified, missed);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting items modified since \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void completeConversation(Mailbox mbox, UnderlyingData data) throws ServiceException {\n        completeConversations(mbox, Arrays.asList(data));\n    }\n\n    private static void completeConversations(Mailbox mbox, List<UnderlyingData> convData) throws ServiceException {\n        if (convData == null || convData.isEmpty())\n            return;\n        for (UnderlyingData data : convData) {\n            if (data.type != MailItem.TYPE_CONVERSATION)\n                throw ServiceException.FAILURE(\"attempting to complete a non-conversation\", null);\n        }\n\n        Map<Integer, UnderlyingData> conversations = new HashMap<Integer, UnderlyingData>(Db.getINClauseBatchSize() * 3 / 2);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        for (int i = 0; i < convData.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), convData.size() - i);\n                stmt = conn.prepareStatement(\"SELECT parent_id, unread, flags, tags\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++) {\n                    UnderlyingData data = convData.get(index);\n                    stmt.setInt(pos++, data.id);\n                    conversations.put(data.id, data);\n                    // don't assume that the UnderlyingData structure was new...\n                    data.tags = data.flags = data.unreadCount = 0;\n                }\n                rs = stmt.executeQuery();\n\n                while (rs.next()) {\n                    UnderlyingData data = conversations.get(rs.getInt(1));\n                    assert(data != null);\n                    data.unreadCount += rs.getInt(2);\n                    data.flags       |= rs.getInt(3);\n                    data.tags        |= rs.getLong(4);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"completing conversation data\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n\n            conversations.clear();\n        }\n    }\n\n    private static final String LEAF_NODE_FIELDS = \"id, size, type, unread, folder_id, parent_id, blob_digest,\" +\n                                                   \" mod_content, mod_metadata, flags, index_id, volume_id\";\n\n    private static final int LEAF_CI_ID           = 1;\n    private static final int LEAF_CI_SIZE         = 2;\n    private static final int LEAF_CI_TYPE         = 3;\n    private static final int LEAF_CI_IS_UNREAD    = 4;\n    private static final int LEAF_CI_FOLDER_ID    = 5;\n    private static final int LEAF_CI_PARENT_ID    = 6;\n    private static final int LEAF_CI_BLOB_DIGEST  = 7;\n    private static final int LEAF_CI_MOD_CONTENT  = 8;\n    private static final int LEAF_CI_MOD_METADATA = 9;\n    private static final int LEAF_CI_FLAGS        = 10;\n    private static final int LEAF_CI_INDEX_ID     = 11;\n    private static final int LEAF_CI_VOLUME_ID    = 12;\n\n    public static PendingDelete getLeafNodes(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        PendingDelete info = new PendingDelete();\n        int folderId = folder.getId();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type NOT IN \" + FOLDER_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n             int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folderId);\n            rs = stmt.executeQuery();\n\n            info.rootId = folderId;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            \n            // make sure that the folder is in the list of deleted item ids\n            info.itemIds.add(folder.getType(), folderId);\n\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items within item \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static PendingDelete getLeafNodes(Mailbox mbox, List<Folder> folders, int before, boolean globalMessages,\n                                             Boolean unread, boolean useChangeDate)\n    throws ServiceException {\n        PendingDelete info = new PendingDelete();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String constraint;\n            String dateColumn = (useChangeDate ? \"change_date\" : \"date\");\n            if (globalMessages)\n                constraint = dateColumn + \" < ? AND type IN \" + typeConstraint(MailItem.TYPE_MESSAGE);\n            else\n                constraint = dateColumn + \" < ? AND type NOT IN \" + NON_SEARCHABLE_TYPES +\n                             \" AND folder_id IN\" + DbUtil.suitableNumberOfVariables(folders);\n            if (unread != null)\n                constraint += \" AND unread = ?\";\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + constraint);\n            if (globalMessages || getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, before);\n            if (!globalMessages) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            if (unread != null)\n                stmt.setBoolean(pos++, unread);\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    private static int getTotalFolderSize(Collection<Folder> folders) {\n        int totalSize = 0;\n        if (folders != null) {\n            for (Folder folder : folders) {\n                totalSize += folder.getSize();\n            }\n        }\n        return totalSize;\n    }\n\n    public static PendingDelete getImapDeleted(Mailbox mbox, Set<Folder> folders) throws ServiceException {\n        PendingDelete info = new PendingDelete();\n        if (folders != null && folders.isEmpty())\n            return info;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // figure out the set of FLAGS bitmasks containing the \\Deleted flag\n            Set<Long> flagsets = getFlagsetCache(conn, mbox).getMatchingTagsets(Flag.BITMASK_DELETED, Flag.BITMASK_DELETED);\n            if (flagsets != null && flagsets.isEmpty())\n                return info;\n\n            String flagconstraint = flagsets == null ? \"\" : \" AND flags IN\" + DbUtil.suitableNumberOfVariables(flagsets);\n            String folderconstraint = folders == null ? \"\" : \" AND folder_id IN\" + DbUtil.suitableNumberOfVariables(folders);\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + IMAP_TYPES + flagconstraint + folderconstraint);\n            if (getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            if (flagsets != null) {\n                for (long flags : flagsets)\n                    stmt.setInt(pos++, (int) flags);\n            }\n            if (folders != null) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of \\\\Deleted items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class LocationCount {\n        public int count;\n        public long size;\n        public LocationCount(int c, long sz)              { count = c;  size = sz; }\n        public LocationCount(LocationCount lc)            { count = lc.count;  size = lc.size; }\n        public LocationCount increment(int c, long sz)    { count += c;  size += sz;  return this; }\n        public LocationCount increment(LocationCount lc)  { count += lc.count;  size += lc.size;  return this; }\n    }\n\n    /**\n     * Accumulates <tt>PendingDelete</tt> info for the given <tt>ResultSet</tt>.\n     * @return a <tt>List</tt> of all versioned items, to be used in a subsequent call to\n     * {@link DbMailItem#accumulateLeafRevisions}, or an empty list.\n     */\n    private static List<Integer> accumulateLeafNodes(PendingDelete info, Mailbox mbox, ResultSet rs) throws SQLException, ServiceException {\n        StoreManager sm = StoreManager.getInstance();\n        List<Integer> versioned = new ArrayList<Integer>();\n\n        while (rs.next()) {\n            // first check to make sure we don't have a modify conflict\n            int revision = rs.getInt(LEAF_CI_MOD_CONTENT);\n            int modMetadata = rs.getInt(LEAF_CI_MOD_METADATA);\n            if (!mbox.checkItemChangeID(modMetadata, revision)) {\n                info.incomplete = true;\n                continue;\n            }\n\n            int id = rs.getInt(LEAF_CI_ID);\n            long size = rs.getLong(LEAF_CI_SIZE);\n            byte type = rs.getByte(LEAF_CI_TYPE);\n\n            Integer item = new Integer(id);\n            info.itemIds.add(type, item);\n            info.size += size;\n            \n            if (rs.getBoolean(LEAF_CI_IS_UNREAD))\n                info.unreadIds.add(item);\n\n            boolean isMessage = false;\n            switch (type) {\n                case MailItem.TYPE_CONTACT:  info.contacts++;  break;\n                case MailItem.TYPE_CHAT:\n                case MailItem.TYPE_MESSAGE:  isMessage = true;    break;\n            }\n\n            // record deleted virtual conversations and modified-or-deleted real conversations\n            if (isMessage) {\n                int parentId = rs.getInt(LEAF_CI_PARENT_ID);\n                if (rs.wasNull() || parentId <= 0)\n                    info.itemIds.add(MailItem.TYPE_VIRTUAL_CONVERSATION, -id);\n                else\n                    info.modifiedIds.add(parentId);\n            }\n\n            Integer folderId = rs.getInt(LEAF_CI_FOLDER_ID);\n            LocationCount count = info.messages.get(folderId);\n            if (count == null)\n                info.messages.put(folderId, new LocationCount(1, size));\n            else\n                count.increment(1, size);\n\n            String blobDigest = rs.getString(LEAF_CI_BLOB_DIGEST);\n            if (blobDigest != null) {\n                info.blobDigests.add(blobDigest);\n                short volumeId = rs.getShort(LEAF_CI_VOLUME_ID);\n                try {\n                    MailboxBlob mblob = sm.getMailboxBlob(mbox, id, revision, volumeId);\n                    if (mblob == null)\n                        sLog.warn(\"missing blob for id: \" + id + \", change: \" + revision);\n                    else\n                        info.blobs.add(mblob);\n                } catch (Exception e1) { }\n            }\n\n            int flags = rs.getInt(LEAF_CI_FLAGS);\n            if ((flags & Flag.BITMASK_VERSIONED) != 0) {\n                versioned.add(id);\n            }\n\n            String indexId = rs.getString(LEAF_CI_INDEX_ID);\n            boolean indexed = !rs.wasNull();\n            if (indexed) {\n                if (info.sharedIndex == null)\n                    info.sharedIndex = new HashSet<String>();\n                boolean shared = (flags & Flag.BITMASK_COPIED) != 0;\n                if (!shared)  info.indexIds.add(indexId);\n                else          info.sharedIndex.add(indexId);\n            }\n        }\n        return versioned;\n    }\n\n    private static void accumulateLeafRevisions(PendingDelete info, Mailbox mbox, List<Integer> versioned) throws ServiceException {\n        if (versioned == null || versioned.size() == 0) {\n            return;\n        }\n        Connection conn = mbox.getOperationConnection();\n        StoreManager sm = StoreManager.getInstance();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.id, mi.folder_id, rev.size, rev.mod_content, rev.volume_id, rev.blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getRevisionTableName(mbox, \"rev\") +\n                    \" WHERE mi.id = rev.item_id AND mi.id IN \" + DbUtil.suitableNumberOfVariables(versioned) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\"));\n            int pos = 1;\n            for (int vid : versioned)\n                stmt.setInt(pos++, vid);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                Integer folderId = rs.getInt(2);\n                LocationCount count = info.messages.get(folderId);\n                if (count == null)\n                    info.messages.put(folderId, new LocationCount(0, rs.getLong(3)));\n                else\n                    count.increment(0, rs.getLong(3));\n\n                String blobDigest = rs.getString(6);\n                if (blobDigest != null) {\n                    info.blobDigests.add(blobDigest);\n                    try {\n                        MailboxBlob mblob = sm.getMailboxBlob(mbox, rs.getInt(1), rs.getInt(4), rs.getShort(5));\n                        if (mblob == null)\n                            sLog.error(\"missing blob for id: \" + rs.getInt(1) + \", change: \" + rs.getInt(4));\n                        else\n                            info.blobs.add(mblob);\n                    } catch (Exception e1) { }\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting version deletion info for items: \" + versioned, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Returns the blob digest for the item with the given id, or <tt>null</tt>\n     * if either the id doesn't exist in the table or there is no associated blob.\n     */\n    public static String getBlobDigest(Mailbox mbox, int itemId) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, itemId);\n            rs = stmt.executeQuery();\n\n            return rs.next() ? rs.getString(1) : null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"unable to get blob digest for id \" + itemId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void resolveSharedIndex(Mailbox mbox, PendingDelete info) throws ServiceException {\n        if (info.sharedIndex == null || info.sharedIndex.isEmpty())\n            return;\n        List<String> indexIDs = new ArrayList<String>(info.sharedIndex);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            for (int i = 0; i < indexIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), indexIDs.size() - i);\n                stmt = conn.prepareStatement(\"SELECT index_id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"index_id IN \" + DbUtil.suitableNumberOfVariables(count));\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setInt(pos++, mbox.getId());\n                for (int index = i; index < i + count; index++)\n                    stmt.setString(pos++, indexIDs.get(index));\n                rs = stmt.executeQuery();\n                while (rs.next())\n                    info.sharedIndex.remove(rs.getInt(1));\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            info.indexIds.addAll(info.sharedIndex);\n            info.sharedIndex.clear();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"resolving shared index entries: \" + info.rootId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String IMAP_FIELDS = \"mi.id, mi.type, mi.imap_id, mi.unread, mi.flags, mi.tags\";\n    private static final String IMAP_TYPES = \"(\" + MailItem.TYPE_MESSAGE + \",\" + MailItem.TYPE_CHAT + ',' + MailItem.TYPE_CONTACT + \")\";\n\n    public static List<ImapMessage> loadImapFolder(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        List<ImapMessage> result = new ArrayList<ImapMessage>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + IMAP_FIELDS +\n                        \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                int flags = rs.getBoolean(4) ? Flag.BITMASK_UNREAD | rs.getInt(5) : rs.getInt(5);\n                result.add(new ImapMessage(rs.getInt(1), rs.getByte(2), rs.getInt(3), flags, rs.getLong(6)));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading IMAP folder data: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static int countImapRecent(Folder folder, int uidCutoff) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(folder.getMailbox()) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES +\n                        \" AND (imap_id IS NULL OR imap_id = 0 OR imap_id > ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folder.getId());\n            stmt.setInt(pos++, uidCutoff);\n            rs = stmt.executeQuery();\n\n            return (rs.next() ? rs.getInt(1) : 0);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"counting IMAP \\\\Recent messages: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String POP3_FIELDS = \"mi.id, mi.size, mi.blob_digest\";\n    private static final String POP3_TYPES = \"(\" + MailItem.TYPE_MESSAGE + \")\";\n\n    public static List<Pop3Message> loadPop3Folder(Folder folder, Date popSince) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        long popDate = popSince == null ? -1 : Math.max(popSince.getTime(), -1);\n        List<Pop3Message> result = new ArrayList<Pop3Message>();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String dateConstraint = popDate < 0 ? \"\" : \" AND date > ?\";\n            stmt = conn.prepareStatement(\"SELECT \" + POP3_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + POP3_TYPES +\n                        \" AND NOT \" + Db.bitmaskAND(\"flags\", Flag.BITMASK_DELETED) + dateConstraint);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folder.getId());\n            if (popDate >= 0)\n                stmt.setInt(pos++, (int) (popDate / 1000L));\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(new Pop3Message(rs.getInt(1), rs.getLong(2), rs.getString(3)));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading POP3 folder data: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getRevisionInfo(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        List<UnderlyingData> dlist = new ArrayList<UnderlyingData>();\n        if (!item.isTagged(Flag.ID_FLAG_VERSIONED))\n            return dlist;\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + REVISION_FIELDS + \" FROM \" + getRevisionTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ?\" +\n                        \" ORDER BY version\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                dlist.add(constructRevision(rs, item));\n            return dlist;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting old revisions for item: \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<Integer> listByFolder(Folder folder, byte type, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        Connection conn = mbox.getOperationConnection();\n        boolean allTypes = type == MailItem.TYPE_UNKNOWN;\n\n        List<Integer> result = new ArrayList<Integer>();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            if (type == MailItem.TYPE_MESSAGE && folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            if (!allTypes)\n                stmt.setByte(pos++, type);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList listByFolder(Folder folder, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        Connection conn = mbox.getOperationConnection();\n\n        TypedIdList result = new TypedIdList();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT id, type FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getByte(2), rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    // these columns are specified by DB_FIELDS, below\n    public static final int CI_ID          = 1;\n    public static final int CI_TYPE        = 2;\n    public static final int CI_PARENT_ID   = 3;\n    public static final int CI_FOLDER_ID   = 4;\n    public static final int CI_INDEX_ID    = 5;\n    public static final int CI_IMAP_ID     = 6;\n    public static final int CI_DATE        = 7;\n    public static final int CI_SIZE        = 8;\n    public static final int CI_VOLUME_ID   = 9;\n    public static final int CI_BLOB_DIGEST = 10;\n    public static final int CI_UNREAD      = 11;\n    public static final int CI_FLAGS       = 12;\n    public static final int CI_TAGS        = 13;\n//  public static final int CI_SENDER      = 14;\n    public static final int CI_SUBJECT     = 14;\n    public static final int CI_NAME        = 15;\n    public static final int CI_METADATA    = 16;\n    public static final int CI_MODIFIED    = 17;\n    public static final int CI_MODIFY_DATE = 18;\n    public static final int CI_SAVED       = 19;\n\n    static final String DB_FIELDS = \"mi.id, mi.type, mi.parent_id, mi.folder_id, mi.index_id, \" +\n                                    \"mi.imap_id, mi.date, mi.size, mi.volume_id, mi.blob_digest, \" +\n                                    \"mi.unread, mi.flags, mi.tags, mi.subject, mi.name, \" +\n                                    \"mi.metadata, mi.mod_metadata, mi.change_date, mi.mod_content\";\n    \n\n    private static UnderlyingData constructItem(ResultSet rs) throws SQLException {\n        return constructItem(rs, 0);\n    }\n    static UnderlyingData constructItem(ResultSet rs, int offset) throws SQLException {\n        UnderlyingData data = new UnderlyingData();\n        data.id          = rs.getInt(CI_ID + offset);\n        data.type        = rs.getByte(CI_TYPE + offset);\n        data.parentId    = rs.getInt(CI_PARENT_ID + offset);\n        data.folderId    = rs.getInt(CI_FOLDER_ID + offset);\n        data.indexId     = rs.getString(CI_INDEX_ID + offset);\n        if (rs.wasNull())\n            data.indexId = null;\n        data.imapId      = rs.getInt(CI_IMAP_ID + offset);\n        if (rs.wasNull())\n            data.imapId = -1;\n        data.date        = rs.getInt(CI_DATE + offset);\n        data.size        = rs.getLong(CI_SIZE + offset);\n        data.volumeId    = rs.getShort(CI_VOLUME_ID + offset);\n        if (rs.wasNull())\n            data.volumeId = -1;\n        data.setBlobDigest(rs.getString(CI_BLOB_DIGEST + offset));\n        data.unreadCount = rs.getInt(CI_UNREAD + offset);\n        data.flags       = rs.getInt(CI_FLAGS + offset);\n        data.tags        = rs.getLong(CI_TAGS + offset);\n        data.subject     = rs.getString(CI_SUBJECT + offset);\n        data.name        = rs.getString(CI_NAME + offset);\n        data.metadata    = rs.getString(CI_METADATA + offset);\n        data.modMetadata = rs.getInt(CI_MODIFIED + offset);\n        data.modContent  = rs.getInt(CI_SAVED + offset);\n        data.dateChanged = rs.getInt(CI_MODIFY_DATE + offset);\n        // make sure to handle NULL column values\n        if (data.parentId == 0)     data.parentId = -1;\n        if (data.dateChanged == 0)  data.dateChanged = -1;\n        return data;\n    }\n\n    private static final String REVISION_FIELDS = \"date, size, volume_id, blob_digest, name, \" +\n                                                  \"metadata, mod_metadata, change_date, mod_content\";\n\n    private static UnderlyingData constructRevision(ResultSet rs, MailItem item) throws SQLException {\n        UnderlyingData data = new UnderlyingData();\n        data.id          = item.getId();\n        data.type        = item.getType();\n        data.parentId    = item.getParentId();\n        data.folderId    = item.getFolderId();\n        data.indexId     = null;\n        data.imapId      = -1;\n        data.date        = rs.getInt(1);\n        data.size        = rs.getLong(2);\n        data.volumeId    = rs.getShort(3);\n        if (rs.wasNull())\n            data.volumeId = -1;\n        data.setBlobDigest(rs.getString(4));\n        data.unreadCount = item.getUnreadCount();\n        data.flags       = item.getInternalFlagBitmask() | Flag.BITMASK_UNCACHED;\n        data.tags        = item.getTagBitmask();\n        data.subject     = item.getSubject();\n        data.name        = rs.getString(5);\n        data.metadata    = rs.getString(6);\n        data.modMetadata = rs.getInt(7);\n        data.dateChanged = rs.getInt(8);\n        data.modContent  = rs.getInt(9);\n        // make sure to handle NULL column values\n        if (data.parentId <= 0)     data.parentId = -1;\n        if (data.dateChanged == 0)  data.dateChanged = -1;\n        return data;\n    }\n\n    //////////////////////////////////////\n    // CALENDAR STUFF BELOW HERE!\n    //////////////////////////////////////\n\n    public static UnderlyingData getCalendarItem(Mailbox mbox, String uid) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE ci.uid = ? AND mi.id = ci.item_id AND mi.type IN \" + CALENDAR_TYPES +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\"));\n\n            int pos = 1;\n            stmt.setString(pos++, uid);\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            rs = stmt.executeQuery();\n\n            if (rs.next())\n                return constructItem(rs);\n            return null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Return all of the Invite records within the range start&lt;=Invites&lt;end.  IE \"Give me all the \n     * invites between 7:00 and 9:00\" will return you everything from 7:00 to 8:59:59.99\n     * @param start\n     * @param end\n     * @param folderId \n     * @return list of invites\n     */\n    public static List<UnderlyingData> getCalendarItems(Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds) \n    throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, DB_FIELDS, mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList listCalendarItems(Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds) \n    throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, \"mi.id, mi.type\", mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            TypedIdList result = new TypedIdList();\n            while (rs.next())\n                result.add(rs.getByte(2), rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"listing calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static PreparedStatement calendarItemStatement(Connection conn, String fields,\n            Mailbox mbox, byte type, long start, long end, int folderId, int[] excludeFolderIds)\n    throws SQLException {\n        boolean folderSpecified = folderId != Mailbox.ID_AUTO_INCREMENT;\n\n        String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n        String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n        String typeList = (type == MailItem.TYPE_UNKNOWN ? CALENDAR_TYPES : typeConstraint(type));\n\n        String excludeFolderPart = \"\";\n        if (excludeFolderIds != null && excludeFolderIds.length > 0) \n            excludeFolderPart = \" AND folder_id NOT IN\" + DbUtil.suitableNumberOfVariables(excludeFolderIds);\n\n        PreparedStatement stmt = conn.prepareStatement(\"SELECT \" + fields +\n                    \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE mi.id = ci.item_id\" + endConstraint + startConstraint + \" AND mi.type IN \" + typeList +\n                    (DebugConfig.disableMailboxGroups? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\") +\n                    (folderSpecified ? \" AND folder_id = ?\" : \"\") + excludeFolderPart);\n\n        int param = 1;\n        if (end > 0)\n            stmt.setTimestamp(param++, new Timestamp(end));\n        if (start > 0)\n            stmt.setTimestamp(param++, new Timestamp(start));\n        if (!DebugConfig.disableMailboxGroups)\n            stmt.setInt(param++, mbox.getId());\n        if (folderSpecified)\n            stmt.setInt(param++, folderId);\n        if (excludeFolderIds != null) {\n            for (int id : excludeFolderIds)\n                stmt.setInt(param++, id);\n        }\n\n        return stmt;\n    }\n\n    public static List<Integer> getItemListByDates(Mailbox mbox, byte type, long start, long end, int folderId, boolean descending) throws ServiceException {\n        Connection conn = mbox.getOperationConnection();\n        boolean allTypes = type == MailItem.TYPE_UNKNOWN;\n\n        List<Integer> result = new ArrayList<Integer>();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n                String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" AND date > ? AND date < ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            stmt.setInt(pos++, mbox.getId());\n            if (!allTypes)\n                stmt.setByte(pos++, type);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, (int)(start / 1000));\n            stmt.setInt(pos++, (int)(end / 1000));\n\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"finding items between dates\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void addToCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?, ?, ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing invite to calendar item table: UID=\" + calItem.getUid(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static long MAX_DATE = new GregorianCalendar(9999, 1, 1).getTimeInMillis();\n\n    public static void updateInCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getCalendarItemTableName(mbox) +\n                            \" SET item_id = ?, start_time = ?, end_time = ? WHERE \" + IN_THIS_MAILBOX_AND + \"uid = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, calItem.getId());\n                    stmt.setTimestamp(pos++, startTs);\n                    stmt.setTimestamp(pos++, endTs);\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setInt(pos++, mbox.getId());\n                    stmt.setString(pos++, calItem.getUid());\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating data in calendar item table \" + calItem.getUid(), nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing invite to calendar item table \" + calItem.getUid(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<CalendarItem.CalendarMetadata> getCalendarItemMetadata(Folder folder, long start, long end) throws ServiceException {\n    \tMailbox mbox = folder.getMailbox();\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        ArrayList<CalendarItem.CalendarMetadata> result = new ArrayList<CalendarItem.CalendarMetadata>();\n        try {\n            String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n            String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n            String folderConstraint = \" AND mi.folder_id = ?\";\n            stmt = conn.prepareStatement(\"SELECT mi.mailbox_id, mi.id, ci.uid, mi.mod_metadata, mi.mod_content, ci.start_time, ci.end_time\" + \n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getCalendarItemTableName(mbox, \"ci\") +\n                        \" WHERE mi.mailbox_id = ci.mailbox_id AND mi.id = ci.item_id\" + \n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? \") +\n                        startConstraint + endConstraint + folderConstraint);\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            if (start > 0)\n                stmt.setTimestamp(pos++, new Timestamp(start));\n            if (end > 0)\n                stmt.setTimestamp(pos++, new Timestamp(end));\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n            \tresult.add(new CalendarItem.CalendarMetadata(\n            \t\t\trs.getInt(1),\n            \t\t\trs.getInt(2),\n            \t\t\trs.getString(3),\n            \t\t\trs.getInt(4),\n            \t\t\trs.getInt(5),\n            \t\t\trs.getTimestamp(6).getTime(),\n            \t\t\trs.getTimestamp(7).getTime()));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching CalendarItem Metadata for mbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n        return result;\n    }\n\n    public static void consistencyCheck(MailItem item, UnderlyingData data, String metadata) throws ServiceException {\n        if (item.getId() <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.sender, \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setInt(pos++, mbox.getId());\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                throw ServiceException.FAILURE(\"consistency check failed: \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" not found in DB\", null);\n\n            UnderlyingData dbdata = constructItem(rs, 1);\n            String dbsender = rs.getString(1);\n\n            String dataBlobDigest = data.getBlobDigest(), dbdataBlobDigest = dbdata.getBlobDigest();\n            String dataSender = item.getSortSender(), dbdataSender = dbsender == null ? \"\" : dbsender;\n            String failures = \"\";\n\n            if (data.id != dbdata.id)                    failures += \" ID\";\n            if (data.type != dbdata.type)                failures += \" TYPE\";\n            if (data.folderId != dbdata.folderId)        failures += \" FOLDER_ID\";\n            if (data.indexId != dbdata.indexId)          failures += \" INDEX_ID\";\n            if (data.imapId != dbdata.imapId)            failures += \" IMAP_ID\";\n            if (data.volumeId != dbdata.volumeId)        failures += \" VOLUME_ID\";\n            if (data.date != dbdata.date)                failures += \" DATE\";\n            if (data.size != dbdata.size)                failures += \" SIZE\";\n            if (dbdata.type != MailItem.TYPE_CONVERSATION) {\n                if (data.unreadCount != dbdata.unreadCount)  failures += \" UNREAD\";\n                if (data.flags != dbdata.flags)              failures += \" FLAGS\";\n                if (data.tags != dbdata.tags)                failures += \" TAGS\";\n            }\n            if (data.modMetadata != dbdata.modMetadata)  failures += \" MOD_METADATA\";\n            if (data.dateChanged != dbdata.dateChanged)  failures += \" CHANGE_DATE\";\n            if (data.modContent != dbdata.modContent)    failures += \" MOD_CONTENT\";\n            if (Math.max(data.parentId, -1) != dbdata.parentId)  failures += \" PARENT_ID\";\n            if (dataBlobDigest != dbdataBlobDigest && (dataBlobDigest == null || !dataBlobDigest.equals(dbdataBlobDigest)))  failures += \" BLOB_DIGEST\";\n            if (dataSender != dbdataSender && (dataSender == null || !dataSender.equalsIgnoreCase(dbdataSender)))  failures += \" SENDER\";\n            if (data.subject != dbdata.subject && (data.subject == null || !data.subject.equals(dbdata.subject)))  failures += \" SUBJECT\";\n            if (data.name != dbdata.name && (data.name == null || !data.name.equals(dbdata.name)))                 failures += \" NAME\";\n            if (metadata != dbdata.metadata && (metadata == null || !metadata.equals(dbdata.metadata)))            failures += \" METADATA\";\n\n            if (item instanceof Folder && dbdata.folderId != dbdata.parentId)  failures += \" FOLDER!=PARENT\";\n\n            if (!failures.equals(\"\"))\n                throw ServiceException.FAILURE(\"consistency check failed: \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" differs from DB at\" + failures, null);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL VARCHAR(128) column (128 characters) by truncating the string\n     *  if necessary.\n     * \n     * @param sender  The string to check (can be null).\n     * @return The passed-in String, truncated to 128 chars. */\n    public static String checkSenderLength(String sender) {\n        if (sender == null || sender.length() <= MAX_SENDER_LENGTH)\n            return sender;\n        return sender.substring(0, MAX_SENDER_LENGTH);\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL VARCHAR(1024) column (1024 characters).\n     * \n     * @param subject  The string to check (can be null).\n     * @return The passed-in String.\n     * @throws ServiceException <code>service.FAILURE</code> if the\n     *         parameter would be silently truncated when inserted. */\n    public static String checkSubjectLength(String subject) throws ServiceException {\n        if (subject == null || subject.length() <= MAX_SUBJECT_LENGTH)\n            return subject;\n        throw ServiceException.FAILURE(\"subject too long\", null);\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL MEDIUMTEXT column (16,777,216 bytes) after conversion to UTF-8.\n     * \n     * @param metadata  The string to check (can be null).\n     * @return The passed-in String.\n     * @throws ServiceException <code>service.FAILURE</code> if the\n     *         parameter would be silently truncated when inserted. */\n    public static String checkMetadataLength(String metadata) throws ServiceException {\n        if (metadata == null)\n            return null;\n        int len = metadata.length();\n        if (len > MAX_MEDIUMTEXT_LENGTH / 4) {  // every char uses 4 bytes in worst case\n            if (StringUtil.isAsciiString(metadata)) {\n                if (len > MAX_MEDIUMTEXT_LENGTH)\n                    throw ServiceException.FAILURE(\"metadata too long\", null);\n            } else {\n                try {\n                    if (metadata.getBytes(\"utf-8\").length > MAX_MEDIUMTEXT_LENGTH)\n                        throw ServiceException.FAILURE(\"metadata too long\", null);\n                } catch (UnsupportedEncodingException uee) { }\n            }\n        }\n        return metadata;\n    }\n\n    /**\n     * Returns the name of the table that stores {@link MailItem} data.  The table name is qualified\n     * by the name of the database (e.g. <tt>mailbox1.mail_item</tt>).\n     */\n    public static String getMailItemTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_MAIL_ITEM);\n    }\n    public static String getMailItemTableName(Mailbox mbox, String alias) {\n        return getMailItemTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on old revisions of {@link MailItem}s.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.mail_item</tt>).\n     */\n    public static String getRevisionTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_REVISION);\n    }\n    public static String getRevisionTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_REVISION);\n    }\n    public static String getRevisionTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_REVISION);\n    }\n    public static String getRevisionTableName(Mailbox mbox, String alias) {\n        return getRevisionTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores {@link CalendarItem} data.  The table name is qualified\n     * by the name of the database (e.g. <tt>mailbox1.appointment</tt>).\n     */\n    public static String getCalendarItemTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_APPOINTMENT);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_APPOINTMENT);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox, String alias) {\n        return getCalendarItemTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that maps subject hashes to {@link Conversation} ids.  The table \n     * name is qualified by the name of the database (e.g. <tt>mailbox1.open_conversation</tt>).\n     */\n    public static String getConversationTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox, String alias) {\n        return getConversationTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on deleted items for the purpose of sync.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.tombstone</tt>).\n     */\n    public static String getTombstoneTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_TOMBSTONE);\n    }\n    public static String getTombstoneTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_TOMBSTONE);\n    }\n\n\n    private static boolean areTagsetsLoaded(Mailbox mbox) {\n        synchronized (sTagsetCache) {\n            return sTagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getTagsetCache(Connection conn, Mailbox mbox) throws ServiceException {\n        int mailboxId = mbox.getId();\n        Integer id = new Integer(mailboxId);\n        TagsetCache tagsets = null;\n\n        synchronized (sTagsetCache) {\n            tagsets = sTagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the tagset cache for a single mailbox outside the\n        // synchronized block.\n        if (tagsets == null) {\n            ZimbraLog.cache.info(\"Loading tagset cache\");\n            tagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" tags\");\n            tagsets.addTagsets(DbMailbox.getDistinctTagsets(conn, mbox));\n\n            synchronized (sTagsetCache) {\n                sTagsetCache.put(id, tagsets);\n            }\n        }\n\n        return tagsets;\n    }\n\n    private static boolean areFlagsetsLoaded(Mailbox mbox) {\n        synchronized(sFlagsetCache) {\n            return sFlagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getFlagsetCache(Connection conn, Mailbox mbox) throws ServiceException {\n        int mailboxId = mbox.getId();\n        Integer id = new Integer(mailboxId);\n        TagsetCache flagsets = null;\n\n        synchronized (sFlagsetCache) {\n            flagsets = sFlagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the flagset cache for a single mailbox outside the\n        // synchronized block.\n        if (flagsets == null) {\n            ZimbraLog.cache.info(\"Loading flagset cache\");\n            flagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" flags\");\n            flagsets.addTagsets(DbMailbox.getDistinctFlagsets(conn, mbox));\n\n            synchronized (sFlagsetCache) {\n                sFlagsetCache.put(id, flagsets);\n            }\n        }\n\n        return flagsets;\n    }\n    \n    /**\n     * Returns a comma-separated list of ids for logging.  If the <tt>String</tt> is\n     * more than 200 characters long, cuts off the list and appends &quot...&quot.\n     */\n    private static String getIdListForLogging(Collection<Integer> ids) {\n        if (ids == null) {\n            return null;\n        }\n        StringBuilder idList = new StringBuilder();\n        boolean firstTime = true;\n        for (Integer id : ids) {\n            if (firstTime) {\n                firstTime = false;\n            } else {\n                idList.append(',');\n            }\n            idList.append(id);\n            if (idList.length() > 200) {\n                idList.append(\"...\");\n                break;\n            }\n        }\n        return idList.toString();\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "d679a9a78b98b3eed2b7b13d2c34c0e3a0b60f27",
    "commit_msg": "(split)bug: 37476\n\nEnclose all database accesses with appropriate synchronization blocks to avoid conflicts in the case where the underlying database does not support row-level locking.  In the case where the database *does* have this support (i.e. everything but SQLite), we're synchronizing on a new Object, which shouldn't slow things down too much.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=37476\n\nCopied from Perforce\n Change: 161770",
    "original_file": "DbMailItem.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 18,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.cs.db;\n\nimport java.io.UnsupportedEncodingException;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.apache.commons.codec.DecoderException;\nimport org.apache.commons.codec.EncoderException;\nimport org.apache.commons.codec.net.BCodec;\n\nimport com.google.common.base.Strings;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.SetMultimap;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.Constants;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.LogFactory;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.TimeoutMap;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.CalendarItem;\nimport com.zimbra.cs.mailbox.Conversation;\nimport com.zimbra.cs.mailbox.Document;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.Message;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.cs.mailbox.Note;\nimport com.zimbra.cs.mailbox.SearchFolder;\nimport com.zimbra.cs.mailbox.Tag;\nimport com.zimbra.cs.mailbox.VirtualConversation;\nimport com.zimbra.cs.mailbox.MailItem.PendingDelete;\nimport com.zimbra.cs.mailbox.MailItem.UnderlyingData;\nimport com.zimbra.cs.mailbox.util.TypedIdList;\nimport com.zimbra.cs.pop3.Pop3Message;\nimport com.zimbra.cs.store.MailboxBlob;\nimport com.zimbra.cs.store.StoreManager;\n\n/**\n * DAO for MAIL_ITEM table.\n *\n * @since Aug 13, 2004\n */\npublic class DbMailItem {\n\n    public static final String TABLE_MAIL_ITEM = \"mail_item\";\n    public static final String TABLE_MAIL_ITEM_DUMPSTER = \"mail_item_dumpster\";\n    public static final String TABLE_REVISION = \"revision\";\n    public static final String TABLE_REVISION_DUMPSTER = \"revision_dumpster\";\n    public static final String TABLE_APPOINTMENT = \"appointment\";\n    public static final String TABLE_APPOINTMENT_DUMPSTER = \"appointment_dumpster\";\n    public static final String TABLE_OPEN_CONVERSATION = \"open_conversation\";\n    public static final String TABLE_TOMBSTONE = \"tombstone\";\n\n    private static Log sLog = LogFactory.getLog(DbMailItem.class);\n\n    /** Maps the mailbox id to the set of all tag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by tag. */\n    private static final Map<Integer, TagsetCache> sTagsetCache =\n        new TimeoutMap<Integer, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    /** Maps the mailbox id to the set of all flag combinations stored for all\n     *  items in the mailbox.  Enables fast database lookup by flag. */\n    private static final Map<Integer, TagsetCache> sFlagsetCache =\n        new TimeoutMap<Integer, TagsetCache>(120 * Constants.MILLIS_PER_MINUTE);\n\n    public static final int MAX_SENDER_LENGTH  = 128;\n    public static final int MAX_RECIPIENTS_LENGTH = 128;\n    public static final int MAX_SUBJECT_LENGTH = 1024;\n    public static final int MAX_TEXT_LENGTH    = 65534;\n    public static final int MAX_MEDIUMTEXT_LENGTH = 16777216;\n\n    public static final String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id = ? AND \";\n    public static final String MAILBOX_ID = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n    public static final String MAILBOX_ID_VALUE = DebugConfig.disableMailboxGroups ? \"\" : \"?, \";\n\n    private static final int RESULTS_STREAMING_MIN_ROWS = 10000;\n\n    public static final int setMailboxId(PreparedStatement stmt, Mailbox mbox, int pos) throws SQLException {\n        if (!DebugConfig.disableMailboxGroups) {\n            stmt.setInt(pos++, mbox.getId());\n        }\n        return pos;\n    }\n\n    public static final String getInThisMailboxAnd(int mboxId, String miAlias, String apAlias) {\n        if (DebugConfig.disableMailboxGroups)\n            return \"\";\n\n        StringBuilder sb = new StringBuilder(miAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        if (apAlias != null) {\n            sb.append(apAlias).append(\".mailbox_id = \").append(mboxId).append(\" AND \");\n        }\n        return sb.toString();\n    }\n\n\n    public void create(UnderlyingData data) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mailbox));\n        if (data.id <= 0 || data.folderId <= 0 || data.parentId == 0) {\n            throw ServiceException.FAILURE(\"invalid data for DB item create\", null);\n        }\n        checkNamingConstraint(mailbox, data.folderId, data.name, data.id);\n\n        DbConnection conn = mailbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getMailItemTableName(mailbox) + \"(\" + mailbox_id +\n                    \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest, unread,\" +\n                    \" flags, tags, sender, sender_id, recipients, subject, name, metadata, mod_metadata, change_date,\" +\n                    \" mod_content) VALUES (\" + MAILBOX_ID_VALUE +\n                    \"?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mailbox, pos);\n            stmt.setInt(pos++, data.id);\n            stmt.setByte(pos++, data.type);\n            if (data.parentId <= 0) {\n                // Messages in virtual conversations are stored with a null parent_id\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, data.parentId);\n            }\n            stmt.setInt(pos++, data.folderId);\n            if (data.indexId == MailItem.IndexStatus.NO.id()) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, data.indexId);\n            }\n            if (data.imapId <= 0) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, data.imapId);\n            }\n            stmt.setInt(pos++, data.date);\n            stmt.setLong(pos++, data.size);\n            if (data.locator != null) {\n                stmt.setString(pos++, data.locator);\n            } else {\n                stmt.setNull(pos++, Types.VARCHAR);\n            }\n            stmt.setString(pos++, data.getBlobDigest());\n            switch (MailItem.Type.of(data.type)) {\n                case MESSAGE:\n                case CHAT:\n                case FOLDER:\n                    stmt.setInt(pos++, data.unreadCount);\n                    break;\n                default:\n                    stmt.setNull(pos++, Types.INTEGER);\n                    break;\n            }\n            stmt.setInt(pos++, data.getFlags());\n            stmt.setLong(pos++, data.tags);\n            stmt.setString(pos++, sender);\n            if (senderId >= 0) {\n                stmt.setInt(pos++, senderId);\n            } else {\n                stmt.setNull(pos++, Types.INTEGER);\n            }\n            stmt.setString(pos++, recipients);\n            stmt.setString(pos++, data.getSubject());\n            stmt.setString(pos++, data.name);\n            stmt.setString(pos++, checkMetadataLength(data.metadata));\n            stmt.setInt(pos++, data.modMetadata);\n            if (data.dateChanged > 0) {\n                stmt.setInt(pos++, data.dateChanged);\n            } else {\n                stmt.setNull(pos++, Types.INTEGER);\n            }\n            stmt.setInt(pos++, data.modContent);\n            int num = stmt.executeUpdate();\n            if (num != 1) {\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n            }\n\n            // Track the tags and flags for fast lookup later\n            if (areTagsetsLoaded(mailbox)) {\n                getTagsetCache(conn, mailbox).addTagset(data.tags);\n            }\n            if (areFlagsetsLoaded(mailbox)) {\n                getFlagsetCache(conn, mailbox).addTagset(data.getFlags());\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            } else {\n                throw ServiceException.FAILURE(\"Failed to create id=\" + data.id + \",type=\" + data.type, e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static void checkNamingConstraint(Mailbox mbox, int folderId, String name, int modifiedItemId) throws ServiceException {\n        if (name == null || name.equals(\"\"))\n            return;\n        if (Db.supports(Db.Capability.UNIQUE_NAME_INDEX) && !Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON))\n            return;\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND id <> ? AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, modifiedItemId);\n            stmt.setString(pos++, StringUtil.trimTrailingSpaces(name));\n            rs = stmt.executeQuery();\n            if (!rs.next() || rs.getInt(1) > 0)\n                throw MailServiceException.ALREADY_EXISTS(name);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"checking for naming conflicts\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void copy(MailItem item, int id, Folder folder, int indexId, int parentId, String locator, String metadata, boolean fromDumpster)\n    throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (id <= 0 || folder == null || parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), id);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String srcTable = getMailItemTableName(mbox, fromDumpster);\n            String destTable = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + destTable +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + MAILBOX_ID_VALUE +\n                        \" ?, type, ?, ?, ?, ?, date, size, ?, blob_digest, unread,\" +\n                        \" flags, tags, sender, subject, name, ?, ?, ?, ? FROM \" + srcTable +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, id);                            // ID\n            if (parentId <= 0)\n                stmt.setNull(pos++, Types.INTEGER);            // PARENT_ID null for messages in virtual convs\n            else\n                stmt.setInt(pos++, parentId);                  //   or, PARENT_ID specified by caller\n            stmt.setInt(pos++, folder.getId());                // FOLDER_ID\n            if (indexId == MailItem.IndexStatus.NO.id()) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, indexId);\n            }\n            stmt.setInt(pos++, id);                            // IMAP_ID is initially the same as ID\n            if (locator != null)\n                stmt.setString(pos++, locator);      // VOLUME_ID specified by caller\n            else\n                stmt.setNull(pos++, Types.VARCHAR);            //   or, no VOLUME_ID\n            stmt.setString(pos++, checkMetadataLength(metadata));  // METADATA\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(id, e);\n            } else {\n                throw ServiceException.FAILURE(\"copying \" + item.getType() + \": \" + item.getId(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void copyCalendarItem(CalendarItem calItem, int newId, boolean fromDumpster)\n    throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n        if (newId <= 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getCalendarItemTableName(mbox) +\n                    \"(\" + mailbox_id +\n                    \" uid, item_id, start_time, end_time) \" +\n                    \"SELECT \" + MAILBOX_ID_VALUE +\n                    \" uid, ?, start_time, end_time FROM \" + getCalendarItemTableName(mbox, fromDumpster) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, newId);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, calItem.getId());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(newId, e);\n            else\n                throw ServiceException.FAILURE(\"copying \" + calItem.getType() + \": \" + calItem.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void copyRevision(MailItem revision, int newId, String locator, boolean fromDumpster)\n    throws ServiceException {\n        Mailbox mbox = revision.getMailbox();\n        if (newId <= 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getRevisionTableName(mbox) +\n                    \"(\" + mailbox_id +\n                    \" item_id, version, date, size, volume_id, blob_digest, name, metadata,\" +\n                    \" mod_metadata, change_date, mod_content) \" +\n                    \"SELECT \" + MAILBOX_ID_VALUE +\n                    \" ?, version, date, size, ?, blob_digest, name, metadata,\" +\n                    \" mod_metadata, change_date, mod_content\" +\n                    \" FROM \" + getRevisionTableName(mbox, fromDumpster) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ? AND version = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, newId);\n            if (locator != null)\n                stmt.setString(pos++, locator);       // VOLUME_ID specified by caller\n            else\n                stmt.setNull(pos++, Types.VARCHAR);      //   or, no VOLUME_ID\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, revision.getId());\n            stmt.setInt(pos++, revision.getVersion());\n            int num = stmt.executeUpdate();\n            if (num != 1)\n                throw ServiceException.FAILURE(\"failed to create object\", null);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(newId, e);\n            } else {\n                throw ServiceException.FAILURE(\"copying revision \" + revision.getVersion() + \" for \" +\n                        revision.getType() + \": \" + revision.getId(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void icopy(MailItem source, UnderlyingData data, boolean shared) throws ServiceException {\n        Mailbox mbox = source.getMailbox();\n        if (data == null || data.id <= 0 || data.folderId <= 0 || data.parentId == 0)\n            throw ServiceException.FAILURE(\"invalid data for DB item i-copy\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, data.folderId, source.getName(), data.id);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            String flags;\n            if (!shared) {\n                flags = \"flags\";\n            } else if (Db.supports(Db.Capability.BITWISE_OPERATIONS)) {\n                flags = \"flags | \" + Flag.BITMASK_COPIED;\n            } else {\n                flags = \"CASE WHEN \" + Db.getInstance().bitAND(\"flags\", String.valueOf(Flag.BITMASK_COPIED)) +\n                        \" <> 0 THEN flags ELSE flags + \" + Flag.BITMASK_COPIED + \" END\";\n            }\n            stmt = conn.prepareStatement(\"INSERT INTO \" + table +\n                        \"(\" + mailbox_id +\n                        \" id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest,\" +\n                        \" unread, flags, tags, sender, subject, name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id +\n                        \" ?, type, parent_id, ?, ?, ?, date, size, ?, blob_digest,\" +\n                        \" unread, \" + flags + \", tags, sender, subject, name, metadata, ?, ?, ? FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, data.id);                       // ID\n            stmt.setInt(pos++, data.folderId);                 // FOLDER_ID\n            if (data.indexId == MailItem.IndexStatus.NO.id()) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, data.indexId);\n            }\n            stmt.setInt(pos++, data.imapId);                   // IMAP_ID\n            if (data.locator != null)\n                stmt.setString(pos++, data.locator);           // VOLUME_ID\n            else\n                stmt.setNull(pos++, Types.TINYINT);            //   or, no VOLUME_ID\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_METADATA\n            stmt.setInt(pos++, mbox.getOperationTimestamp());  // CHANGE_DATE\n            stmt.setInt(pos++, mbox.getOperationChangeID());   // MOD_CONTENT\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, source.getId());\n            stmt.executeUpdate();\n            stmt.close();\n\n            boolean needsTag = shared && !source.isTagged(Flag.ID_COPIED);\n\n            if (needsTag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(source.getInternalFlagBitmask() | Flag.BITMASK_COPIED);\n\n            if (needsTag || source.getParentId() > 0) {\n                boolean altersMODSEQ = source.getParentId() > 0;\n                String updateChangeID = (altersMODSEQ ? \", mod_metadata = ?, change_date = ?\" : \"\");\n                stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = NULL, flags = \" + flags + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                pos = 1;\n                if (altersMODSEQ) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, source.getId());\n                stmt.executeUpdate();\n                stmt.close();\n            }\n\n            if (source instanceof Message && source.getParentId() <= 0)\n                changeOpenTargets(source, data.id);\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(data.id, e);\n            } else {\n                throw ServiceException.FAILURE(\"i-copying \" + source.getType() + \": \" + source.getId(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void snapshotRevision(MailItem item, int version) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(version >= 1);\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getRevisionTableName(mbox) +\n                        \"(\" + mailbox_id + \"item_id, version, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content) \" +\n                        \"SELECT \" + mailbox_id + \"id, ?, date, size, volume_id, blob_digest,\" +\n                        \" name, metadata, mod_metadata, change_date, mod_content\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, version);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(item.getId(), e);\n            } else {\n                throw ServiceException.FAILURE(\"saving revision info for \" + item.getType() + \": \" + item.getId(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void purgeRevisions(MailItem item, int revision, boolean includeOlderRevisions) throws ServiceException {\n        if (revision <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getRevisionTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ? AND version \" +\n                        (includeOlderRevisions ? \"<= ?\" : \"= ?\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.setInt(pos++, revision);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"purging revisions for \" + item.getType() + \": \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void changeType(MailItem item, byte type) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET type = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, type);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new type for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(MailItem item, Folder folder) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != folder.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folder.getId(), item.getName(), item.getId());\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            int pos = 1;\n            boolean hasIndexId = false;\n            if (item instanceof Folder) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET parent_id = ?, folder_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                stmt.setInt(pos++, folder.getId());\n            } else if (item instanceof Conversation && !(item instanceof VirtualConversation)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ?\");\n            } else {\n                // set the indexId, in case it changed (moving items out of junk can trigger an index ID change)\n                hasIndexId = true;\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                            \" SET folder_id = ?, index_id = ?, mod_metadata = ?, change_date = ? \" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            }\n            stmt.setInt(pos++, folder.getId());\n            if (hasIndexId) {\n                if (item.getIndexStatus() == MailItem.IndexStatus.NO) {\n                    stmt.setNull(pos++, Types.INTEGER);\n                } else {\n                    stmt.setInt(pos++, item.getIndexId());\n                }\n            }\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            else\n                throw ServiceException.FAILURE(\"writing new folder data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void setFolder(List<Message> msgs, Folder folder) throws ServiceException {\n        if (msgs == null || msgs.isEmpty())\n            return;\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            // commented out because at present messages cannot have names (and thus can't have naming conflicts)\n//            if (!Db.supports(Db.Capability.UNIQUE_NAME_INDEX) || Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) {\n//                stmt = conn.prepareStatement(\"SELECT mi.name\" +\n//                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getMailItemTableName(mbox, \"m2\") +\n//                        \" WHERE mi.id IN \" + DbUtil.suitableNumberOfVariables(itemIDs) +\n//                        \" AND mi.name IS NOT NULL and m2.name IS NOT NULL\" +\n//                        \" AND m2.folder_id = ? AND mi.id <> m2.id\" +\n//                        \" AND \" + (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) ? \"UPPER(mi.name) = UPPER(m2.name)\" : \"mi.name = m2.name\") +\n//                        \" AND mi.mailbox_id = ? AND m2.mailbox_id = ?\");\n//                int pos = 1;\n//                for (Message msg : msgs)\n//                    stmt.setInt(pos++, msg.getId());\n//                stmt.setInt(pos++, folder.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                stmt.setInt(pos++, mbox.getId());\n//                rs = stmt.executeQuery();\n//                if (rs.next())\n//                    throw MailServiceException.ALREADY_EXISTS(rs.getString(1));\n//                rs.close();\n//                stmt.close();\n//            }\n\n            String imapRenumber = mbox.isTrackingImap() ? \", imap_id = CASE WHEN imap_id IS NULL THEN NULL ELSE 0 END\" : \"\";\n            for (int i = 0; i < msgs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), msgs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                            \" SET folder_id = ?, mod_metadata = ?, change_date = ?\" + imapRenumber +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count));\n                int pos = 1;\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, msgs.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n//            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n//                throw MailServiceException.ALREADY_EXISTS(msgs.toString(), e);\n//            else\n            throw ServiceException.FAILURE(\"writing new folder data for messages\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static SetMultimap<MailItem.Type, Integer> getIndexDeferredIds(DbConnection conn, Mailbox mbox)\n            throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT type, id FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"index_id <= 1\"); // 0: deferred, 1: stale\n            try {\n                setMailboxId(stmt, mbox, 1);\n                ResultSet rs = stmt.executeQuery();\n                try {\n                    SetMultimap<MailItem.Type, Integer> result = Multimaps.newSetMultimap(\n                            new EnumMap<MailItem.Type, Collection<Integer>>(MailItem.Type.class),\n                            new Supplier<Set<Integer>>() {\n                                @Override public Set<Integer> get() {\n                                    return new HashSet<Integer>();\n                                }\n                            });\n                    while (rs.next()) {\n                        result.put(MailItem.Type.of(rs.getByte(1)), rs.getInt(2));\n                    }\n                    return result;\n                } finally {\n                    DbPool.closeResults(rs);\n                }\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to query index deferred IDs\", e);\n        }\n    }\n\n    public static List<Integer> getReIndexIds(Mailbox mbox, Set<MailItem.Type> types) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = DbPool.getConnection(mbox);\n        try {\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"index_id IS NOT NULL\" +\n                    (types.isEmpty() ? \"\" : \" AND \" + DbUtil.whereIn(\"type\", types.size())));\n            try {\n                int pos = setMailboxId(stmt, mbox, 1);\n                for (MailItem.Type type : types) {\n                    stmt.setByte(pos++, type.toByte());\n                }\n                ResultSet rs = stmt.executeQuery();\n                try {\n                    List<Integer> ids = new ArrayList<Integer>();\n                    while (rs.next()) {\n                        ids.add(rs.getInt(1));\n                    }\n                    return ids;\n                } finally {\n                    DbPool.closeResults(rs);\n                }\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to query re-index IDs\", e);\n        } finally {\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void setIndexIds(Mailbox mbox, List<MailItem> items) throws ServiceException {\n        if (items == null || items.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < items.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), items.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) + \" SET index_id = id WHERE \" +\n                        IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, items.get(index).getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to set index_id\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void resetIndexId(DbConnection conn, Mailbox mbox) throws ServiceException {\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                    \" SET index_id = 0 WHERE \" + IN_THIS_MAILBOX_AND + \"index_id > 0\");\n            setMailboxId(stmt, mbox, 1);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to reset index_id\", e);\n        } finally {\n            conn.closeQuietly(stmt);\n        }\n    }\n\n    public static void resetSenderId(DbConnection conn, Mailbox mbox) throws ServiceException {\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                    \" SET sender_id = NULL WHERE \" + IN_THIS_MAILBOX_AND + \"sender_id IS NOT NULL\");\n            setMailboxId(stmt, mbox, 1);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to reset sender_id\", e);\n        } finally {\n            conn.closeQuietly(stmt);\n        }\n    }\n\n    public static void setParent(MailItem child, MailItem parent) throws ServiceException {\n        setParent(new MailItem[] { child }, parent);\n    }\n\n    public static void setParent(MailItem[] children, MailItem parent) throws ServiceException {\n        if (children == null || children.length == 0)\n            return;\n        Mailbox mbox = children[0].getMailbox();\n        if (parent != null && mbox != parent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < children.length; i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), children.length - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count));\n                int pos = 1;\n                if (parent == null || parent instanceof VirtualConversation)\n                    stmt.setNull(pos++, Types.INTEGER);\n                else\n                    stmt.setInt(pos++, parent.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, children[index].getId());\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"adding children to parent \" + (parent == null ? \"NULL\" : parent.getId() + \"\"), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void reparentChildren(MailItem oldParent, MailItem newParent) throws ServiceException {\n        if (oldParent == newParent)\n            return;\n        Mailbox mbox = oldParent.getMailbox();\n        if (mbox != newParent.getMailbox())\n            throw MailServiceException.WRONG_MAILBOX();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation = (oldParent instanceof VirtualConversation ? \"id = ?\" : \"parent_id = ?\");\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(oldParent) +\n                        \" SET parent_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + relation);\n            int pos = 1;\n            if (newParent instanceof VirtualConversation) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, newParent.getId());\n            }\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, oldParent instanceof VirtualConversation ? ((VirtualConversation) oldParent).getMessageId() : oldParent.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new parent for children of item \" + oldParent.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveMetadata(MailItem item, String metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setString(pos++, checkMetadataLength(metadata));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void persistCounts(MailItem item, Metadata metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET size = ?, unread = ?, metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getUnreadCount());\n            stmt.setString(pos++, checkMetadataLength(metadata.toString()));\n            stmt.setInt(pos++, item.getModifiedSequence());\n            if (item.getChangeDate() > 0)\n                stmt.setInt(pos++, (int) (item.getChangeDate() / 1000));\n            else\n                stmt.setNull(pos++, Types.INTEGER);\n            stmt.setInt(pos++, item.getSavedSequence());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing metadata for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // need to kill the Note class sooner rather than later\n    public static void saveSubject(Note note) throws ServiceException {\n        Mailbox mbox = note.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(note) +\n                        \" SET date = ?, size = ?, subject = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (note.getDate() / 1000));\n            stmt.setLong(pos++, note.getSize());\n            stmt.setString(pos++, note.getSubject());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, note.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing subject for mailbox \" + note.getMailboxId() + \", note \" + note.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveName(MailItem item, int folderId, Metadata metadata) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        String name = item.getName().equals(\"\") ? null : item.getName();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        checkNamingConstraint(mbox, folderId, name, item.getId());\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFolder = item instanceof Folder;\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET date = ?, size = ?, flags = ?, name = ?, subject = ?,\" +\n                        \"  folder_id = ?,\" + (isFolder ? \" parent_id = ?,\" : \"\") +\n                        \"  metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, name);\n            stmt.setInt(pos++, folderId);\n            if (isFolder) {\n                stmt.setInt(pos++, folderId);\n            }\n            stmt.setString(pos++, metadata.toString());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW))\n                throw MailServiceException.ALREADY_EXISTS(name, e);\n            else\n                throw ServiceException.FAILURE(\"writing name for mailbox \" + item.getMailboxId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public void update(MailItem item, Metadata metadata) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mailbox));\n        String name = item.getName().equals(\"\") ? null : item.getName();\n        checkNamingConstraint(mailbox, item.getFolderId(), name, item.getId());\n\n        DbConnection conn = mailbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                    \" SET type = ?, imap_id = ?, index_id = ?, parent_id = ?, date = ?, size = ?, flags = ?, \" +\n                    \"blob_digest = ?, sender = ?, sender_id = ?, recipients = ?, subject = ?, name = ?, \" +\n                    \"metadata = ?, mod_metadata = ?, change_date = ?, mod_content = ?, volume_id = ? WHERE \" +\n                    IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setByte(pos++, item.getType().toByte());\n            if (item.getImapUid() >= 0) {\n                stmt.setInt(pos++, item.getImapUid());\n            } else {\n                stmt.setNull(pos++, Types.INTEGER);\n            }\n            if (item.getIndexStatus() == MailItem.IndexStatus.NO) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, item.getIndexId());\n            }\n            // messages in virtual conversations are stored with a null parent_id\n            if (item.getParentId() <= 0) {\n                stmt.setNull(pos++, Types.INTEGER);\n            } else {\n                stmt.setInt(pos++, item.getParentId());\n            }\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setLong(pos++, item.getSize());\n            stmt.setInt(pos++, item.getInternalFlagBitmask());\n            stmt.setString(pos++, item.getDigest());\n            stmt.setString(pos++, item.getSortSender());\n            if (senderId >= 0) {\n                stmt.setInt(pos++, senderId);\n            } else {\n                stmt.setNull(pos++, Types.INTEGER);\n            }\n            stmt.setString(pos++, item.getSortRecipients());\n            stmt.setString(pos++, item.getSortSubject());\n            stmt.setString(pos++, name);\n            stmt.setString(pos++, checkMetadataLength(metadata.toString()));\n            stmt.setInt(pos++, mailbox.getOperationChangeID());\n            stmt.setInt(pos++, mailbox.getOperationTimestamp());\n            stmt.setInt(pos++, item.getSavedSequence());\n            if (item.getLocator() != null) {\n                stmt.setString(pos++, item.getLocator());\n            } else {\n                stmt.setNull(pos++, Types.TINYINT);\n            }\n            pos = setMailboxId(stmt, mailbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n\n            // Update the flagset cache.  Assume that the item's in-memory data has already been updated.\n            if (areFlagsetsLoaded(mailbox)) {\n                getFlagsetCache(conn, mailbox).addTagset(item.getInternalFlagBitmask());\n            }\n        } catch (SQLException e) {\n            // catch item_id uniqueness constraint violation and return failure\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                throw MailServiceException.ALREADY_EXISTS(item.getName(), e);\n            } else {\n                throw ServiceException.FAILURE(\"Failed to update item mbox=\" + mailbox.getId() + \",id=\" + item.getId(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveBlobInfo(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET size = ?, blob_digest = ?, volume_id = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setLong(pos++, item.getSize());\n            stmt.setString(pos++, item.getDigest());\n            if (item.getLocator() != null)\n                stmt.setString(pos++, item.getLocator());\n            else\n                stmt.setNull(pos++, Types.TINYINT);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating blob info for mailbox \" + mbox.getId() + \", item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void openConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getConversationTableName(item) +\n                        \"(\" + mailbox_id + \"hash, conv_id)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(item) +\n                            \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, item.getId());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setString(pos++, hash);\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating open conversation association for hash \" + hash, nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing open conversation association for hash \" + hash, e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void closeConversation(String hash, MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(item) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"hash = ? AND conv_id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, hash);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversation association for hash \" + hash, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes rows from <tt>open_conversation</tt> whose items are older than\n     * the given date.\n     *\n     * @param mbox the mailbox\n     * @param beforeDate the cutoff date in seconds\n     */\n    public static void closeOldConversations(Mailbox mbox, int beforeDate) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ZimbraLog.purge.debug(\"Closing conversations dated before %d.\", beforeDate);\n        try {\n            String mailboxJoin = (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = open_conversation.mailbox_id\");\n            stmt = conn.prepareStatement(\"DELETE FROM \" + getConversationTableName(mbox) +\n                \" WHERE \" + IN_THIS_MAILBOX_AND + \"conv_id IN (\" +\n                \"  SELECT id FROM \" + getMailItemTableName(mbox, \"mi\") +\n                \"  WHERE mi.id = open_conversation.conv_id\" +\n                   mailboxJoin +\n                \"  AND date < ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, beforeDate);\n            int numRows = stmt.executeUpdate();\n            if (numRows > 0) {\n                ZimbraLog.purge.info(\"Closed %d conversations dated before %d.\", numRows, beforeDate);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"closing open conversations dated before \" + beforeDate, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void changeOpenTargets(MailItem oldTarget, int newTargetId) throws ServiceException {\n        Mailbox mbox = oldTarget.getMailbox();\n        int oldTargetId = oldTarget instanceof VirtualConversation ? ((VirtualConversation) oldTarget).getMessageId() : oldTarget.getId();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getConversationTableName(oldTarget) +\n                        \" SET conv_id = ? WHERE \" + IN_THIS_MAILBOX_AND + \"conv_id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, newTargetId);\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, oldTargetId);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"switching open conversation association for item \" + oldTarget.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveDate(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET date = ?, mod_metadata = ?, change_date = ? WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, (int) (item.getDate() / 1000));\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void saveImapUid(MailItem item) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                        \" SET imap_id = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, item.getImapUid());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting IMAP UID for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(MailItem item, Tag tag, boolean add) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n        if (mbox != tag.getMailbox()) {\n            throw MailServiceException.WRONG_MAILBOX();\n        }\n        if (tag.getId() == Flag.ID_UNREAD) {\n            throw ServiceException.FAILURE(\"unread state must be updated with alterUnread()\", null);\n        }\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAGS_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = Db.getInstance().bitAND(column, \"?\") + (add ? \" = 0\" : \" <> 0\");\n\n            String relation;\n            if (item instanceof VirtualConversation) {\n                relation = \"id = ?\";\n            } else if (item instanceof Conversation) {\n                relation = \"parent_id = ?\";\n            } else if (item instanceof Folder) {\n                relation = \"folder_id = ?\";\n            } else if (item instanceof Flag) {\n                relation = Db.getInstance().bitAND(\"flags\", \"?\") + \" <> 0\";\n            } else if (item instanceof Tag) {\n                relation = Db.getInstance().bitAND(\"tags\", \"?\") + \" <> 0\";\n            } else {\n                relation = \"id = ?\";\n            }\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                    \" SET \" + primaryUpdate + updateChangeID +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND \" + relation);\n\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            if (altersModseq) {\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n            }\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, tag.getBitmask());\n            if (item instanceof Tag) {\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            } else if (item instanceof VirtualConversation) {\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            } else {\n                stmt.setInt(pos++, item.getId());\n            }\n            stmt.executeUpdate();\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox))\n                getFlagsetCache(conn, mbox).addTagset(item.getInternalFlagBitmask());\n            else if (areTagsetsLoaded(mbox))\n                getTagsetCache(conn, mbox).addTagset(item.getTagBitmask());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterTag(Tag tag, List<Integer> itemIDs, boolean add) throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty()) {\n            return;\n        }\n        Mailbox mbox = tag.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            boolean isFlag = tag instanceof Flag;\n            boolean altersModseq = !isFlag || (tag.getBitmask() & Flag.FLAGS_SYSTEM) == 0;\n            String column = (isFlag ? \"flags\" : \"tags\");\n\n            String primaryUpdate = column + \" = \" + column + (add ? \" + ?\" : \" - ?\");\n            String updateChangeID = (altersModseq ? \", mod_metadata = ?, change_date = ?\" : \"\");\n            String precondition = Db.getInstance().bitAND(column, \"?\") + (add ? \" = 0\" : \" <> 0\");\n\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                            \" SET \" + primaryUpdate + updateChangeID +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + precondition + \" AND \" + DbUtil.whereIn(\"id\", count));\n\n                int pos = 1;\n                stmt.setLong(pos++, tag.getBitmask());\n                if (altersModseq) {\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                }\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setLong(pos++, tag.getBitmask());\n                for (int index = i; index < i + count; index++) {\n                    stmt.setInt(pos++, itemIDs.get(index));\n                }\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n\n            // Update the flagset or tagset cache.  Assume that the item's in-memory\n            // data has already been updated.\n            if (tag instanceof Flag && areFlagsetsLoaded(mbox)) {\n                getFlagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n            } else if (areTagsetsLoaded(mbox)) {\n                getTagsetCache(conn, mbox).applyMask(tag.getBitmask(), add);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating tag data for \" + itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void clearTag(Tag tag) throws ServiceException {\n        Mailbox mbox = tag.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(tag) +\n                        \" SET tags = tags - ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + Db.getInstance().bitAND(\"tags\", \"?\") + \" <> 0\");\n            int pos = 1;\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, tag.getBitmask());\n            stmt.executeUpdate();\n\n            if (areTagsetsLoaded(mbox)) {\n                getTagsetCache(conn, mbox).applyMask(tag.getTagBitmask(), false);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"clearing all references to tag \" + tag.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Sets the <code>unread</code> column for the specified <code>MailItem</code>.\n     * If the <code>MailItem</code> is a <code>Conversation</code>, <code>Tag</code>\n     * or <code>Folder</code>, sets the <code>unread</code> column for all related items.\n     */\n    public static void alterUnread(MailItem item, boolean unread) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String relation;\n            if (item instanceof VirtualConversation) {\n                relation = \"id = ?\";\n            } else if (item instanceof Conversation) {\n                relation = \"parent_id = ?\";\n            } else if (item instanceof Folder) {\n                relation = \"folder_id = ?\";\n            } else if (item instanceof Flag) {\n                relation = Db.getInstance().bitAND(\"flags\", \"?\") + \" <> 0\";\n            } else if (item instanceof Tag) {\n                relation = Db.getInstance().bitAND(\"tags\", \"?\") + \" <> 0\";\n            } else {\n                relation = \"id = ?\";\n            }\n\n            stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(item) +\n                        \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ? AND \" + relation +\n                        \"  AND \" + typeIn(MailItem.Type.MESSAGE));\n            int pos = 1;\n            stmt.setInt(pos++, unread ? 1 : 0);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, unread ? 0 : 1);\n            if (item instanceof Tag) {\n                stmt.setLong(pos++, ((Tag) item).getBitmask());\n            } else if (item instanceof VirtualConversation) {\n                stmt.setInt(pos++, ((VirtualConversation) item).getMessageId());\n            } else {\n                stmt.setInt(pos++, item.getId());\n            }\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for item \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void alterUnread(Mailbox mbox, List<Integer> itemIDs, boolean unread)\n    throws ServiceException {\n        if (itemIDs == null || itemIDs.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            for (int i = 0; i < itemIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), itemIDs.size() - i);\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET unread = ?, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread = ?\" +\n                            \"  AND \" + DbUtil.whereIn(\"id\", count) +\n                            \"  AND \" + typeIn(MailItem.Type.MESSAGE));\n                int pos = 1;\n                stmt.setInt(pos++, unread ? 1 : 0);\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, unread ? 0 : 1);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, itemIDs.get(index));\n                stmt.executeUpdate();\n                stmt.close();\n                stmt = null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating unread state for \" +\n                itemIDs.size() + \" items: \" + getIdListForLogging(itemIDs), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all conversations affected by a folder deletion.  For all conversations\n     * that have messages in the given folder, updates their message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     *\n     * @param folder the folder that is being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Folder folder, Set<Integer> candidates) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) + \", \" +\n                        \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                        \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.Type.CONVERSATION.toByte());\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, folder.getId());\n                stmt.setInt(pos++, mbox.getOperationChangeID());\n                stmt.setInt(pos++, mbox.getOperationTimestamp());\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.executeUpdate();\n                stmt.close();\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setInt(pos++, folder.getId());\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    List<Integer> convIDs = update.getValue();\n                    for (int i = 0; i < convIDs.size(); i += Db.getINClauseBatchSize()) {\n                        int count = Math.min(Db.getINClauseBatchSize(), convIDs.size() - i);\n                        stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(folder) +\n                                \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                                \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count) +\n                                \"  AND type = \" + MailItem.Type.CONVERSATION.toByte());\n                        pos = 1;\n                        stmt.setInt(pos++, update.getKey());\n                        stmt.setInt(pos++, mbox.getOperationChangeID());\n                        stmt.setInt(pos++, mbox.getOperationTimestamp());\n                        pos = setMailboxId(stmt, mbox, pos);\n                        for (int index = i; index < i + count; index++)\n                            stmt.setInt(pos++, convIDs.get(index));\n                        stmt.executeUpdate();\n                        stmt.close();\n                    }\n                }\n            }\n\n            return getPurgedConversations(mbox, candidates);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations crossing folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Updates all affected conversations when a <code>List</code> of <code>MailItem</code>s\n     * is deleted.  Updates each conversation's message count and nulls out\n     * metadata so that the sender list is recalculated the next time the conversation\n     * is instantiated.\n     *\n     * @param mbox the mailbox\n     * @param ids of the items being deleted\n     * @return the ids of any conversation that were purged as a result of this operation\n     */\n    public static List<Integer> markDeletionTargets(Mailbox mbox, List<Integer> ids, Set<Integer> candidates) throws ServiceException {\n        if (ids == null)\n            return null;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox);\n            if (Db.supports(Db.Capability.MULTITABLE_UPDATE)) {\n                for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n                    int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                    stmt = conn.prepareStatement(\"UPDATE \" + table + \", \" +\n                            \"(SELECT parent_id pid, COUNT(*) count FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count) +\n                            \" AND parent_id IS NOT NULL GROUP BY parent_id) AS x\" +\n                            \" SET size = size - count, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = pid AND type = \" + MailItem.Type.CONVERSATION.toByte());\n                    int pos = 1;\n                    pos = setMailboxId(stmt, mbox, pos);\n                    for (int index = i; index < i + count; index++)\n                        stmt.setInt(pos++, ids.get(index));\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            } else {\n                stmt = conn.prepareStatement(\"SELECT parent_id, COUNT(*) FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", ids.size()) + \"AND parent_id IS NOT NULL\" +\n                        \" GROUP BY parent_id\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int id : ids)\n                    stmt.setInt(pos++, id);\n                rs = stmt.executeQuery();\n                Map<Integer, List<Integer>> counts = new HashMap<Integer, List<Integer>>();\n                while (rs.next()) {\n                    int convId = rs.getInt(1), count = rs.getInt(2);\n                    List<Integer> targets = counts.get(count);\n                    if (targets == null)\n                        counts.put(count, targets = new ArrayList<Integer>());\n                    targets.add(convId);\n                }\n                rs.close();\n                stmt.close();\n\n                for (Map.Entry<Integer, List<Integer>> update : counts.entrySet()) {\n                    stmt = conn.prepareStatement(\"UPDATE \" + getMailItemTableName(mbox) +\n                            \" SET size = size - ?, metadata = NULL, mod_metadata = ?, change_date = ?\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", update.getValue().size()) +\n                            \" AND type = \" + MailItem.Type.CONVERSATION.toByte());\n                    pos = 1;\n                    stmt.setInt(pos++, update.getKey());\n                    stmt.setInt(pos++, mbox.getOperationChangeID());\n                    stmt.setInt(pos++, mbox.getOperationTimestamp());\n                    pos = setMailboxId(stmt, mbox, pos);\n                    for (int convId : update.getValue())\n                        stmt.setInt(pos++, convId);\n                    stmt.executeUpdate();\n                    stmt.close();\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking deletions for conversations touching \" +\n                ids.size() + \" items: \" + getIdListForLogging(ids), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return getPurgedConversations(mbox, candidates);\n    }\n\n    private static List<Integer> getPurgedConversations(Mailbox mbox, Set<Integer> candidates) throws ServiceException {\n        if (candidates == null || candidates.isEmpty())\n            return null;\n        List<Integer> purgedConvs = new ArrayList<Integer>();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // note: be somewhat careful making changes here, as <tt>i</tt> and <tt>it</tt> operate separately\n            Iterator<Integer> it = candidates.iterator();\n            for (int i = 0; i < candidates.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), candidates.size() - i);\n                stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count) + \" AND size <= 0\");\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n                rs = stmt.executeQuery();\n\n                while (rs.next())\n                    purgedConvs.add(rs.getInt(1));\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            return purgedConvs;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting list of purged conversations\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes the specified <code>MailItem</code> from the <code>mail_item</code>\n     * table.  If the object is a <code>Folder</code> or <code>Conversation</code>,\n     * deletes any corresponding messages.  Does not delete subfolders.\n     */\n    public static void delete(MailItem item, boolean fromDumpster) throws ServiceException {\n        deleteContents(item, fromDumpster);\n        if (item instanceof VirtualConversation)\n            return;\n        delete(item.getMailbox(), Collections.singletonList(item.getId()), fromDumpster);\n    }\n\n    /**\n     * Deletes <code>MailItem</code>s with the specified ids from the <code>mail_item</code>\n     * table.  Assumes that there is no data referencing the specified id's.\n     */\n    public static void delete(Mailbox mbox, Collection<Integer> ids, boolean fromDumpster) throws ServiceException {\n        // trim out any non-persisted items\n        if (ids == null || ids.size() == 0)\n            return;\n        List<Integer> targets = new ArrayList<Integer>();\n        for (int id : ids) {\n            if (id > 0)\n                targets.add(id);\n        }\n        if (targets.size() == 0)\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        for (int offset = 0; offset < targets.size(); offset += Db.getINClauseBatchSize()) {\n            PreparedStatement stmt = null;\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), targets.size() - offset);\n                if (!fromDumpster && mbox.dumpsterEnabled())\n                    copyToDumpster(conn, mbox, targets, offset, count);\n                stmt = conn.prepareStatement(\"DELETE FROM \" + getMailItemTableName(mbox, fromDumpster) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int i = offset; i < offset + count; ++i)\n                    stmt.setInt(pos++, targets.get(i));\n                stmt.executeUpdate();\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"deleting \" + ids.size() + \" item(s): \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        }\n    }\n\n    public static void deleteContents(MailItem item, boolean fromDumpster) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        String target;\n        if (item instanceof VirtualConversation)  target = \"id = ?\";\n        else if (item instanceof Conversation)    target = \"parent_id = ?\";\n        else if (item instanceof Document)        target = \"parent_id = ?\";\n        else if (item instanceof SearchFolder)    return;\n        else if (item instanceof Folder)          target = \"folder_id = ?\";\n        else                                      return;\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        String miTableName = getMailItemTableName(item, fromDumpster);\n        try {\n            if (!fromDumpster && mbox.dumpsterEnabled()) {\n                // Get the list of item ids to be deleted.\n                List<Integer> ids = new ArrayList<Integer>();\n                PreparedStatement listStmt = null;\n                ResultSet rs = null;\n                try {\n                    listStmt = conn.prepareStatement(\"SELECT id FROM \" + miTableName +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + target +\n//                            \" AND type NOT IN \" + FOLDER_TYPES +  // DUMPSTER_TYPES implies !FOLDER_TYPES\n                            \" AND type IN \" + DUMPSTER_TYPES);\n                    int pos = 1;\n                    pos = setMailboxId(listStmt, mbox, pos);\n                    listStmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n                    rs = listStmt.executeQuery();\n                    while (rs.next()) {\n                        int id = rs.getInt(1);\n                        if (id > 0)\n                            ids.add(id);\n                    }\n                } finally {\n                    DbPool.closeResults(rs);\n                    DbPool.closeStatement(listStmt);\n                }\n                if (!ids.isEmpty()) {\n                    for (int offset = 0; offset < ids.size(); offset += Db.getINClauseBatchSize()) {\n                        int count = Math.min(Db.getINClauseBatchSize(), ids.size() - offset);\n                        copyToDumpster(conn, mbox, ids, offset, count);\n                    }\n                }\n            }\n\n            stmt = conn.prepareStatement(\"DELETE FROM \" + miTableName +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + target + \" AND type NOT IN \" + FOLDER_TYPES);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item instanceof VirtualConversation ? ((VirtualConversation) item).getMessageId() : item.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting contents for \" + item.getType() + \" \" + item.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // parent_id = null, change_date = ? (to be set to deletion time)\n    private static String MAIL_ITEM_DUMPSTER_COPY_SRC_FIELDS =\n        (DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \") +\n        \"id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest, \" +\n        \"unread, flags, tags, sender, recipients, subject, name, metadata, mod_metadata, ?, mod_content\";\n    private static String MAIL_ITEM_DUMPSTER_COPY_DEST_FIELDS =\n        (DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \") +\n        \"id, type, parent_id, folder_id, index_id, imap_id, date, size, volume_id, blob_digest, \" +\n        \"unread, flags, tags, sender, recipients, subject, name, metadata, mod_metadata, change_date, mod_content\";\n\n    /**\n     * Copy rows from mail_item, appointment and revision table to the corresponding dumpster tables.\n     * @param conn\n     * @param mbox\n     * @param ids\n     * @param offset offset of the first item to copy in ids\n     * @param count number of items to copy\n     * @throws SQLException\n     * @throws ServiceException\n     */\n    private static void copyToDumpster(DbConnection conn, Mailbox mbox, List<Integer> ids, int offset, int count)\n    throws SQLException, ServiceException {\n        String miTableName = getMailItemTableName(mbox, false);\n        String dumpsterMiTableName = getMailItemTableName(mbox, true);\n        String ciTableName = getCalendarItemTableName(mbox, false);\n        String dumpsterCiTableName = getCalendarItemTableName(mbox, true);\n        String revTableName = getRevisionTableName(mbox, false);\n        String dumpsterRevTableName = getRevisionTableName(mbox, true);\n\n        // Copy the mail_item rows being deleted to dumpster_mail_item.  Copy the corresponding rows\n        // from appointment and revision tables to their dumpster counterparts.  They are copied here,\n        // just before cascaded deletes following mail_item deletion.\n        String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n        String whereIdIn = DbUtil.whereIn(\"id\", count);\n        String whereItemIdIn = DbUtil.whereIn(\"item_id\", count);\n        String notSpam = !mbox.useDumpsterForSpam() ? \" AND folder_id != \" + Mailbox.ID_FOLDER_SPAM : \"\";\n        String notDraft = \" AND folder_id != \" + Mailbox.ID_FOLDER_DRAFTS;\n        PreparedStatement miCopyStmt = null;\n        try {\n            miCopyStmt = conn.prepareStatement(command + \" INTO \" + dumpsterMiTableName +\n                    \" (\" + MAIL_ITEM_DUMPSTER_COPY_DEST_FIELDS + \")\" +\n                    \" SELECT \" + MAIL_ITEM_DUMPSTER_COPY_SRC_FIELDS + \" FROM \" + miTableName +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + whereIdIn + \" AND type IN \" + DUMPSTER_TYPES + notSpam + notDraft);\n            int pos = 1;\n            miCopyStmt.setInt(pos++, mbox.getOperationTimestamp());\n            pos = setMailboxId(miCopyStmt, mbox, pos);\n            for (int i = offset; i < offset + count; ++i)\n                miCopyStmt.setInt(pos++, ids.get(i));\n            miCopyStmt.executeUpdate();\n        } finally {\n            DbPool.closeStatement(miCopyStmt);\n        }\n\n        PreparedStatement ciCopyStmt = null;\n        try {\n            ciCopyStmt = conn.prepareStatement(command + \" INTO \" + dumpsterCiTableName +\n                    \" SELECT * FROM \" + ciTableName +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + whereItemIdIn);\n            int pos = 1;\n            pos = setMailboxId(ciCopyStmt, mbox, pos);\n            for (int i = offset; i < offset + count; ++i)\n                ciCopyStmt.setInt(pos++, ids.get(i));\n            ciCopyStmt.executeUpdate();\n        } finally {\n            DbPool.closeStatement(ciCopyStmt);\n        }\n\n        PreparedStatement revCopyStmt = null;\n        try {\n            revCopyStmt = conn.prepareStatement(command + \" INTO \" + dumpsterRevTableName +\n                    \" SELECT * FROM \" + revTableName +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + whereItemIdIn);\n            int pos = 1;\n            pos = setMailboxId(revCopyStmt, mbox, pos);\n            for (int i = offset; i < offset + count; ++i)\n                revCopyStmt.setInt(pos++, ids.get(i));\n            revCopyStmt.executeUpdate();\n        } finally {\n            DbPool.closeStatement(revCopyStmt);\n        }\n    }\n\n    public static void writeTombstones(Mailbox mbox, TypedIdList tombstones) throws ServiceException {\n        if (tombstones == null || tombstones.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        for (Map.Entry<MailItem.Type, List<Integer>> entry : tombstones) {\n            MailItem.Type type = entry.getKey();\n            switch (type) {\n            case CONVERSATION:\n            case VIRTUAL_CONVERSATION:\n                continue;\n            }\n            StringBuilder ids = new StringBuilder();\n            for (Integer id : entry.getValue()) {\n                ids.append(ids.length() == 0 ? \"\" : \",\").append(id);\n\n                // catch overflows of TEXT values; since all chars are ASCII, no need to convert to UTF-8 for length check beforehand\n                if (ids.length() > MAX_TEXT_LENGTH - 50) {\n                    writeTombstone(mbox, type, ids.toString());\n                    ids.setLength(0);\n                }\n            }\n\n            writeTombstone(mbox, type, ids.toString());\n        }\n    }\n\n    private static void writeTombstone(Mailbox mbox, MailItem.Type type, String ids) throws ServiceException {\n        if (Strings.isNullOrEmpty(ids)) {\n            return;\n        }\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getTombstoneTableName(mbox) +\n                        \"(\" + mailbox_id + \"sequence, date, type, ids)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, mbox.getOperationChangeID());\n            stmt.setInt(pos++, mbox.getOperationTimestamp());\n            stmt.setByte(pos++, type.toByte());\n            stmt.setString(pos++, ids);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing tombstones for \" + type + \"(s): \" + ids, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList readTombstones(Mailbox mbox, long lastSync) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        TypedIdList tombstones = new TypedIdList();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT type, ids FROM \" + getTombstoneTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"sequence > ? AND ids IS NOT NULL\" +\n                        \" ORDER BY sequence\");\n            Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                MailItem.Type type = MailItem.Type.of(rs.getByte(1));\n                String row = rs.getString(2);\n                if (row == null || row.equals(\"\"))\n                    continue;\n                for (String entry : row.split(\",\")) {\n                    try {\n                        tombstones.add(type, Integer.parseInt(entry));\n                    } catch (NumberFormatException nfe) {\n                        ZimbraLog.sync.warn(\"unparseable TOMBSTONE entry: \" + entry);\n                    }\n                }\n            }\n            return tombstones;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"reading tombstones since change: \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Deletes tombstones dated earlier than the given timestamp.\n     *\n     * @param mbox the mailbox\n     * @param beforeDate timestamp in seconds\n     * @return the change number of the most recent tombstone that was deleted, or 0 if none were removed\n     */\n    public static int purgeTombstones(Mailbox mbox, int beforeDate)\n    throws ServiceException {\n        assert Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox);\n\n        int cutoff = 0;\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT MAX(sequence) FROM \" + getTombstoneTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"date <= ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, beforeDate);\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                cutoff = rs.getInt(1);\n            }\n\n            if (cutoff > 0) {\n                stmt = conn.prepareStatement(\"DELETE FROM \" + getTombstoneTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"sequence <= ?\");\n                pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                stmt.setLong(pos++, cutoff);\n                int numRows = stmt.executeUpdate();\n                if (numRows > 0) {\n                    ZimbraLog.mailbox.info(\"Purged %d tombstones dated before %d.\", numRows, beforeDate);\n                }\n            }\n\n            return cutoff;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"purging tombstones with date before \" + beforeDate, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static final String FOLDER_TYPES = \"(\" +\n        MailItem.Type.FOLDER.toByte() + ',' +\n        MailItem.Type.SEARCHFOLDER.toByte() + ',' +\n        MailItem.Type.MOUNTPOINT.toByte() + ')';\n\n    private static final String FOLDER_AND_TAG_TYPES = \"(\" +\n        MailItem.Type.FOLDER.toByte() + ',' +\n        MailItem.Type.SEARCHFOLDER.toByte() + ',' +\n        MailItem.Type.MOUNTPOINT.toByte() + ',' +\n        MailItem.Type.TAG.toByte() + ')';\n\n    private static final String MESSAGE_TYPES = \"(\" +\n        MailItem.Type.MESSAGE.toByte() + ',' +\n        MailItem.Type.CHAT.toByte() + ')';\n\n    private static final String DOCUMENT_TYPES = \"(\" +\n        MailItem.Type.DOCUMENT.toByte() + ',' +\n        MailItem.Type.WIKI.toByte() + ')';\n\n    private static final String CALENDAR_TYPES = \"(\" +\n        MailItem.Type.APPOINTMENT.toByte() + ',' +\n        MailItem.Type.TASK.toByte() + ')';\n\n    private static final String DUMPSTER_TYPES = \"(\" +\n        MailItem.Type.MESSAGE.toByte() + ',' +\n        MailItem.Type.CONTACT.toByte() + ',' +\n        MailItem.Type.DOCUMENT.toByte() + ',' +\n        MailItem.Type.APPOINTMENT.toByte() + ',' +\n        MailItem.Type.TASK.toByte() + ',' +\n        MailItem.Type.CHAT.toByte() + ',' +\n        MailItem.Type.COMMENT.toByte() + ')';\n\n    static final String NON_SEARCHABLE_TYPES = \"(\" +\n        MailItem.Type.FOLDER.toByte() + ',' +\n        MailItem.Type.SEARCHFOLDER.toByte() + ',' +\n        MailItem.Type.MOUNTPOINT.toByte() + ',' +\n        MailItem.Type.TAG.toByte() + ',' +\n        MailItem.Type.CONVERSATION.toByte() + ')';\n\n    private static String typeIn(MailItem.Type type) {\n        switch (type) {\n            case FOLDER:    return \"type IN \" + FOLDER_TYPES;\n            case MESSAGE:   return \"type IN \" + MESSAGE_TYPES;\n            case DOCUMENT:  return \"type IN \" + DOCUMENT_TYPES;\n            default:        return \"type = \" + type.toByte();\n        }\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class FolderTagMap extends HashMap<UnderlyingData, FolderTagCounts> { }\n\n    public static class FolderTagCounts {\n        public long totalSize;\n        public int deletedCount, deletedUnreadCount;\n\n        @Override\n        public String toString() {\n            return totalSize + \"/\" + deletedCount + \"/\" + deletedUnreadCount;\n        }\n    }\n\n    public static Mailbox.MailboxData getFoldersAndTags(Mailbox mbox, FolderTagMap folderData, FolderTagMap tagData, boolean reload)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String table = getMailItemTableName(mbox, \"mi\");\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS + \" FROM \" + table +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + FOLDER_AND_TAG_TYPES);\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                MailItem.Type type = MailItem.Type.of(data.type);\n                if (MailItem.isAcceptableType(MailItem.Type.FOLDER, type)) {\n                    folderData.put(data, null);\n                } else if (MailItem.isAcceptableType(MailItem.Type.TAG, type)) {\n                    tagData.put(data, null);\n                }\n\n                rs.getInt(CI_UNREAD);\n                reload |= rs.wasNull();\n            }\n            rs.close();\n\n            for (UnderlyingData data : folderData.keySet()) {\n                if (data.parentId != data.folderId) {\n                    // we had a small folder data inconsistency issue, so resolve it here\n                    //   rather than returning it up to the caller\n                    stmt.close();\n                    stmt = conn.prepareStatement(\"UPDATE \" + table +\n                            \" SET parent_id = folder_id\" +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n                    int pos = 1;\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setInt(pos++, data.id);\n                    stmt.executeUpdate();\n\n                    data.parentId = data.folderId;\n                    ZimbraLog.mailbox.info(\"correcting PARENT_ID column for \" + MailItem.Type.of(data.type) + \" \" + data.id);\n                }\n            }\n\n            if (!reload)\n                return null;\n\n            Map<Integer, UnderlyingData> lookup = new HashMap<Integer, UnderlyingData>(folderData.size() + tagData.size());\n\n            // going to recalculate counts, so discard any existing counts...\n            for (FolderTagMap itemData : new FolderTagMap[] { folderData, tagData }) {\n                for (Map.Entry<UnderlyingData, FolderTagCounts> entry : itemData.entrySet()) {\n                    UnderlyingData data = entry.getKey();\n                    lookup.put(data.id, data);\n                    data.size = data.unreadCount = 0;\n                    entry.setValue(new FolderTagCounts());\n                }\n            }\n\n            rs.close();\n            stmt.close();\n\n            Mailbox.MailboxData mbd = new Mailbox.MailboxData();\n            stmt = conn.prepareStatement(\"SELECT folder_id, type, tags, flags, COUNT(*), SUM(unread), SUM(size)\" +\n                        \" FROM \" + table + \" WHERE \" + IN_THIS_MAILBOX_AND + \"type NOT IN \" + NON_SEARCHABLE_TYPES +\n                        \" GROUP BY folder_id, type, tags, flags\");\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                int folderId = rs.getInt(1);\n                byte type  = rs.getByte(2);\n                long tags  = rs.getLong(3);\n                boolean deleted = (rs.getInt(4) & Flag.BITMASK_DELETED) != 0;\n                int count  = rs.getInt(5);\n                int unread = rs.getInt(6);\n                long size  = rs.getLong(7);\n\n                if (type == MailItem.Type.CONTACT.toByte()) {\n                    mbd.contacts += count;\n                }\n                mbd.size += size;\n\n                UnderlyingData data = lookup.get(folderId);\n                if (data != null) {\n                    data.unreadCount += unread;\n                    data.size += count;\n\n                    FolderTagCounts fcounts = folderData.get(data);\n                    fcounts.totalSize += size;\n                    if (deleted) {\n                        fcounts.deletedCount += count;\n                        fcounts.deletedUnreadCount += unread;\n                    }\n                } else {\n                    ZimbraLog.mailbox.warn(\"inconsistent DB state: items with no corresponding folder (folder ID \" + folderId + \")\");\n                }\n\n                for (int i = 0; tags != 0 && i < MailItem.MAX_TAG_COUNT - 1; i++) {\n                    if ((tags & (1L << i)) != 0) {\n                        data = lookup.get(i + MailItem.TAG_ID_OFFSET);\n                        if (data != null) {\n                            // not keeping track of item counts on tags, just unread counts\n                            data.unreadCount += unread;\n                            if (deleted) {\n                                tagData.get(data).deletedUnreadCount += unread;\n                            }\n                        } else {\n                            ZimbraLog.mailbox.warn(\"inconsistent DB state: items with no corresponding tag (tag ID \" + (i + MailItem.TAG_ID_OFFSET) + \")\");\n                        }\n                        // could track cumulative count if desired...\n                        tags &= ~(1L << i);\n                    }\n                }\n            }\n\n            rs.close();\n            stmt.close();\n\n            stmt = conn.prepareStatement(\"SELECT mi.folder_id, SUM(rev.size)\" +\n                        \" FROM \" + table + \", \" + getRevisionTableName(mbox, \"rev\") +\n                        \" WHERE mi.id = rev.item_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND rev.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\") +\n                        \" GROUP BY folder_id\");\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                int folderId = rs.getInt(1);\n                long size    = rs.getLong(2);\n\n                mbd.size += size;\n\n                UnderlyingData data = lookup.get(folderId);\n                if (data != null) {\n                    folderData.get(data).totalSize += size;\n                } else {\n                    ZimbraLog.mailbox.warn(\"inconsistent DB state: revisions with no corresponding folder (folder ID \" + folderId + \")\");\n                }\n            }\n\n            return mbd;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching folder data for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByType(Mailbox mbox, MailItem.Type type, SortBy sort) throws ServiceException {\n        if (Mailbox.isCachedType(type)) {\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        }\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(mbox, \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + typeIn(type) + DbSearch.orderBy(sort, false));\n            if (type == MailItem.Type.MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            setMailboxId(stmt, mbox, 1);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                result.add(constructItem(rs));\n            }\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n\n            if (type == MailItem.Type.CONVERSATION) {\n                completeConversations(mbox, result);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items of type \" + type, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent) throws ServiceException {\n        return getByParent(parent, SortBy.DATE_DESC, false);\n    }\n\n    public static List<UnderlyingData> getByParent(MailItem parent, SortBy sort, boolean fromDumpster) throws ServiceException {\n        Mailbox mbox = parent.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(parent.getMailbox(), \" mi\", fromDumpster) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"parent_id = ? \" + DbSearch.orderBy(sort, false));\n            if (parent.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, parent.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs, fromDumpster);\n                if (Mailbox.isCachedType(MailItem.Type.of(data.type))) {\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                }\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching children of item \" + parent.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getUnreadMessages(MailItem relativeTo) throws ServiceException {\n        Mailbox mbox = relativeTo.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String relation;\n            if (relativeTo instanceof VirtualConversation) {\n                relation = \"id = ?\";\n            } else if (relativeTo instanceof Conversation) {\n                relation = \"parent_id = ?\";\n            } else if (relativeTo instanceof Folder) {\n                relation = \"folder_id = ?\";\n            } else if (relativeTo instanceof Flag) {\n                relation = Db.getInstance().bitAND(\"flags\", \"?\") + \" <> 0\";\n            } else if (relativeTo instanceof Tag) {\n                relation = Db.getInstance().bitAND(\"tags\", \"?\") + \" <> 0\";\n            } else {\n                relation = \"id = ?\";\n            }\n\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(relativeTo.getMailbox(), \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"unread > 0 AND \" + relation + \" AND type NOT IN \" + NON_SEARCHABLE_TYPES);\n            if (relativeTo.getUnreadCount() > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (relativeTo instanceof Tag) {\n                stmt.setLong(pos++, ((Tag) relativeTo).getBitmask());\n            } else if (relativeTo instanceof VirtualConversation) {\n                stmt.setInt(pos++, ((VirtualConversation) relativeTo).getMessageId());\n            } else {\n                stmt.setInt(pos++, relativeTo.getId());\n            }\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (Mailbox.isCachedType(MailItem.Type.of(data.type))) {\n                    throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                }\n                result.add(data);\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching unread messages for item \" + relativeTo.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getByFolder(Folder folder, MailItem.Type type, SortBy sort)\n            throws ServiceException {\n        if (Mailbox.isCachedType(type)) {\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        }\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND \" + typeIn(type) +\n                    DbSearch.orderBy(sort, false));\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS && type == MailItem.Type.MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching items in folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getById(Mailbox mbox, int id, MailItem.Type type, boolean fromDumpster)\n            throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\", fromDumpster) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, id);\n            rs = stmt.executeQuery();\n\n            if (!rs.next()) {\n                throw MailItem.noSuchItem(id, type);\n            }\n            UnderlyingData data = constructItem(rs, fromDumpster);\n            if (!MailItem.isAcceptableType(type, MailItem.Type.of(data.type))) {\n                throw MailItem.noSuchItem(id, type);\n            }\n            if (!fromDumpster && data.type == MailItem.Type.CONVERSATION.toByte()) {\n                completeConversation(mbox, data);\n            }\n            return data;\n        } catch (SQLException e) {\n            if (!fromDumpster)\n                throw ServiceException.FAILURE(\"fetching item \" + id, e);\n            else\n                throw ServiceException.FAILURE(\"fetching item \" + id + \" from dumpster\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByImapId(Mailbox mbox, int imapId, int folderId) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND imap_id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, imapId);\n            rs = stmt.executeQuery();\n\n            if (!rs.next()) {\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            }\n            UnderlyingData data = constructItem(rs);\n            if (data.type == MailItem.Type.CONVERSATION.toByte()) {\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            }\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + imapId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getById(Mailbox mbox, Collection<Integer> ids, MailItem.Type type)\n            throws ServiceException {\n        if (Mailbox.isCachedType(type))\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n        if (ids.isEmpty())\n            return result;\n        List<UnderlyingData> conversations = new ArrayList<UnderlyingData>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        Iterator<Integer> it = ids.iterator();\n        for (int i = 0; i < ids.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), ids.size() - i);\n                stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                            \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"id\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, it.next());\n\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    UnderlyingData data = constructItem(rs);\n                    MailItem.Type resultType = MailItem.Type.of(data.type);\n                    if (!MailItem.isAcceptableType(type, resultType)) {\n                        throw MailItem.noSuchItem(data.id, type);\n                    } else if (Mailbox.isCachedType(resultType)) {\n                        throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n                    }\n                    if (resultType == MailItem.Type.CONVERSATION) {\n                        conversations.add(data);\n                    }\n                    result.add(data);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"fetching \" + ids.size() + \" items: \" + getIdListForLogging(ids), e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n        }\n\n        if (!conversations.isEmpty())\n            completeConversations(mbox, conversations);\n        return result;\n    }\n\n    public static UnderlyingData getByName(Mailbox mbox, int folderId, String name, MailItem.Type type)\n    throws ServiceException {\n        if (Mailbox.isCachedType(type)) {\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        }\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND \" + typeIn(type) +\n                        \" AND \" + Db.equalsSTRING(\"name\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            stmt.setString(pos++, name);\n            rs = stmt.executeQuery();\n\n            if (!rs.next()) {\n                throw MailItem.noSuchItem(-1, type);\n            }\n            UnderlyingData data = constructItem(rs);\n            MailItem.Type resultType = MailItem.Type.of(data.type);\n            if (!MailItem.isAcceptableType(type, resultType)) {\n                throw MailItem.noSuchItem(data.id, type);\n            }\n            if (resultType == MailItem.Type.CONVERSATION) {\n                completeConversation(mbox, data);\n            }\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item by name ('\" + name + \"' in folder \" + folderId + \")\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static UnderlyingData getByHash(Mailbox mbox, String hash) throws ServiceException {\n        return ListUtil.getFirstElement(getByHashes(mbox, Arrays.asList(hash)));\n    }\n\n    public static List<UnderlyingData> getByHashes(Mailbox mbox, List<String> hashes) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        if (ListUtil.isEmpty(hashes))\n            return null;\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS + \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"mi.id IN\" +\n                    \" (SELECT DISTINCT conv_id FROM \" + getConversationTableName(mbox, \"oc\") +\n                    \"  WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"oc.hash\", hashes.size()) + \")\");\n            int pos = setMailboxId(stmt, mbox, 1);\n            pos = setMailboxId(stmt, mbox, pos);\n            for (String hash : hashes) {\n                stmt.setString(pos++, hash);\n            }\n            rs = stmt.executeQuery();\n\n            List<UnderlyingData> dlist = new ArrayList<UnderlyingData>(3);\n            while (rs.next()) {\n                UnderlyingData data = constructItem(rs);\n                if (data.type == MailItem.Type.CONVERSATION.toByte()) {\n                    completeConversation(mbox, data);\n                }\n                dlist.add(data);\n            }\n            return dlist.isEmpty() ? null : dlist;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching conversation for hash \" + hashes, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static Pair<List<Integer>,TypedIdList> getModifiedItems(Mailbox mbox, MailItem.Type type, long lastSync,\n            Set<Integer> visible) throws ServiceException {\n        if (Mailbox.isCachedType(type)) {\n            throw ServiceException.INVALID_REQUEST(\"folders and tags must be retrieved from cache\", null);\n        }\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<Integer> modified = new ArrayList<Integer>();\n        TypedIdList missed = new TypedIdList();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = type == MailItem.Type.UNKNOWN ? \"type NOT IN \" + NON_SEARCHABLE_TYPES : typeIn(type);\n            stmt = conn.prepareStatement(\"SELECT id, type, folder_id\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"mod_metadata > ? AND \" + typeConstraint +\n                        \" ORDER BY mod_metadata, id\");\n            if (type == MailItem.Type.MESSAGE) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setLong(pos++, lastSync);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                if (visible == null || visible.contains(rs.getInt(3)))\n                    modified.add(rs.getInt(1));\n                else\n                    missed.add(MailItem.Type.of(rs.getByte(2)), rs.getInt(1));\n            }\n\n            return new Pair<List<Integer>,TypedIdList>(modified, missed);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting items modified since \" + lastSync, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void completeConversation(Mailbox mbox, UnderlyingData data) throws ServiceException {\n        completeConversations(mbox, Arrays.asList(data));\n    }\n\n    private static void completeConversations(Mailbox mbox, List<UnderlyingData> convData) throws ServiceException {\n        if (convData == null || convData.isEmpty()) {\n            return;\n        }\n        for (UnderlyingData data : convData) {\n            if (data.type != MailItem.Type.CONVERSATION.toByte()) {\n                throw ServiceException.FAILURE(\"attempting to complete a non-conversation\", null);\n            }\n        }\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        Map<Integer, UnderlyingData> conversations = new HashMap<Integer, UnderlyingData>(Db.getINClauseBatchSize() * 3 / 2);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        for (int i = 0; i < convData.size(); i += Db.getINClauseBatchSize()) {\n            try {\n                int count = Math.min(Db.getINClauseBatchSize(), convData.size() - i);\n                stmt = conn.prepareStatement(\"SELECT parent_id, unread, flags, tags\" +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"parent_id\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++) {\n                    UnderlyingData data = convData.get(index);\n                    stmt.setInt(pos++, data.id);\n                    conversations.put(data.id, data);\n                    // don't assume that the UnderlyingData structure was new...\n                    data.tags = data.unreadCount = 0;\n                    data.setFlags(0);\n                }\n                rs = stmt.executeQuery();\n\n                while (rs.next()) {\n                    UnderlyingData data = conversations.get(rs.getInt(1));\n                    assert(data != null);\n                    data.unreadCount += rs.getInt(2);\n                    data.setFlags(data.getFlags() | rs.getInt(3));\n                    data.tags        |= rs.getLong(4);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"completing conversation data\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n            }\n\n            conversations.clear();\n        }\n    }\n\n    private static final String LEAF_NODE_FIELDS = \"id, size, type, unread, folder_id, parent_id, blob_digest,\" +\n                                                   \" mod_content, mod_metadata, flags, index_id, volume_id\";\n\n    private static final int LEAF_CI_ID           = 1;\n    private static final int LEAF_CI_SIZE         = 2;\n    private static final int LEAF_CI_TYPE         = 3;\n    private static final int LEAF_CI_IS_UNREAD    = 4;\n    private static final int LEAF_CI_FOLDER_ID    = 5;\n    private static final int LEAF_CI_PARENT_ID    = 6;\n    private static final int LEAF_CI_BLOB_DIGEST  = 7;\n    private static final int LEAF_CI_MOD_CONTENT  = 8;\n    private static final int LEAF_CI_MOD_METADATA = 9;\n    private static final int LEAF_CI_FLAGS        = 10;\n    private static final int LEAF_CI_INDEX_ID     = 11;\n    private static final int LEAF_CI_VOLUME_ID    = 12;\n\n    public static PendingDelete getLeafNodes(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n        int folderId = folder.getId();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type NOT IN \" + FOLDER_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folderId);\n            rs = stmt.executeQuery();\n\n            info.rootId = folderId;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n\n            // make sure that the folder is in the list of deleted item ids\n            info.itemIds.add(folder.getType(), folderId);\n\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items within item \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static PendingDelete getLeafNodes(Mailbox mbox, List<Folder> folders, int before, boolean globalMessages,\n                                             Boolean unread, boolean useChangeDate, Integer maxItems)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String constraint;\n            String dateColumn = (useChangeDate ? \"change_date\" : \"date\");\n            if (globalMessages) {\n                constraint = dateColumn + \" < ? AND \" + typeIn(MailItem.Type.MESSAGE);\n            } else {\n                constraint = dateColumn + \" < ? AND type NOT IN \" + NON_SEARCHABLE_TYPES +\n                             \" AND \" + DbUtil.whereIn(\"folder_id\", folders.size());\n            }\n            if (unread != null) {\n                constraint += \" AND unread = ?\";\n            }\n            String orderByLimit = \"\";\n            if (maxItems != null && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                orderByLimit = \" ORDER BY \" + dateColumn + \" LIMIT \" + maxItems;\n            }\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + constraint + orderByLimit);\n            if (globalMessages || getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, before);\n            if (!globalMessages) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            if (unread != null)\n                stmt.setBoolean(pos++, unread);\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static int getTotalFolderSize(Collection<Folder> folders) {\n        int totalSize = 0;\n        if (folders != null) {\n            for (Folder folder : folders) {\n                totalSize += folder.getSize();\n            }\n        }\n        return totalSize;\n    }\n\n    public static PendingDelete getImapDeleted(Mailbox mbox, Set<Folder> folders) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PendingDelete info = new PendingDelete();\n        if (folders != null && folders.isEmpty())\n            return info;\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // figure out the set of FLAGS bitmasks containing the \\Deleted flag\n            Set<Long> flagsets = getFlagsetCache(conn, mbox).getMatchingTagsets(Flag.BITMASK_DELETED, Flag.BITMASK_DELETED);\n            if (flagsets != null && flagsets.isEmpty())\n                return info;\n\n            String flagconstraint = flagsets == null ? \"\" : \" AND \" + DbUtil.whereIn(\"flags\", flagsets.size());\n            String folderconstraint = folders == null ? \"\" : \" AND \" + DbUtil.whereIn(\"folder_id\", folders.size());\n\n            stmt = conn.prepareStatement(\"SELECT \" + LEAF_NODE_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"type IN \" + IMAP_TYPES + flagconstraint + folderconstraint);\n            if (getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS)\n                Db.getInstance().enableStreaming(stmt);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (flagsets != null) {\n                for (long flags : flagsets)\n                    stmt.setInt(pos++, (int) flags);\n            }\n            if (folders != null) {\n                for (Folder folder : folders)\n                    stmt.setInt(pos++, folder.getId());\n            }\n            rs = stmt.executeQuery();\n\n            info.rootId = 0;\n            info.size   = 0;\n            List<Integer> versionedIds = accumulateLeafNodes(info, mbox, rs);\n            rs.close(); rs = null;\n            stmt.close(); stmt = null;\n            accumulateLeafRevisions(info, mbox, versionedIds);\n            return info;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching list of \\\\Deleted items for purge\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class LocationCount {\n        public int count;\n        public int deleted;\n        public long size;\n        public LocationCount(int c, int d, long sz)            { count = c;  deleted += d;  size = sz; }\n        public LocationCount(LocationCount lc)                 { count = lc.count;  deleted = lc.deleted;  size = lc.size; }\n        public LocationCount increment(int c, int d, long sz)  { count += c;  deleted += d;  size += sz;  return this; }\n        public LocationCount increment(LocationCount lc)       { count += lc.count;  deleted += lc.deleted;  size += lc.size;  return this; }\n    }\n\n    /**\n     * Accumulates <tt>PendingDelete</tt> info for the given <tt>ResultSet</tt>.\n     * @return a <tt>List</tt> of all versioned items, to be used in a subsequent call to\n     * {@link DbMailItem#accumulateLeafRevisions}, or an empty list.\n     */\n    private static List<Integer> accumulateLeafNodes(PendingDelete info, Mailbox mbox, ResultSet rs) throws SQLException, ServiceException {\n        boolean dumpsterEnabled = mbox.dumpsterEnabled();\n        boolean useDumpsterForSpam = mbox.useDumpsterForSpam();\n        StoreManager sm = StoreManager.getInstance();\n        List<Integer> versioned = new ArrayList<Integer>();\n\n        while (rs.next()) {\n            // first check to make sure we don't have a modify conflict\n            int revision = rs.getInt(LEAF_CI_MOD_CONTENT);\n            int modMetadata = rs.getInt(LEAF_CI_MOD_METADATA);\n            if (!mbox.checkItemChangeID(modMetadata, revision)) {\n                info.incomplete = true;\n                continue;\n            }\n\n            int id = rs.getInt(LEAF_CI_ID);\n            long size = rs.getLong(LEAF_CI_SIZE);\n            MailItem.Type type = MailItem.Type.of(rs.getByte(LEAF_CI_TYPE));\n\n            Integer item = new Integer(id);\n            info.itemIds.add(type, item);\n            info.size += size;\n\n            if (rs.getBoolean(LEAF_CI_IS_UNREAD)) {\n                info.unreadIds.add(item);\n            }\n            boolean isMessage = false;\n            switch (type) {\n            case CONTACT:\n                info.contacts++;\n                break;\n            case CHAT:\n            case MESSAGE:\n                isMessage = true;\n                break;\n            }\n\n            // record deleted virtual conversations and modified-or-deleted real conversations\n            if (isMessage) {\n                int parentId = rs.getInt(LEAF_CI_PARENT_ID);\n                if (rs.wasNull() || parentId <= 0) {\n                    info.itemIds.add(MailItem.Type.VIRTUAL_CONVERSATION, -id);\n                } else {\n                    info.modifiedIds.add(parentId);\n                }\n            }\n\n            int flags = rs.getInt(LEAF_CI_FLAGS);\n            if ((flags & Flag.BITMASK_VERSIONED) != 0)\n                versioned.add(id);\n\n            Integer folderId = rs.getInt(LEAF_CI_FOLDER_ID);\n            boolean isDeleted = (flags & Flag.BITMASK_DELETED) != 0;\n            LocationCount count = info.messages.get(folderId);\n            if (count == null)\n                info.messages.put(folderId, new LocationCount(1, isDeleted ? 1 : 0, size));\n            else\n                count.increment(1, isDeleted ? 1 : 0, size);\n\n            int fid = folderId != null ? folderId.intValue() : -1;\n            if (!dumpsterEnabled || fid == Mailbox.ID_FOLDER_DRAFTS || (fid == Mailbox.ID_FOLDER_SPAM && !useDumpsterForSpam)) {\n                String blobDigest = rs.getString(LEAF_CI_BLOB_DIGEST);\n                if (blobDigest != null) {\n                    info.blobDigests.add(blobDigest);\n                    String locator = rs.getString(LEAF_CI_VOLUME_ID);\n                    try {\n                        MailboxBlob mblob = sm.getMailboxBlob(mbox, id, revision, locator);\n                        if (mblob == null)\n                            sLog.warn(\"missing blob for id: \" + id + \", change: \" + revision);\n                        else\n                            info.blobs.add(mblob);\n                    } catch (Exception e1) { }\n                }\n\n                int indexId = rs.getInt(LEAF_CI_INDEX_ID);\n                boolean indexed = !rs.wasNull();\n                if (indexed) {\n                    if (info.sharedIndex == null)\n                        info.sharedIndex = new HashSet<Integer>();\n                    boolean shared = (flags & Flag.BITMASK_COPIED) != 0;\n                    if (shared) {\n                        info.sharedIndex.add(indexId);\n                    } else {\n                        info.indexIds.add(indexId > MailItem.IndexStatus.STALE.id() ? indexId : id);\n                    }\n                }\n            }\n        }\n        return versioned;\n    }\n\n    private static void accumulateLeafRevisions(PendingDelete info, Mailbox mbox, List<Integer> versioned) throws ServiceException {\n        if (versioned == null || versioned.size() == 0) {\n            return;\n        }\n        boolean dumpsterEnabled = mbox.dumpsterEnabled();\n        boolean useDumpsterForSpam = mbox.useDumpsterForSpam();\n        DbConnection conn = mbox.getOperationConnection();\n        StoreManager sm = StoreManager.getInstance();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.id, mi.folder_id, rev.size, rev.mod_content, rev.volume_id, rev.blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getRevisionTableName(mbox, \"rev\") +\n                    \" WHERE mi.id = rev.item_id AND \" + DbUtil.whereIn(\"mi.id\", versioned.size()) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? AND mi.mailbox_id = rev.mailbox_id\"));\n            int pos = 1;\n            for (int vid : versioned)\n                stmt.setInt(pos++, vid);\n            pos = setMailboxId(stmt, mbox, pos);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                Integer folderId = rs.getInt(2);\n                LocationCount count = info.messages.get(folderId);\n                if (count == null)\n                    info.messages.put(folderId, new LocationCount(0, 0, rs.getLong(3)));\n                else\n                    count.increment(0, 0, rs.getLong(3));\n\n                int fid = folderId != null ? folderId.intValue() : -1;\n                if (!dumpsterEnabled || fid == Mailbox.ID_FOLDER_DRAFTS || (fid == Mailbox.ID_FOLDER_SPAM && !useDumpsterForSpam)) {\n                    String blobDigest = rs.getString(6);\n                    if (blobDigest != null) {\n                        info.blobDigests.add(blobDigest);\n                        try {\n                            MailboxBlob mblob = sm.getMailboxBlob(mbox, rs.getInt(1), rs.getInt(4), rs.getString(5));\n                            if (mblob == null)\n                                sLog.error(\"missing blob for id: \" + rs.getInt(1) + \", change: \" + rs.getInt(4));\n                            else\n                                info.blobs.add(mblob);\n                        } catch (Exception e1) { }\n                    }\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting version deletion info for items: \" + versioned, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Returns the blob digest for the item with the given id, or <tt>null</tt>\n     * if either the id doesn't exist in the table or there is no associated blob.\n     */\n    public static String getBlobDigest(Mailbox mbox, int itemId) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT blob_digest \" +\n                    \" FROM \" + getMailItemTableName(mbox) +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, itemId);\n            rs = stmt.executeQuery();\n\n            return rs.next() ? rs.getString(1) : null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"unable to get blob digest for id \" + itemId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void resolveSharedIndex(Mailbox mbox, PendingDelete info) throws ServiceException {\n        if (info.sharedIndex == null || info.sharedIndex.isEmpty())\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<Integer> indexIDs = new ArrayList<Integer>(info.sharedIndex);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            for (int i = 0; i < indexIDs.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), indexIDs.size() - i);\n                stmt = conn.prepareStatement(\"SELECT index_id FROM \" + getMailItemTableName(mbox) +\n                            \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"index_id\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setInt(pos++, indexIDs.get(index));\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    info.sharedIndex.remove(rs.getInt(1));\n                }\n                rs.close(); rs = null;\n                stmt.close(); stmt = null;\n            }\n\n            info.indexIds.addAll(info.sharedIndex);\n            info.sharedIndex.clear();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"resolving shared index entries: \" + info.rootId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    private static final String IMAP_FIELDS = \"mi.id, mi.type, mi.imap_id, mi.unread, mi.flags, mi.tags\";\n    private static final String IMAP_TYPES = \"(\" +\n        MailItem.Type.MESSAGE.toByte() + \",\" +\n        MailItem.Type.CHAT.toByte() + ',' +\n        MailItem.Type.CONTACT.toByte() + \")\";\n\n    public static List<ImapMessage> loadImapFolder(Folder folder) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<ImapMessage> result = new ArrayList<ImapMessage>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + IMAP_FIELDS +\n                        \" FROM \" + getMailItemTableName(folder.getMailbox(), \" mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES);\n            if (folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                int flags = rs.getBoolean(4) ? Flag.BITMASK_UNREAD | rs.getInt(5) : rs.getInt(5);\n                result.add(new ImapMessage(rs.getInt(1), MailItem.Type.of(rs.getByte(2)), rs.getInt(3), flags, rs.getLong(6)));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading IMAP folder data: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static int countImapRecent(Folder folder, int uidCutoff) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + getMailItemTableName(folder.getMailbox()) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ? AND type IN \" + IMAP_TYPES +\n                        \" AND (imap_id IS NULL OR imap_id = 0 OR imap_id > ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            stmt.setInt(pos++, uidCutoff);\n            rs = stmt.executeQuery();\n\n            return (rs.next() ? rs.getInt(1) : 0);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"counting IMAP \\\\Recent messages: \" + folder.getPath(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<Pop3Message> loadPop3Folder(Set<Folder> folders, Date popSince) throws ServiceException {\n        assert !folders.isEmpty() : folders;\n        Mailbox mbox = Iterables.get(folders, 0).getMailbox();\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long popDate = popSince == null ? -1 : Math.max(popSince.getTime(), -1);\n        List<Pop3Message> result = new ArrayList<Pop3Message>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String dateConstraint = popDate < 0 ? \"\" : \" AND date > ?\";\n            stmt = conn.prepareStatement(\n                    \"SELECT mi.id, mi.size, mi.blob_digest FROM \" + getMailItemTableName(mbox, \" mi\") +\n                    \" WHERE \" + IN_THIS_MAILBOX_AND + DbUtil.whereIn(\"folder_id\", folders.size()) +\n                    \" AND type = \" + MailItem.Type.MESSAGE.toByte() + \" AND \" +\n                    Db.getInstance().bitAND(\"flags\", String.valueOf(Flag.BITMASK_DELETED | Flag.BITMASK_POPPED)) +\n                    \" = 0\" + dateConstraint);\n            if (getTotalFolderSize(folders) > RESULTS_STREAMING_MIN_ROWS) {\n                //TODO: Because of POPPED flag, the folder size no longer represent the count.\n                Db.getInstance().enableStreaming(stmt);\n            }\n\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            for (Folder folder : folders) {\n                stmt.setInt(pos++, folder.getId());\n            }\n            if (popDate >= 0) {\n                stmt.setInt(pos++, (int) (popDate / 1000L));\n            }\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                result.add(new Pop3Message(rs.getInt(1), rs.getLong(2), rs.getString(3)));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"loading POP3 folder data: \" + folders, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getRevisionInfo(MailItem item, boolean fromDumpster) throws ServiceException {\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        List<UnderlyingData> dlist = new ArrayList<UnderlyingData>();\n        if (!item.isTagged(Flag.ID_VERSIONED)) {\n            return dlist;\n        }\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + REVISION_FIELDS + \" FROM \" + getRevisionTableName(mbox, fromDumpster) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"item_id = ?\" +\n                        \" ORDER BY version\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                dlist.add(constructRevision(rs, item, fromDumpster));\n            return dlist;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting old revisions for item: \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<Integer> listByFolder(Folder folder, MailItem.Type type, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean allTypes = type == MailItem.Type.UNKNOWN;\n        List<Integer> result = new ArrayList<Integer>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            if (type == MailItem.Type.MESSAGE && folder.getSize() > RESULTS_STREAMING_MIN_ROWS) {\n                Db.getInstance().enableStreaming(stmt);\n            }\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (!allTypes) {\n                stmt.setByte(pos++, type.toByte());\n            }\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList listByFolder(Folder folder, boolean descending) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        TypedIdList result = new TypedIdList();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT id, type FROM \" + getMailItemTableName(folder) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"folder_id = ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                result.add(MailItem.Type.of(rs.getByte(2)), rs.getInt(1));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item list for folder \" + folder.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // these columns are specified by DB_FIELDS, below\n    public static final int CI_ID          = 1;\n    public static final int CI_TYPE        = 2;\n    public static final int CI_PARENT_ID   = 3;\n    public static final int CI_FOLDER_ID   = 4;\n    public static final int CI_INDEX_ID    = 5;\n    public static final int CI_IMAP_ID     = 6;\n    public static final int CI_DATE        = 7;\n    public static final int CI_SIZE        = 8;\n    public static final int CI_VOLUME_ID   = 9;\n    public static final int CI_BLOB_DIGEST = 10;\n    public static final int CI_UNREAD      = 11;\n    public static final int CI_FLAGS       = 12;\n    public static final int CI_TAGS        = 13;\n    public static final int CI_SUBJECT     = 14;\n    public static final int CI_NAME        = 15;\n    public static final int CI_METADATA    = 16;\n    public static final int CI_MODIFIED    = 17;\n    public static final int CI_MODIFY_DATE = 18;\n    public static final int CI_SAVED       = 19;\n\n    static final String DB_FIELDS = \"mi.id, mi.type, mi.parent_id, mi.folder_id, mi.index_id, mi.imap_id, mi.date, \" +\n        \"mi.size, mi.volume_id, mi.blob_digest, mi.unread, mi.flags, mi.tags, mi.subject, mi.name, \" +\n        \"mi.metadata, mi.mod_metadata, mi.change_date, mi.mod_content\";\n\n    private static UnderlyingData constructItem(ResultSet rs) throws SQLException, ServiceException {\n        return constructItem(rs, 0, false);\n    }\n\n    private static UnderlyingData constructItem(ResultSet rs, boolean fromDumpster) throws SQLException, ServiceException {\n        return constructItem(rs, 0, fromDumpster);\n    }\n\n    static UnderlyingData constructItem(ResultSet rs, int offset) throws SQLException, ServiceException {\n        return constructItem(rs, offset, false);\n    }\n\n    static UnderlyingData constructItem(ResultSet rs, int offset, boolean fromDumpster) throws SQLException, ServiceException {\n        UnderlyingData data = new UnderlyingData();\n        data.id = rs.getInt(CI_ID + offset);\n        data.type = rs.getByte(CI_TYPE + offset);\n        data.parentId = rs.getInt(CI_PARENT_ID + offset);\n        data.folderId = rs.getInt(CI_FOLDER_ID + offset);\n        data.indexId = rs.getInt(CI_INDEX_ID + offset);\n        if (rs.wasNull()) {\n            data.indexId = MailItem.IndexStatus.NO.id();\n        }\n        data.imapId = rs.getInt(CI_IMAP_ID + offset);\n        if (rs.wasNull()) {\n            data.imapId = -1;\n        }\n        data.date = rs.getInt(CI_DATE + offset);\n        data.size = rs.getLong(CI_SIZE + offset);\n        data.locator = rs.getString(CI_VOLUME_ID + offset);\n        data.setBlobDigest(rs.getString(CI_BLOB_DIGEST + offset));\n        data.unreadCount = rs.getInt(CI_UNREAD + offset);\n        int flags = rs.getInt(CI_FLAGS + offset);\n        if (!fromDumpster) {\n            data.setFlags(flags);\n        } else {\n            data.setFlags(flags | Flag.BITMASK_UNCACHED | Flag.BITMASK_IN_DUMPSTER);\n        }\n        data.tags = rs.getLong(CI_TAGS + offset);\n        data.setSubject(rs.getString(CI_SUBJECT + offset));\n        data.name = rs.getString(CI_NAME + offset);\n        data.metadata = decodeMetadata(rs.getString(CI_METADATA + offset));\n        data.modMetadata = rs.getInt(CI_MODIFIED + offset);\n        data.modContent = rs.getInt(CI_SAVED + offset);\n        data.dateChanged = rs.getInt(CI_MODIFY_DATE + offset);\n        // make sure to handle NULL column values\n        if (data.parentId == 0) {\n            data.parentId = -1;\n        }\n        if (data.dateChanged == 0) {\n            data.dateChanged = -1;\n        }\n        return data;\n    }\n\n    private static final String REVISION_FIELDS = \"date, size, volume_id, blob_digest, name, \" +\n                                                  \"metadata, mod_metadata, change_date, mod_content\";\n\n    private static UnderlyingData constructRevision(ResultSet rs, MailItem item, boolean fromDumpster) throws SQLException, ServiceException {\n        UnderlyingData data = new UnderlyingData();\n        data.id          = item.getId();\n        data.type        = item.getType().toByte();\n        data.parentId    = item.getParentId();\n        data.folderId    = item.getFolderId();\n        data.indexId = MailItem.IndexStatus.NO.id();\n        data.imapId      = -1;\n        data.date        = rs.getInt(1);\n        data.size        = rs.getLong(2);\n        data.locator    = rs.getString(3);\n        data.setBlobDigest(rs.getString(4));\n        data.unreadCount = item.getUnreadCount();\n        if (!fromDumpster) {\n            data.setFlags(item.getInternalFlagBitmask() | Flag.BITMASK_UNCACHED);\n        } else {\n            data.setFlags(item.getInternalFlagBitmask() | Flag.BITMASK_UNCACHED | Flag.BITMASK_IN_DUMPSTER);\n        }\n        data.tags        = item.getTagBitmask();\n        data.setSubject(item.getSubject());\n        data.name        = rs.getString(5);\n        data.metadata    = decodeMetadata(rs.getString(6));\n        data.modMetadata = rs.getInt(7);\n        data.dateChanged = rs.getInt(8);\n        data.modContent  = rs.getInt(9);\n        // make sure to handle NULL column values\n        if (data.parentId <= 0)     data.parentId = -1;\n        if (data.dateChanged == 0)  data.dateChanged = -1;\n        return data;\n    }\n\n    //////////////////////////////////////\n    // CALENDAR STUFF BELOW HERE!\n    //////////////////////////////////////\n\n    public static UnderlyingData getCalendarItem(Mailbox mbox, String uid) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                    \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                    \" WHERE ci.uid = ? AND mi.id = ci.item_id AND mi.type IN \" + CALENDAR_TYPES +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\"));\n\n            int pos = 1;\n            stmt.setString(pos++, uid);\n            pos = setMailboxId(stmt, mbox, pos);\n            rs = stmt.executeQuery();\n\n            if (rs.next())\n                return constructItem(rs);\n            return null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Return all of the Invite records within the range start&lt;=Invites&lt;end.  IE \"Give me all the\n     * invites between 7:00 and 9:00\" will return you everything from 7:00 to 8:59:59.99\n     * @param start\n     * @param end\n     * @param folderId\n     * @return list of invites\n     */\n    public static List<UnderlyingData> getCalendarItems(Mailbox mbox, MailItem.Type type, long start, long end,\n            int folderId, int[] excludeFolderIds) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, DB_FIELDS, mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n            while (rs.next())\n                result.add(constructItem(rs));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<UnderlyingData> getCalendarItems(Mailbox mbox, List<String> uids) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        List<UnderlyingData> result = new ArrayList<UnderlyingData>();\n        try {\n            for (int i = 0; i < uids.size(); i += Db.getINClauseBatchSize()) {\n                int count = Math.min(Db.getINClauseBatchSize(), uids.size() - i);\n                stmt = conn.prepareStatement(\"SELECT \" + DB_FIELDS +\n                        \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE mi.id = ci.item_id AND mi.type IN \" + CALENDAR_TYPES +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\") +\n                        \" AND \" + DbUtil.whereIn(\"ci.uid\", count));\n                int pos = 1;\n                pos = setMailboxId(stmt, mbox, pos);\n                for (int index = i; index < i + count; index++)\n                    stmt.setString(pos++, uids.get(index));\n                rs = stmt.executeQuery();\n                while (rs.next())\n                    result.add(constructItem(rs));\n                stmt.close();\n                stmt = null;\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static TypedIdList listCalendarItems(Mailbox mbox, MailItem.Type type, long start, long end, int folderId,\n            int[] excludeFolderIds) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = calendarItemStatement(conn, \"mi.id, mi.type\", mbox, type, start, end, folderId, excludeFolderIds);\n            rs = stmt.executeQuery();\n\n            TypedIdList result = new TypedIdList();\n            while (rs.next()) {\n                result.add(MailItem.Type.of(rs.getByte(2)), rs.getInt(1));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"listing calendar items for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static PreparedStatement calendarItemStatement(DbConnection conn, String fields,\n            Mailbox mbox, MailItem.Type type, long start, long end, int folderId, int[] excludeFolderIds)\n            throws SQLException {\n        boolean folderSpecified = folderId != Mailbox.ID_AUTO_INCREMENT;\n\n        String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n        String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n        String typeConstraint = type == MailItem.Type.UNKNOWN ? \"type IN \" + CALENDAR_TYPES : typeIn(type);\n\n        String excludeFolderPart = \"\";\n        if (excludeFolderIds != null && excludeFolderIds.length > 0)\n            excludeFolderPart = \" AND \" + DbUtil.whereNotIn(\"folder_id\", excludeFolderIds.length);\n\n        PreparedStatement stmt = conn.prepareStatement(\"SELECT \" + fields +\n                \" FROM \" + getCalendarItemTableName(mbox, \"ci\") + \", \" + getMailItemTableName(mbox, \"mi\") +\n                \" WHERE mi.id = ci.item_id\" + endConstraint + startConstraint + \" AND mi.\" + typeConstraint +\n                (DebugConfig.disableMailboxGroups? \"\" : \" AND ci.mailbox_id = ? AND mi.mailbox_id = ci.mailbox_id\") +\n                (folderSpecified ? \" AND folder_id = ?\" : \"\") + excludeFolderPart);\n\n        int pos = 1;\n        if (end > 0)\n            stmt.setTimestamp(pos++, new Timestamp(end));\n        if (start > 0)\n            stmt.setTimestamp(pos++, new Timestamp(start));\n        pos = setMailboxId(stmt, mbox, pos);\n        if (folderSpecified)\n            stmt.setInt(pos++, folderId);\n        if (excludeFolderIds != null) {\n            for (int id : excludeFolderIds)\n                stmt.setInt(pos++, id);\n        }\n\n        return stmt;\n    }\n\n    public static List<Integer> getItemListByDates(Mailbox mbox, MailItem.Type type, long start, long end, int folderId,\n            boolean descending) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean allTypes = type == MailItem.Type.UNKNOWN;\n        List<Integer> result = new ArrayList<Integer>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String typeConstraint = allTypes ? \"\" : \"type = ? AND \";\n            stmt = conn.prepareStatement(\"SELECT id FROM \" + getMailItemTableName(mbox) +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + typeConstraint + \"folder_id = ?\" +\n                        \" AND date > ? AND date < ?\" +\n                        \" ORDER BY date\" + (descending ? \" DESC\" : \"\"));\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (!allTypes) {\n                stmt.setByte(pos++, type.toByte());\n            }\n            stmt.setInt(pos++, folderId);\n            stmt.setInt(pos++, (int)(start / 1000));\n            stmt.setInt(pos++, (int)(end / 1000));\n\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                result.add(rs.getInt(1));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"finding items between dates\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class QueryParams {\n        private SortedSet<Integer> mFolderIds = new TreeSet<Integer>();\n        private Long mChangeDateBefore;\n        private Integer mModifiedSequenceBefore;\n        private Integer mRowLimit;\n        private Set<MailItem.Type> includedTypes = EnumSet.noneOf(MailItem.Type.class);\n        private Set<MailItem.Type> excludedTypes = EnumSet.noneOf(MailItem.Type.class);\n\n        public SortedSet<Integer> getFolderIds() {\n            return Collections.unmodifiableSortedSet(mFolderIds);\n        }\n\n        public QueryParams setFolderIds(Collection<Integer> ids) {\n            mFolderIds.clear();\n            if (ids != null) {\n                mFolderIds.addAll(ids);\n            }\n            return this;\n        }\n\n        public Set<MailItem.Type> getIncludedTypes() {\n            return Collections.unmodifiableSet(includedTypes);\n        }\n\n        public QueryParams setIncludedTypes(Set<MailItem.Type> types) {\n            includedTypes.clear();\n            includedTypes.addAll(types);\n            return this;\n        }\n\n        public Set<MailItem.Type> getExcludedTypes() {\n            return Collections.unmodifiableSet(excludedTypes);\n        }\n\n        public QueryParams setExcludedTypes(Set<MailItem.Type> types) {\n            excludedTypes.clear();\n            excludedTypes.addAll(types);\n            return this;\n        }\n\n        /**\n         * @return the timestamp, in seconds\n         */\n        public Long getChangeDateBefore() { return mChangeDateBefore; }\n        /**\n         * Return items modified earlier than the given timestamp.\n         * @param timestamp the timestamp, in seconds\n         */\n        public QueryParams setChangeDateBefore(Long timestamp) { mChangeDateBefore = timestamp; return this; }\n        public Integer getModifiedSequenceBefore() { return mModifiedSequenceBefore; }\n        public QueryParams setModifiedSequenceBefore(Integer changeId) { mModifiedSequenceBefore = changeId; return this; }\n\n        public Integer getRowLimit() { return mRowLimit; }\n        public QueryParams setRowLimit(Integer rowLimit) { mRowLimit = rowLimit; return this; }\n    }\n\n    /**\n     * Returns the ids of items that match the given query parameters.\n     * @return the matching ids, or an empty <tt>Set</tt>\n     */\n    public static Set<Integer> getIds(Mailbox mbox, DbConnection conn, QueryParams params, boolean fromDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        Set<Integer> ids = new HashSet<Integer>();\n\n        try {\n            // Prepare the statement based on query parameters.\n            StringBuilder buf = new StringBuilder();\n            buf.append(\"SELECT id FROM \" + getMailItemTableName(mbox, fromDumpster) + \" WHERE \" + IN_THIS_MAILBOX_AND + \"1 = 1\");\n\n            Set<MailItem.Type> includedTypes = params.getIncludedTypes();\n            Set<MailItem.Type> excludedTypes = params.getExcludedTypes();\n            Set<Integer> folderIds = params.getFolderIds();\n            Long changeDateBefore = params.getChangeDateBefore();\n            Integer modifiedSequenceBefore = params.getModifiedSequenceBefore();\n            Integer rowLimit = params.getRowLimit();\n\n            if (!includedTypes.isEmpty()) {\n                buf.append(\" AND \").append(DbUtil.whereIn(\"type\", includedTypes.size()));\n            }\n            if (!excludedTypes.isEmpty()) {\n                buf.append(\" AND \").append(DbUtil.whereNotIn(\"type\", excludedTypes.size()));\n            }\n            if (!folderIds.isEmpty()) {\n                buf.append(\" AND \").append(DbUtil.whereIn(\"folder_id\", folderIds.size()));\n            }\n            if (changeDateBefore != null) {\n                buf.append(\" AND \").append(\"change_date < ?\");\n            }\n            if (modifiedSequenceBefore != null) {\n                buf.append(\" AND \").append(\"mod_metadata < ?\");\n            }\n            if (rowLimit != null && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                buf.append(\" LIMIT \").append(rowLimit);\n            }\n            stmt = conn.prepareStatement(buf.toString());\n\n            // Bind values, execute query, return results.\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            for (MailItem.Type type : includedTypes) {\n                stmt.setByte(pos++, type.toByte());\n            }\n            for (MailItem.Type type : excludedTypes) {\n                stmt.setByte(pos++, type.toByte());\n            }\n            for (int id : folderIds) {\n                stmt.setInt(pos++, id);\n            }\n            if (changeDateBefore != null) {\n                stmt.setInt(pos++, changeDateBefore.intValue());\n            }\n            if (modifiedSequenceBefore != null) {\n                stmt.setInt(pos++, modifiedSequenceBefore);\n            }\n\n            rs = stmt.executeQuery();\n\n            while (rs.next())\n                ids.add(rs.getInt(1));\n            return ids;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting ids\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void addToCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(\"INSERT INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing invite to calendar item table: UID=\" + calItem.getUid(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static long MAX_DATE = new GregorianCalendar(9999, 1, 1).getTimeInMillis();\n\n    public static void updateInCalendarItemTable(CalendarItem calItem) throws ServiceException {\n        Mailbox mbox = calItem.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        long end = calItem.getEndTime();\n        Timestamp startTs = new Timestamp(calItem.getStartTime());\n        Timestamp endTs = new Timestamp(end <= 0 ? MAX_DATE : end);\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            String mailbox_id = DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \";\n            stmt = conn.prepareStatement(command + \" INTO \" + getCalendarItemTableName(mbox) +\n                        \" (\" + mailbox_id + \"uid, item_id, start_time, end_time)\" +\n                        \" VALUES (\" + MAILBOX_ID_VALUE + \"?, ?, ?, ?)\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, calItem.getUid());\n            stmt.setInt(pos++, calItem.getId());\n            stmt.setTimestamp(pos++, startTs);\n            stmt.setTimestamp(pos++, endTs);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    DbPool.closeStatement(stmt);\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + getCalendarItemTableName(mbox) +\n                            \" SET item_id = ?, start_time = ?, end_time = ? WHERE \" + IN_THIS_MAILBOX_AND + \"uid = ?\");\n                    int pos = 1;\n                    stmt.setInt(pos++, calItem.getId());\n                    stmt.setTimestamp(pos++, startTs);\n                    stmt.setTimestamp(pos++, endTs);\n                    pos = setMailboxId(stmt, mbox, pos);\n                    stmt.setString(pos++, calItem.getUid());\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"updating data in calendar item table \" + calItem.getUid(), nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"writing invite to calendar item table \" + calItem.getUid(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static List<CalendarItem.CalendarMetadata> getCalendarItemMetadata(Folder folder, long start, long end) throws ServiceException {\n        Mailbox mbox = folder.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        ArrayList<CalendarItem.CalendarMetadata> result = new ArrayList<CalendarItem.CalendarMetadata>();\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            String startConstraint = start > 0 ? \" AND ci.end_time > ?\" : \"\";\n            String endConstraint = end > 0 ? \" AND ci.start_time < ?\" : \"\";\n            String folderConstraint = \" AND mi.folder_id = ?\";\n            stmt = conn.prepareStatement(\"SELECT mi.mailbox_id, mi.id, ci.uid, mi.mod_metadata, mi.mod_content, ci.start_time, ci.end_time\" +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") + \", \" + getCalendarItemTableName(mbox, \"ci\") +\n                        \" WHERE mi.mailbox_id = ci.mailbox_id AND mi.id = ci.item_id\" +\n                        (DebugConfig.disableMailboxGroups ? \"\" : \" AND mi.mailbox_id = ? \") +\n                        startConstraint + endConstraint + folderConstraint);\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            if (start > 0)\n                stmt.setTimestamp(pos++, new Timestamp(start));\n            if (end > 0)\n                stmt.setTimestamp(pos++, new Timestamp(end));\n            stmt.setInt(pos++, folder.getId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                result.add(new CalendarItem.CalendarMetadata(\n                            rs.getInt(1),\n                            rs.getInt(2),\n                            rs.getString(3),\n                            rs.getInt(4),\n                            rs.getInt(5),\n                            rs.getTimestamp(6).getTime(),\n                            rs.getTimestamp(7).getTime()));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching CalendarItem Metadata for mbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n        return result;\n    }\n\n\n    public static void consistencyCheck(MailItem item, UnderlyingData data, String metadata) throws ServiceException {\n        if (item.getId() <= 0)\n            return;\n        Mailbox mbox = item.getMailbox();\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT mi.sender, \" + DB_FIELDS +\n                        \" FROM \" + getMailItemTableName(mbox, \"mi\") +\n                        \" WHERE \" + IN_THIS_MAILBOX_AND + \"id = ?\");\n            int pos = 1;\n            pos = setMailboxId(stmt, mbox, pos);\n            stmt.setInt(pos++, item.getId());\n            rs = stmt.executeQuery();\n\n            if (!rs.next()) {\n                throw ServiceException.FAILURE(\"consistency check failed: \" + item.getType() + \" \" + item.getId() +\n                        \" not found in DB\", null);\n            }\n\n            UnderlyingData dbdata = constructItem(rs, 1);\n            String dbsender = rs.getString(1);\n\n            String dataBlobDigest = data.getBlobDigest(), dbdataBlobDigest = dbdata.getBlobDigest();\n            String dataSender = item.getSortSender(), dbdataSender = dbsender == null ? \"\" : dbsender;\n            String failures = \"\";\n\n            if (data.id != dbdata.id)                    failures += \" ID\";\n            if (data.type != dbdata.type)                failures += \" TYPE\";\n            if (data.folderId != dbdata.folderId)        failures += \" FOLDER_ID\";\n            if (data.indexId != dbdata.indexId)          failures += \" INDEX_ID\";\n            if (data.imapId != dbdata.imapId)            failures += \" IMAP_ID\";\n            if (data.locator != dbdata.locator)          failures += \" VOLUME_ID\";\n            if (data.date != dbdata.date)                failures += \" DATE\";\n            if (data.size != dbdata.size)                failures += \" SIZE\";\n            if (dbdata.type != MailItem.Type.CONVERSATION.toByte()) {\n                if (data.unreadCount != dbdata.unreadCount)  failures += \" UNREAD\";\n                if (data.getFlags() != dbdata.getFlags())    failures += \" FLAGS\";\n                if (data.tags != dbdata.tags)                failures += \" TAGS\";\n            }\n            if (data.modMetadata != dbdata.modMetadata)  failures += \" MOD_METADATA\";\n            if (data.dateChanged != dbdata.dateChanged)  failures += \" CHANGE_DATE\";\n            if (data.modContent != dbdata.modContent)    failures += \" MOD_CONTENT\";\n            if (Math.max(data.parentId, -1) != dbdata.parentId)  failures += \" PARENT_ID\";\n            if (dataBlobDigest != dbdataBlobDigest && (dataBlobDigest == null || !dataBlobDigest.equals(dbdataBlobDigest)))  failures += \" BLOB_DIGEST\";\n            if (dataSender != dbdataSender && (dataSender == null || !dataSender.equalsIgnoreCase(dbdataSender)))  failures += \" SENDER\";\n            if (data.getSubject() != dbdata.getSubject() &&\n                    (data.getSubject() == null || !data.getSubject().equals(dbdata.getSubject()))) {\n                failures += \" SUBJECT\";\n            }\n            if (data.name != dbdata.name && (data.name == null || !data.name.equals(dbdata.name)))                 failures += \" NAME\";\n            if (metadata != dbdata.metadata && (metadata == null || !metadata.equals(dbdata.metadata)))            failures += \" METADATA\";\n\n            if (item instanceof Folder && dbdata.folderId != dbdata.parentId)  failures += \" FOLDER!=PARENT\";\n\n            if (!failures.equals(\"\")) {\n                throw ServiceException.FAILURE(\"consistency check failed: \" + item.getType() + \" \" + item.getId() +\n                        \" differs from DB at\" + failures, null);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching item \" + item.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    /**\n     * Makes sure that the argument won't overflow the maximum length by truncating the string if necessary.  Strips\n     * surrogate characters from the string if needed so that the database (i.e. MySQL) doesn't choke on Unicode\n     * characters outside the BMP (U+10000 and higher).\n     *\n     * @param value the string to check (can be null).\n     * @param max maximum length\n     * @return The passed-in String, truncated to the maximum length.\n     */\n    public static String normalize(String value, int max) {\n        if (Strings.isNullOrEmpty(value)) {\n            return value;\n        }\n        String trimmed = value.length() <= max ? value : value.substring(0, max).trim();\n        if (!Db.supports(Db.Capability.NON_BMP_CHARACTERS)) {\n            trimmed = StringUtil.removeSurrogates(trimmed);\n        }\n        return trimmed;\n    }\n\n    /** Makes sure that the argument won't overflow the maximum length of a\n     *  MySQL MEDIUMTEXT column (16,777,216 bytes) after conversion to UTF-8.\n     *\n     * @param metadata  The string to check (can be null).\n     * @return The passed-in String, possibly re-encoded as base64 to hide\n     *         non-BMP characters from the database.\n     * @throws ServiceException <code>service.FAILURE</code> if the\n     *         parameter would be silently truncated when inserted. */\n    public static String checkMetadataLength(String metadata) throws ServiceException {\n        if (metadata == null) {\n            return null;\n        }\n\n        String result = encodeMetadata(metadata);\n        int len = result.length();\n        if (len > MAX_MEDIUMTEXT_LENGTH / 4) {  // every char uses 4 bytes in worst case\n            if (StringUtil.isAsciiString(result)) {\n                if (len > MAX_MEDIUMTEXT_LENGTH)\n                    throw ServiceException.FAILURE(\"metadata too long\", null);\n            } else {\n                try {\n                    if (result.getBytes(\"utf-8\").length > MAX_MEDIUMTEXT_LENGTH)\n                        throw ServiceException.FAILURE(\"metadata too long\", null);\n                } catch (UnsupportedEncodingException uee) { }\n            }\n        }\n        return result;\n    }\n\n    public static String encodeMetadata(String metadata) throws ServiceException {\n        if (Db.supports(Db.Capability.NON_BMP_CHARACTERS) || !StringUtil.containsSurrogates(metadata)) {\n            return metadata;\n        }\n\n        try {\n            return new BCodec(\"utf-8\").encode(metadata);\n        } catch (EncoderException ee) {\n            throw ServiceException.FAILURE(\"encoding non-BMP metadata\", ee);\n        }\n    }\n\n    public static String decodeMetadata(String metadata) throws ServiceException {\n        if (StringUtil.isNullOrEmpty(metadata) || !metadata.startsWith(\"=?\")) {\n            return metadata;\n        } else {\n            try {\n                return new BCodec(\"utf-8\").decode(metadata);\n            } catch (DecoderException de) {\n                throw ServiceException.FAILURE(\"encoding non-BMP metadata\", de);\n            }\n        }\n    }\n\n    /**\n     * Returns the name of the table that stores {@link MailItem} data.  The table name is qualified\n     * with the name of the database (e.g. <tt>mboxgroup1.mail_item</tt>).\n     */\n    public static String getMailItemTableName(int mailboxId, int groupId, boolean dumpster) {\n        return DbMailbox.qualifyTableName(groupId, !dumpster ? TABLE_MAIL_ITEM : TABLE_MAIL_ITEM_DUMPSTER);\n    }\n    public static String getMailItemTableName(MailItem item) {\n        return getMailItemTableName(item, false);\n    }\n    public static String getMailItemTableName(MailItem item, boolean dumpster) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), !dumpster ? TABLE_MAIL_ITEM : TABLE_MAIL_ITEM_DUMPSTER);\n    }\n    public static String getMailItemTableName(Mailbox mbox) {\n        return getMailItemTableName(mbox, false);\n    }\n    public static String getMailItemTableName(Mailbox mbox, boolean dumpster) {\n        return DbMailbox.qualifyTableName(mbox, !dumpster ? TABLE_MAIL_ITEM : TABLE_MAIL_ITEM_DUMPSTER);\n    }\n    public static String getMailItemTableName(Mailbox mbox, String alias) {\n        return getMailItemTableName(mbox, alias, false);\n    }\n    public static String getMailItemTableName(Mailbox mbox, String alias, boolean dumpster) {\n        return getMailItemTableName(mbox, dumpster) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on old revisions of {@link MailItem}s.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.revision</tt>).\n     */\n    public static String getRevisionTableName(int mailboxId, int groupId, boolean dumpster) {\n        return DbMailbox.qualifyTableName(groupId, !dumpster ? TABLE_REVISION : TABLE_REVISION_DUMPSTER);\n    }\n    public static String getRevisionTableName(MailItem item) {\n        return getRevisionTableName(item, false);\n    }\n    public static String getRevisionTableName(MailItem item, boolean dumpster) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), !dumpster ? TABLE_REVISION : TABLE_REVISION_DUMPSTER);\n    }\n    public static String getRevisionTableName(Mailbox mbox) {\n        return getRevisionTableName(mbox, false);\n    }\n    public static String getRevisionTableName(Mailbox mbox, boolean dumpster) {\n        return DbMailbox.qualifyTableName(mbox, !dumpster ? TABLE_REVISION : TABLE_REVISION_DUMPSTER);\n    }\n    public static String getRevisionTableName(Mailbox mbox, String alias) {\n        return getRevisionTableName(mbox, alias, false);\n    }\n    public static String getRevisionTableName(Mailbox mbox, String alias, boolean dumpster) {\n        return getRevisionTableName(mbox, dumpster) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores {@link CalendarItem} data.  The table name is qualified\n     * by the name of the database (e.g. <tt>mailbox1.appointment</tt>).\n     */\n    public static String getCalendarItemTableName(int mailboxId, int groupId, boolean dumpster) {\n        return DbMailbox.qualifyTableName(groupId, !dumpster ? TABLE_APPOINTMENT : TABLE_APPOINTMENT_DUMPSTER);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox) {\n        return getCalendarItemTableName(mbox, false);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox, boolean dumpster) {\n        return DbMailbox.qualifyTableName(mbox, !dumpster ? TABLE_APPOINTMENT : TABLE_APPOINTMENT_DUMPSTER);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox, String alias) {\n        return getCalendarItemTableName(mbox, alias, false);\n    }\n    public static String getCalendarItemTableName(Mailbox mbox, String alias, boolean dumpster) {\n        return getCalendarItemTableName(mbox, dumpster) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that maps subject hashes to {@link Conversation} ids.  The table\n     * name is qualified by the name of the database (e.g. <tt>mailbox1.open_conversation</tt>).\n     */\n    public static String getConversationTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(MailItem item) {\n        return DbMailbox.qualifyTableName(item.getMailbox(), TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_OPEN_CONVERSATION);\n    }\n    public static String getConversationTableName(Mailbox mbox, String alias) {\n        return getConversationTableName(mbox) + \" AS \" + alias;\n    }\n\n    /**\n     * Returns the name of the table that stores data on deleted items for the purpose of sync.\n     * The table name is qualified by the name of the database (e.g. <tt>mailbox1.tombstone</tt>).\n     */\n    public static String getTombstoneTableName(int mailboxId, int groupId) {\n        return DbMailbox.qualifyTableName(groupId, TABLE_TOMBSTONE);\n    }\n    public static String getTombstoneTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_TOMBSTONE);\n    }\n\n\n    /** If the database doesn't support row-level locking, try to synchronize\n     *  database accesses on the Mailbox object to avoid having read/write\n     *  conflicts with Mailbox write transactions.  In the case where the DB\n     *  <u>does</u> support row-level locking, synchronizing on a local\n     *  <code>Object</code> shouldn't add problematic overhead. */\n    public static Object getSynchronizer(Mailbox mbox) {\n        return Db.supports(Db.Capability.ROW_LEVEL_LOCKING) ? new Object() : mbox;\n    }\n\n\n    private static boolean areTagsetsLoaded(Mailbox mbox) {\n        synchronized (sTagsetCache) {\n            return sTagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getTagsetCache(DbConnection conn, Mailbox mbox) throws ServiceException {\n        int mailboxId = mbox.getId();\n        Integer id = new Integer(mailboxId);\n        TagsetCache tagsets = null;\n\n        synchronized (sTagsetCache) {\n            tagsets = sTagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the tagset cache for a single mailbox outside the\n        // synchronized block.\n        if (tagsets == null) {\n            ZimbraLog.cache.info(\"Loading tagset cache\");\n            tagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" tags\");\n            tagsets.addTagsets(DbMailbox.getDistinctTagsets(conn, mbox));\n\n            synchronized (sTagsetCache) {\n                sTagsetCache.put(id, tagsets);\n            }\n        }\n\n        return tagsets;\n    }\n\n    private static boolean areFlagsetsLoaded(Mailbox mbox) {\n        synchronized(sFlagsetCache) {\n            return sFlagsetCache.containsKey(mbox.getId());\n        }\n    }\n\n    static TagsetCache getFlagsetCache(DbConnection conn, Mailbox mbox) throws ServiceException {\n        int mailboxId = mbox.getId();\n        Integer id = new Integer(mailboxId);\n        TagsetCache flagsets = null;\n\n        synchronized (sFlagsetCache) {\n            flagsets = sFlagsetCache.get(id);\n        }\n\n        // All access to a mailbox is synchronized, so we can initialize\n        // the flagset cache for a single mailbox outside the\n        // synchronized block.\n        if (flagsets == null) {\n            ZimbraLog.cache.info(\"Loading flagset cache\");\n            flagsets = new TagsetCache(\"Mailbox \" + mailboxId + \" flags\");\n            flagsets.addTagsets(DbMailbox.getDistinctFlagsets(conn, mbox));\n\n            synchronized (sFlagsetCache) {\n                sFlagsetCache.put(id, flagsets);\n            }\n        }\n\n        return flagsets;\n    }\n\n    /**\n     * Returns a comma-separated list of ids for logging.  If the <tt>String</tt> is\n     * more than 200 characters long, cuts off the list and appends &quot...&quot.\n     */\n    private static String getIdListForLogging(Collection<Integer> ids) {\n        if (ids == null)\n            return null;\n        StringBuilder idList = new StringBuilder();\n        boolean firstTime = true;\n        for (Integer id : ids) {\n            if (firstTime)\n                firstTime = false;\n            else\n                idList.append(',');\n            idList.append(id);\n            if (idList.length() > 200) {\n                idList.append(\"...\");\n                break;\n            }\n        }\n        return idList.toString();\n    }\n\n    public static long getConversationCount(DbConnection conn, Folder folder) throws ServiceException {\n        int collapsed;\n        int distinct;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n             stmt = conn.prepareStatement(\"SELECT COUNT(*), COUNT(DISTINCT parent_id) FROM \" +\n                     DbMailItem.getMailItemTableName(folder.getMailbox()) + \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND +\n                     \"folder_id = ? AND type = ? AND parent_id IS NOT NULL\");\n             int pos = DbMailItem.setMailboxId(stmt, folder.getMailbox(), 1);\n             stmt.setInt(pos++, folder.getId());\n             stmt.setByte(pos, MailItem.Type.MESSAGE.toByte());\n             rs = stmt.executeQuery();\n             rs.next();\n             collapsed = rs.getInt(1);\n             distinct = rs.getInt(2);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Failed to get counversation count\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        long total = folder.getItemCount();\n        long conv = total - collapsed + distinct;\n        ZimbraLog.mailbox.debug(\"ConversationCount folder=%d,conv=%d(%d-%d+%d)\",\n                folder.getId(), conv, total, collapsed, distinct);\n        return conv;\n    }\n\n    private final Mailbox mailbox;\n    // The following data are only used for INSERT/UPDATE, not loaded by SELECT.\n    private String sender;\n    private int senderId = -1;\n    private String recipients;\n\n    /**\n     * {@link UnderlyingData} + extra data used for INSERT/UPDATE into MAIL_ITEM table.\n     */\n    public DbMailItem(Mailbox mbox) {\n        mailbox = mbox;\n    }\n\n    public DbMailItem setSender(String value) {\n        if (!Strings.isNullOrEmpty(value)) {\n            sender = DbMailItem.normalize(value, DbMailItem.MAX_SENDER_LENGTH);\n        }\n        return this;\n    }\n\n    public DbMailItem setSenderId(int value) {\n        senderId = value;\n        return this;\n    }\n\n    public DbMailItem setRecipients(String value) {\n        if (!Strings.isNullOrEmpty(value)) {\n            recipients = DbMailItem.normalize(value, DbMailItem.MAX_RECIPIENTS_LENGTH);\n        }\n        return this;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "DbMailItem.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 19,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.taglib;\n\nimport com.google.common.base.Charsets;\nimport com.zimbra.common.auth.ZAuthToken;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.RemoteIP;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.taglib.bean.BeanUtils;\nimport com.zimbra.cs.zclient.ZAuthResult;\nimport com.zimbra.cs.zclient.ZFolder;\nimport com.zimbra.cs.zclient.ZMailbox;\nimport com.zimbra.common.localconfig.LC;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.jstl.core.Config;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\npublic class ZJspSession {\n\n    public static final String ATTR_SESSION = ZJspSession.class.getCanonicalName()+\".session\";\n    private static final String ATTR_TEMP_AUTHTOKEN = ZJspSession.class.getCanonicalName()+\".authToken\";\n\n    // AP-TODO: COOKIE_NAME is no longer used, retire\n    public static final String COOKIE_NAME = \"ZM_AUTH_TOKEN\";\n    public static final String ZM_LAST_SERVER_COOKIE_NAME = \"ZM_LAST_SERVER\";\n\n\n    private static final String CONFIG_ZIMBRA_SOAP_URL = \"zimbra.soap.url\";\n    private static final String CONFIG_ZIMBRA_JSP_SESSION_TIMEOUT = \"zimbra.jsp.session.timeout\";\n    private static final String CONFIG_ZIMBRA_SEARCH_USE_OFFSET = \"zimbra.search.useoffset\";\n\n    public static final String Q_ZAUTHTOKEN = \"zauthtoken\";\n    public static final String Q_ZINITMODE = \"zinitmode\";\n    public static final String Q_ZREMBERME = \"zrememberme\";\n    public static final String Q_ZLASTSERVER = \"zlastserver\";\n\n    private ZMailbox mMbox;\n    private ZAuthToken mAuthToken;\n\n    public ZJspSession(ZAuthToken authToken, ZMailbox mbox) {\n        mAuthToken = authToken;\n        mMbox = mbox;\n    }\n\n    public ZMailbox getMailbox() { return mMbox; }\n    public ZAuthToken getAuthToken() { return mAuthToken; }\n\n    private static String sSoapUrl = null;\n\n    private static final String DEFAULT_HTTPS_PORT = \"443\";\n    private static final String DEFAULT_HTTP_PORT = \"80\";\n    private static final String RANDOM_HTTP_PORT = \"0\";\n    private static final String PROTO_MIXED = \"mixed\";\n    private static final String PROTO_HTTP = \"http\";\n    private static final String PROTO_HTTPS = \"https\";\n\n    private static final String sProtocolMode = BeanUtils.getEnvString(\"protocolMode\", PROTO_HTTP);\n    private static final boolean MODE_HTTP = sProtocolMode.equals(PROTO_HTTP);\n    private static final boolean MODE_MIXED = sProtocolMode.equals(PROTO_MIXED);\n    private static final boolean MODE_HTTPS = sProtocolMode.equals(PROTO_HTTPS);\n\n    private static final String sHttpsPort = BeanUtils.getEnvString(\"httpsPort\", DEFAULT_HTTPS_PORT);\n    private static final String sHttpPort = BeanUtils.getEnvString(\"httpPort\", DEFAULT_HTTP_PORT);\n    private static final String sLocalHost = BeanUtils.getEnvString(\"localHost\", \"localhost\");\n\n    private static final String sAdminUrl = BeanUtils.getEnvString(\"adminUrl\", null);\n    private static final RemoteIP.TrustedIPs TRUSTED_IPS = new RemoteIP.TrustedIPs(\n            BeanUtils.getEnvString(\"trustedIPs\", \"\").split(\" \"));\n\n    public static boolean secureAuthTokenCookie(HttpServletRequest request) {\n        String initMode = request.getParameter(Q_ZINITMODE);\n        boolean currentHttps = request.getScheme().equals(PROTO_HTTPS);\n        return MODE_HTTPS || (currentHttps && (initMode == null || initMode.equals(PROTO_HTTPS)));\n    }\n\n    public static boolean isProtocolModeHttps() {\n        return MODE_HTTPS;\n    }\n\n    private static void addParam(StringBuilder query, String name, String value) {\n        if (query.length() > 0) {\n            query.append('&');\n        }\n        if (value == null) {\n            value = \"\";\n        }\n        try {\n            query.append(name).append(\"=\").append(URLEncoder.encode(value, Charsets.UTF_8.name()));\n        } catch (UnsupportedEncodingException never) {\n            assert false;\n        }\n    }\n\n    private static boolean isInQueryString(HttpServletRequest req, String name) {\n        String qs = req.getQueryString();\n        return (!(qs == null || qs.length() == 0)) && qs.indexOf(name + \"=\") != -1;\n    }\n\n    private static String generateQueryString(HttpServletRequest req, Map<String,String> toAdd, Set<String> toRemove) {\n        StringBuilder query = new StringBuilder();\n        @SuppressWarnings(\"rawtypes\")\n        Enumeration names = req.getParameterNames();\n        while (names.hasMoreElements()) {\n            String name = (String) names.nextElement();\n            if (toRemove != null && !toRemove.contains(name) && isInQueryString(req, name)) {\n                String values[] = req.getParameterValues(name);\n                if (values != null) {\n                    for (String value : values) {\n                        addParam(query, name, value);\n                    }\n                }\n            }\n        }\n        if (toAdd != null) {\n            for (Entry<String, String> entry : toAdd.entrySet()) {\n                addParam(query, entry.getKey(), entry.getValue());\n            }\n        }\n\n        return query.length() > 0 ? \"?\" + query.toString()  : \"\";\n    }\n\n    private static String getRedirect(HttpServletRequest request,\n                                      String protoHostPort,\n                                      String path,\n                                      Map<String,String> paramsToAdd,\n                                      Set<String> paramsToRemove)\n    {\n        if (path == null || path.equals(\"\"))\n            path = \"/\";\n\n        String contextPath = request.getContextPath();\n        if(contextPath.equals(\"/\")) contextPath = \"\";\n\n        String qs = generateQueryString(request, paramsToAdd, paramsToRemove);\n\n        return protoHostPort + contextPath + path + qs;\n    }\n\n    private static String getRedirectToHostHeader(HttpServletRequest request,\n                                                  String proto,\n                                                  String path,\n                                                  Map<String,String> paramsToAdd,\n                                                  Set<String> paramsToRemove)\n    {\n        String protoHostPort = proto + \"://\" + request.getHeader(\"Host\");\n        return getRedirect(request, protoHostPort, path, paramsToAdd, paramsToRemove);\n    }\n\n\n    private static String getRedirect(HttpServletRequest request,\n                                      String proto,\n                                      String host,\n                                      String path,\n                                      Map<String,String> paramsToAdd,\n                                      Set<String> paramsToRemove)\n    {\n        String port;\n        if (proto.equals(PROTO_HTTPS)) {\n            port = (sHttpsPort != null && sHttpsPort.equals(DEFAULT_HTTPS_PORT)) ? \"\" : \":\" + sHttpsPort;\n        } else if (proto.equals(PROTO_HTTP)) {\n            if (sHttpPort.equals(RANDOM_HTTP_PORT))\n                port = \":\" + LC.zimbra_admin_service_port.value();\n            else\n                port = sHttpPort.equals(DEFAULT_HTTP_PORT) ? \"\" : \":\" + sHttpPort;\n        } else {\n            return null;\n        }\n\n        String protoHostPort = proto + \"://\" + host + port;\n        return getRedirect(request, protoHostPort, path, paramsToAdd, paramsToRemove);\n    }\n\n    public static String getPostLoginRedirectUrl(PageContext context, String path, ZAuthResult authResult, boolean rememberMe, boolean needRefer) {\n        HttpServletRequest request = (HttpServletRequest) context.getRequest();\n        HttpServletResponse response = (HttpServletResponse) context.getResponse();\n\n        String initMode = request.getParameter(Q_ZINITMODE);\n        boolean hasIniitMode = initMode != null;\n        boolean needsAuthtokenRemoved = request.getParameter(Q_ZAUTHTOKEN) != null;\n\n        // see if we don't need to redirect\n        if (!(needRefer || needsAuthtokenRemoved || hasIniitMode))\n            return null;\n\n\n        Map<String,String> toAdd = new HashMap<String, String>();\n        Set<String> toRemove = new HashSet<String>();\n\n        String proto;\n        if (hasIniitMode && !needRefer) {\n            if (MODE_MIXED && initMode.equals(PROTO_HTTP) && !request.getScheme().equals(PROTO_HTTP)) {\n                proto = PROTO_HTTP;\n            } else if (MODE_MIXED && initMode.equals(PROTO_HTTPS) && !request.getScheme().equals(PROTO_HTTPS)) {\n                proto = PROTO_HTTPS;\n            } else if (MODE_HTTPS) {\n                proto = PROTO_HTTPS;\n            } else {\n                proto = PROTO_HTTP;\n            }\n            toRemove.add(Q_ZINITMODE);\n        } else {\n            proto = request.getScheme();\n        }\n\n        String host;\n        if (needRefer) {\n            host = authResult.getRefer();\n//            Do not append the authToken in the redirect URL. If needRefer is set, let the\n//            client send it as a separate param. \n//            toAdd.put(Q_ZAUTHTOKEN, authResult.getAuthToken().getValue());\n            if (rememberMe) {\n                toAdd.put(Q_ZREMBERME, \"1\");\n                Cookie lastServerCookie = new Cookie(ZJspSession.ZM_LAST_SERVER_COOKIE_NAME, host);\n                long timeLeft = authResult.getExpires() - System.currentTimeMillis();\n                if (timeLeft > 0) lastServerCookie.setMaxAge((int) (timeLeft/1000));\n                lastServerCookie.setPath(\"/\");\n                response.addCookie(lastServerCookie);\n            }\n        } else {\n            host = request.getServerName();\n        }\n\n        if (needsAuthtokenRemoved) {\n            // strip off authtoken/rememberme if present\n            toRemove.add(Q_ZAUTHTOKEN);\n            toRemove.add(Q_ZREMBERME);\n        }\n\n        if (needsAuthtokenRemoved && !hasIniitMode && !needRefer)\n            return getRedirectToHostHeader(request, proto, path, toAdd, toRemove);\n        else\n            return getRedirect(request, proto, host, path, toAdd, toRemove);\n    }\n\n    public static String getChangePasswordUrl(PageContext context, String path) {\n        HttpServletRequest request = (HttpServletRequest) context.getRequest();\n\n        try {\n            ZMailbox mbox = getZMailbox(context);\n            String publicUrl = mbox.getAccountInfo(false).getPublicURLBase();\n            if (publicUrl != null)\n                return getRedirect(request, publicUrl, path, null, null);\n        } catch (JspException e) {\n            // fall through to use the Host header\n        } catch (ServiceException e) {\n            // fall through to use the Host header\n        }\n\n        String proto = MODE_HTTP ? PROTO_HTTP : PROTO_HTTPS;\n        return getRedirectToHostHeader(request, proto, path, null, null);\n    }\n\n    private static int[] sAdminPorts = null;\n\n    private static synchronized boolean isAdminPort(int port, PageContext context) {\n        if (sAdminPorts == null) {\n            String portsStr = context.getServletContext().getInitParameter(\"admin.allowed.ports\");\n            String ports[] = portsStr != null ? portsStr.split(\",\") : null;\n            if (ports != null) {\n                sAdminPorts = new int[ports.length];\n                int i=0;\n                for (String p : ports) {\n                    try { sAdminPorts[i] = Integer.parseInt(p.trim()); }\n                    catch (NumberFormatException nfe) { sAdminPorts[i] = -1; }\n                    i++;\n                }\n            } else {\n                sAdminPorts = new int[0];\n            }\n        }\n        for (int p : sAdminPorts) {\n            if (p == port) return true;\n        }\n        return false;\n    }\n\n    public static String getAdminLoginRedirectUrl(PageContext context, String defaultPath) {\n        HttpServletRequest request = (HttpServletRequest) context.getRequest();\n        if (isAdminPort(request.getServerPort(), context)) {\n            String qs = request.getQueryString();\n            String path = sAdminUrl != null ? sAdminUrl : defaultPath;\n            if(qs != null)\n                path = path + \"?\" + qs;\n            return path;\n        } else {\n            return null;\n        }\n    }\n\n    private static String getLastServer(HttpServletRequest request) {\n        // make sure we aren't in a redirect loop\n        if (\"1\".equals(request.getParameter(Q_ZLASTSERVER))) return null;\n        String lastServer;\n        Cookie[] cookies = request.getCookies();\n        if (cookies == null) return null;\n        for (Cookie c : cookies){\n            if (c.getName().equals(ZM_LAST_SERVER_COOKIE_NAME)) {\n                lastServer = c.getValue();\n                if (lastServer != null && !request.getServerName().equalsIgnoreCase(lastServer)) {\n                    return lastServer;\n                } else{\n                    return null;\n                }\n            }\n        }\n        return null;\n    }\n\n    public static String getPreLoginRedirectUrl(PageContext context, String path) {\n        HttpServletRequest request = (HttpServletRequest) context.getRequest();\n\n        String lastServer = getLastServer(request);\n        boolean CURRENT_HTTP = request.getScheme().equals(PROTO_HTTP);\n\n        if (lastServer != null) {\n            Map<String,String> toAdd = new HashMap<String, String>();\n            toAdd.put(Q_ZLASTSERVER, \"1\"); // to hopefully prevent redirect loops\n            return getRedirect(request, request.getScheme(), lastServer, path, toAdd, null);\n        }\n\n        if (  ((MODE_MIXED || MODE_HTTPS) && CURRENT_HTTP) || (!CURRENT_HTTP && MODE_HTTP)) {\n            Map<String,String> toAdd = new HashMap<String, String>();\n            toAdd.put(Q_ZINITMODE, PROTO_HTTP);\n            return getRedirect(request, PROTO_HTTPS, request.getServerName(), path, toAdd, null);\n        } else {\n            return null;\n        }\n    }\n\n    public static boolean getSearchUseOffset(PageContext context) {\n        String useOffset = (String) Config.find(context, CONFIG_ZIMBRA_SEARCH_USE_OFFSET);\n        return useOffset != null && (useOffset.equalsIgnoreCase(\"true\") || useOffset.equalsIgnoreCase(\"1\"));\n    }\n\n    public static synchronized String getSoapURL(PageContext context) {\n        if (sSoapUrl == null) {\n            sSoapUrl = (String) Config.find(context, CONFIG_ZIMBRA_SOAP_URL);\n            if (sSoapUrl == null) {\n                if (sProtocolMode.equalsIgnoreCase(PROTO_HTTPS)) {\n                    String httpsPort = (sHttpsPort != null && sHttpsPort.equals(DEFAULT_HTTPS_PORT)) ? \"\" : \":\" + sHttpsPort;\n                    sSoapUrl = \"https://\" + sLocalHost + httpsPort +\"/service/soap\";\n                } else {\n                    String httpPort;\n                    if (sHttpPort.equals(RANDOM_HTTP_PORT)) // offline uses random http port\n                        httpPort = \":\" + LC.zimbra_admin_service_port.value();\n                    else\n                        httpPort = sHttpPort.equals(DEFAULT_HTTP_PORT) ? \"\" : \":\" + sHttpPort;\n                    sSoapUrl = \"http://\" + sLocalHost + httpPort +\"/service/soap\";\n                }\n            }\n        }\n        return sSoapUrl;\n    }\n\n    public static ZMailbox getZMailbox(PageContext context) throws JspException {\n        try {\n            ZJspSession session = ZJspSession.getSession(context);\n            if (session == null ) {\n                throw ServiceException.AUTH_REQUIRED();\n            } else {\n                return session.getMailbox();\n            }\n        } catch (ServiceException e) {\n            throw new JspTagException(\"getMailbox\", e);\n        }\n    }\n\n    public static ZAuthToken getAuthToken(PageContext context) {\n        // check here first, in case we are logging in and cookie isn't set yet.\n        // String authToken = (String) context.getAttribute(ATTR_TEMP_AUTHTOKEN, PageContext.REQUEST_SCOPE);\n        ZAuthToken authToken = (ZAuthToken) context.getAttribute(ATTR_TEMP_AUTHTOKEN, PageContext.REQUEST_SCOPE);\n        if (authToken != null) return authToken;\n\n        HttpServletRequest request= (HttpServletRequest) context.getRequest();\n        ZAuthToken zat = new ZAuthToken(request, false);\n        if (zat.isEmpty())\n            return null;\n        else\n            return zat;\n    }\n\n    public static boolean hasSession(PageContext context) {\n        HttpServletRequest req = (HttpServletRequest) context.getRequest();\n        if (req.getSession(false) == null)\n            return false;\n\n        ZAuthToken authToken = getAuthToken(context);\n        ZJspSession sess = (ZJspSession) context.getAttribute(ATTR_SESSION, PageContext.SESSION_SCOPE);\n        // see if we have a session that matches auth token\n        return sess != null && sess.getAuthToken().equals(authToken);\n    }\n\n    public static ZJspSession getSession(PageContext context) throws ServiceException {\n        ZJspSession sess = (ZJspSession) context.getAttribute(ATTR_SESSION, PageContext.SESSION_SCOPE);\n        ZAuthToken authToken = getAuthToken(context);\n\n        // see if we have a session that matches auth token\n        if (sess != null && sess.getAuthToken().equals(authToken)) {\n            return sess;\n        }\n\n        if (authToken == null || authToken.isEmpty()) {\n            return null;\n        } else {\n            // see if we can get a mailbox from the auth token\n            ZMailbox.Options options = new ZMailbox.Options(authToken, getSoapURL(context));\n            options.setClientIp(getRemoteAddr(context));\n\n            //options.setAuthAuthToken(true);\n            ZMailbox mbox = ZMailbox.getMailbox(options);\n            mbox.getAccountInfo(false);\n            return setSession(context, mbox);\n        }\n    }\n\n    public static ZMailbox getRestMailbox(PageContext context, String authToken, String targetAccountId) throws ServiceException {\n        if (authToken == null || authToken.length() == 0) {\n            return null;\n        } else {\n            // see if we can get a mailbox from the auth token\n            ZMailbox.Options options = new ZMailbox.Options(authToken, getSoapURL(context));\n            options.setNoSession(true);\n            options.setAuthAuthToken(false);\n            options.setTargetAccount(targetAccountId);\n            options.setTargetAccountBy(Provisioning.AccountBy.id);\n            options.setClientIp(getRemoteAddr(context));\n            return ZMailbox.getMailbox(options);\n        }\n    }\n\n    public static ZMailbox getRestMailbox(PageContext context, ZAuthToken authToken, String targetAccountId) throws ServiceException {\n        if (authToken == null) {\n            return null;\n        } else {\n            // see if we can get a mailbox from the auth token\n            ZMailbox.Options options = new ZMailbox.Options(authToken, getSoapURL(context));\n            options.setNoSession(true);\n            options.setAuthAuthToken(false);\n            options.setTargetAccount(targetAccountId);\n            options.setTargetAccountBy(Provisioning.AccountBy.id);\n            options.setClientIp(getRemoteAddr(context));\n            return ZMailbox.getMailbox(options);\n        }\n    }\n\n    public static void setCollapsed(ZFolder folder, HashMap<String,String> expanded) {\n        if (!folder.getSubFolders().isEmpty()) {\n            expanded.put(folder.getId(), \"collapse\");\n            for (ZFolder child : folder.getSubFolders()) {\n                setCollapsed(child, expanded);\n            }\n        }\n    }\n\n    public static ZJspSession setSession(PageContext context, ZMailbox mbox) throws ServiceException {\n        ZJspSession sess = new ZJspSession(mbox.getAuthToken(), mbox);\n        // save auth token for duration of request (chicken/egg in getSession)\n        context.setAttribute(ATTR_TEMP_AUTHTOKEN, mbox.getAuthToken(), PageContext.REQUEST_SCOPE);\n        context.setAttribute(ATTR_SESSION, sess, PageContext.SESSION_SCOPE);\n        HashMap<String,String> expanded = new HashMap<String, String>();\n        for (ZFolder f : mbox.getUserRoot().getSubFolders()) {\n            setCollapsed(f, expanded);\n        }\n        context.setAttribute(\"expanded\", expanded, PageContext.SESSION_SCOPE);\n        String timeOutStr = (String) Config.find(context, CONFIG_ZIMBRA_JSP_SESSION_TIMEOUT);\n        if (timeOutStr != null) {\n            try {\n                context.getSession().setMaxInactiveInterval(Integer.parseInt(timeOutStr));\n            } catch (NumberFormatException e) {\n                // TODO: log\n            }\n        }\n        return sess;\n    }\n\n    public static void clearSession(PageContext context) {\n        try {\n            //context.getSession().invalidate();\n        } catch (Exception e) {\n            // ignore if the session is already gone\n        }\n    }\n\n    public static String getRemoteAddr(PageContext context) {\n        HttpServletRequest req = (HttpServletRequest)context.getRequest();\n        RemoteIP remoteIp = new RemoteIP(req, TRUSTED_IPS);\n        return remoteIp.getRequestIP();\n    }\n\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-taglib",
    "commit": "3c1e9f3fd28135111914ef84807a0d65b1b0a784",
    "commit_msg": "bug: 75976 Failed to send message potential XSS\n\nIntegration from helix to main\n\n- Additional Checks for NPE\n- Handling similar case for forward of messages\n\nReviewboard url: https://reviewboard.eng.vmware.com/r/363794/\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=75976\n\nCopied from Perforce\n Change: 389560",
    "original_file": "ZJspSession.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 20,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private Map<Db.Error, String> mErrorCodes;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"column id is not unique\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        Map<String, String> pragmas = getCustomPragmas();\n        String cacheSize = LC.get(\"sqlite_cache_size\");\n        LinkedList<java.sql.Connection> connections = new LinkedList<java.sql.Connection>();\n        \n        if (cacheSize != null)\n            cacheSize = \"1500\";\n        for (int i = 0; i < poolSize; i++) {\n            java.sql.Connection conn = pool.getConnection();\n            if (i == 0)\n                ZimbraLog.dbconn.info(\"sqlite driver running in \" + conn.getMetaData().getDriverVersion() + \" mode\");\n\n            try {\n                conn.setAutoCommit(true);\n                pragma(conn, \"cache_size\", cacheSize);\n                pragma(conn, \"default_cache_size\", cacheSize);\n                pragma(conn, \"page_size\", \"4096\");\n                pragma(conn, \"default_page_size\", \"4096\");\n                pragma(conn, \"fullfsync\", \"0\");\n                pragma(conn, \"journal_mode\", \"TRUNCATE\");\n                pragma(conn, \"legacy_file_format\", \"OFF\");\n                pragma(conn, \"synchronous\", \"NORMAL\");\n\n                for (Map.Entry<String, String> pragma : pragmas.entrySet())\n                    pragma(conn, pragma.getKey(), pragma.getValue());\n            } finally {\n                connections.add(conn);\n                conn.setAutoCommit(false);\n            }\n        }\n        for (java.sql.Connection conn : connections)\n            conn.close();\n\n        super.startup(pool, poolSize);\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private Map<String, String> getCustomPragmas() {\n        String propsfile = LC.get(\"sqlite_pragma_file\");\n        if (propsfile == null || propsfile.trim().equals(\"\"))\n            return Collections.emptyMap();\n\n        try {\n            Properties props = new Properties();\n            props.load(new FileInputStream(propsfile));\n            ZimbraLog.dbconn.info(\"reading custom sqlite pragmas from conf file: \" + propsfile);\n\n            Map<String, String> pragmas = new HashMap<String, String>(props.size() * 3 / 2);\n            for (Map.Entry<Object, Object> foo : props.entrySet()) {\n                String key = (String) foo.getKey(), value = (String) foo.getValue();\n                pragmas.put(key, value);\n                ZimbraLog.dbconn.info(\"  found custom pragma: '\" + key + \"' => '\" + value + \"'\");\n            }\n            return pragmas;\n        } catch (FileNotFoundException x) {\n            ZimbraLog.dbconn.info(\"no sqlite pragma conf file found; will use standard config\");\n        } catch (IOException x) {\n            ZimbraLog.dbconn.warn(\"exception reading from sqlite pragma conf file (\" + propsfile + \"); will use standard config\", x);\n        }\n        return Collections.emptyMap();\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n                \n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n        \n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } catch (SQLException e) {\n            if (!\"database is already attached\".equals(e.getMessage()))\n                return;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n        \n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "9d36bbd5e4525c1bee19d482d7933e64d25b9f8b",
    "commit_msg": "(split)bug: none cleanup sqlite pragma settings. They are now set upon\nConnection creation rather than attempting to grab all items from\ndb pool. This also lets different pooling strategies work correctly that\nmight destroy connections\n\nCopied from Perforce\n Change: 214219",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 21,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2011, 2012, 2013, 2014, 2016 Synacor, Inc.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software Foundation,\n * version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License along with this program.\n * If not, see <https://www.gnu.org/licenses/>.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.imap;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.util.ByteUtil;\n\n/**\n * IMAP cache using local disk.\n *\n * @author dkarp\n * @author ysasaki\n */\nfinal class DiskImapCache implements ImapSessionManager.Cache<String, ImapFolder> {\n\n    private static final String CACHE_DATA_SUBDIR =\n            \"data\" + File.separator + \"mailboxd\" + File.separator + \"imap\" + File.separator + \"cache\";\n    private static final File CACHE_DIR = new File(LC.zimbra_home.value(), CACHE_DATA_SUBDIR);\n    private static final String IMAP_CACHEFILE_SUFFIX = \".i4c\";\n\n    DiskImapCache() {\n        CACHE_DIR.mkdirs();\n\n        // iterate over all serialized folders and delete all but the most recent\n        File[] allCached = CACHE_DIR.listFiles();\n        Arrays.sort(allCached, new Comparator<File>() {\n            @Override public int compare(File o1, File o2)  {\n                return o1.getName().compareTo(o2.getName());\n            }\n        });\n        File previous = null;\n        String lastOwner = \"\", lastId = \"\";\n        for (File cached : allCached) {\n            String split = ImapSessionManager.isActiveKey(cached.getName()) ? \"_\" : \":\";\n            String[] parts = cached.getName().split(split);\n            if (previous != null && parts.length >= 4) {\n                if (lastOwner.equals(parts[0]) && lastId.equals(parts[1])) {\n                    previous.delete();\n                } else {\n                    removeSessionFromFilename(previous);\n                }\n            }\n            lastOwner = parts[0];  lastId = parts[1];\n            previous = cached;\n        }\n        removeSessionFromFilename(previous);\n    }\n\n    /**\n     * Renames the passed-in {@link File} by removing everything from the {@code +} character to the extension. If the\n     * filename does not contain {@code +}, does nothing.\n     */\n    private static void removeSessionFromFilename(File file) {\n        if (file == null) {\n            return;\n        }\n        String filename = file.getName();\n        if (filename.contains(\"+\")) {\n            file.renameTo(new File(CACHE_DIR, filename.substring(0, filename.lastIndexOf(\"+\")) + IMAP_CACHEFILE_SUFFIX));\n        }\n    }\n\n    @Override\n    public void put(String key, ImapFolder folder) {\n        File pagefile = new File(CACHE_DIR, key + IMAP_CACHEFILE_SUFFIX);\n        if (pagefile.exists()) {\n            return;\n        }\n        FileOutputStream fos = null;\n        ObjectOutputStream oos = null;\n        try {\n            oos = new ObjectOutputStream(fos = new FileOutputStream(pagefile));\n            synchronized (folder) {\n                oos.writeObject(folder);\n            }\n        } catch (IOException e) {\n            ByteUtil.closeStream(oos);\n            ByteUtil.closeStream(fos);\n            pagefile.delete();\n        } finally {\n            ByteUtil.closeStream(oos);\n            ByteUtil.closeStream(fos);\n        }\n    }\n\n    @Override\n    public ImapFolder get(String key) {\n        File pagefile = new File(CACHE_DIR, key + IMAP_CACHEFILE_SUFFIX);\n        if (!pagefile.exists()) {\n            return null;\n        }\n        FileInputStream fis = null;\n        ObjectInputStream ois = null;\n        try {\n            // read serialized ImapFolder from cache\n            ois = new ObjectInputStream(fis = new FileInputStream(pagefile));\n            return (ImapFolder) ois.readObject();\n        } catch (Exception e) {\n            ByteUtil.closeStream(ois);\n            ByteUtil.closeStream(fis);\n            pagefile.delete();\n            return null;\n        } finally {\n            ByteUtil.closeStream(ois);\n            ByteUtil.closeStream(fis);\n        }\n    }\n\n    @Override\n    public void remove(String key) {\n        File pagefile = new File(CACHE_DIR, key + IMAP_CACHEFILE_SUFFIX);\n        pagefile.delete();\n    }\n\n    @Override\n    public void updateAccessTime(String key) {\n        //nothing to do; disk cache never expires\n    }\n}\n",
    "vulnerability_type": "Insecure Deserialization",
    "repo": "zm-mailbox",
    "commit": "27a11bd3386f10cc4bc7a507aa4aa7e07c16c652",
    "commit_msg": "ZCS-6695 Fixing ObjectInputStream to deserialize only specified class",
    "original_file": "DiskImapCache.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 22,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013 Zimbra Software, LLC.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.4 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.cs.html;\n\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.regex.Pattern;\n\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.NamespaceContext;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLLocator;\nimport org.apache.xerces.xni.XMLResourceIdentifier;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.cyberneko.html.filters.DefaultFilter;\n\nimport com.google.common.base.Strings;\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.servlet.ZThreadLocal;\n\n/**\n * very Mutated version of ElementRemover.java filter from cyberneko html.\n * change accepted/removed elements to static hashmaps for one-time\n * initialization, switched from Hashtable to HashMap, sanatize\n * attributes, etc.\n *\n * TODO: more checks:\n * allow limited use of <meta> tags? like for Content-Type?\n * make sure any clicked links pop up in new window\n * figure out how to block images by default, and how to re-enable them. styles?\n * strict attr value checking?\n *  don't allow id attr in tags if we aren't putting html into an iframe (I'm assuming we are, and id's in iframes don't conflict with iframes elsewhere)\n */\npublic class DefangFilter extends DefaultFilter {\n\n    /**\n     * disable all form/input type tags\n     */\n    private static final boolean ENABLE_INPUT_TAGS = true;\n\n    /**\n     * enable table tags\n     */\n    private static final boolean ENABLE_TABLE_TAGS = true;\n\n    /**\n     * enable phrase tags (EM, STRONG, CITE, DFN, CODE, SAMP, KBD, VAR, ABBR, ACRONYM)\n     */\n    private static final boolean ENABLE_PHRASE_TAGS = true;\n\n    /**\n     * enable list tags (UL, OL, LI, DL, DT, DD, DIR, MENU)\n     */\n    private static final boolean ENABLE_LIST_TAGS = true;\n\n    /**\n     * enable font style tags (TT, I, B, BIG, SMALL, STRIKE, S, U)\n     */\n    private static final boolean ENABLE_FONT_STYLE_TAGS = true;\n\n    /** The Host header received in the request. */\n    private String reqVirtualHost = null;\n\n    /** enable same host post request for a form in email */\n    private static boolean sameHostFormPostCheck = LC.defang_block_form_same_host_post_req.booleanValue();\n\n    //\n    // Constants\n    //\n\n    /** A \"null\" object. */\n    protected static final Object NULL = new Object();\n\n    // regexes inside of attr values to strip out\n    private static final Pattern AV_JS_ENTITY = Pattern.compile(LC.defang_av_js_entity.value());\n    private static final Pattern AV_SCRIPT_TAG = Pattern.compile(LC.defang_av_script_tag.value(), Pattern.CASE_INSENSITIVE);\n    private static final Pattern AV_JAVASCRIPT = Pattern.compile(LC.defang_av_javascript.value(), Pattern.CASE_INSENSITIVE);\n\n\n // regex for URLs href. TODO: beef this up\n    private static final Pattern VALID_EXT_URL = Pattern.compile(LC.defang_valid_ext_url.value(), Pattern.CASE_INSENSITIVE);\n    private static final Pattern VALID_INT_IMG = Pattern.compile(LC.defang_valid_int_img.value());\n    private static final Pattern VALID_IMG_FILE = Pattern.compile(LC.defang_valid_img_file.value());\n\n    // matches the file format that convertd uses so it doesn't get 'pnsrc'ed\n    private static final Pattern VALID_CONVERTD_FILE = Pattern\n        .compile(LC.defang_valid_convertd_file.value());\n\n    //\n    // Data\n    //\n\n    // information\n\n    /** attr Set cache */\n    private static HashMap<String, HashSet<String>> mAttrSetCache = new HashMap<String, HashSet<String>>();\n\n    /** Accepted elements. */\n    private static HashMap<String, HashSet<String>> mAcceptedElements = new HashMap<String, HashSet<String>>();\n\n    /** Removed elements. */\n    private static HashMap<String, Object> mRemovedElements = new HashMap<String, Object>();\n\n    // state\n\n    private String mBaseHref = null;\n    private URI mBaseHrefURI = null;\n\n\n    /** Strip images */\n    boolean mNeuterImages;\n\n    /** The name of the element in the process of being removed. */\n    protected String mRemovalElementName;\n\n    /** Tracks the recursive nesting level of the element being removed.\n     *  Since we're skipping from the element's open-tag to its close-tag,\n     *  we need to make sure not to stop skipping if another element of\n     *  the same type was nested in the first.  For instance,\n     *  <pre>\n     *    &lt;skipme>&lt;foo>&lt;skipme>XX&lt;/skipme>&lt;/foo>&lt;/skipme>\n     *  </pre> should not stop skipping at the first <tt>&lt;/skipme></tt>\n     *  but rather after the second. */\n    protected int mRemovalElementCount;\n\n    /** The style element depth */\n    protected int mStyleDepth;\n\n    //private static String[] STD_CORE = { \"id\", \"class\", \"title\", \"style\" };\n    private static String CORE = \"id,class,title,style,\";\n    private static String LANG = \"dir,lang,xml:lang,\";\n    private static String CORE_LANG = CORE+LANG;\n    private static String KBD = \"accesskey,tabindex,\";\n\n    static {\n        // set which elements to accept\n        acceptElement(\"a\", CORE+KBD+\",charset,coords,href,hreflang,name,rel,rev,shape,target,type\");\n        acceptElement(\"address\", CORE_LANG);\n        //acceptElement(\"base\", \"href\"); //,target\");\n        acceptElement(\"bdo\", CORE_LANG);\n        acceptElement(\"blockquote\", CORE_LANG+\"cite\");\n        acceptElement(\"body\", CORE_LANG+\"background\"); //+\"alink,background,bgcolor,link,text,vlink\");\n        acceptElement(\"br\", CORE+\"clear\");\n        acceptElement(\"center\", CORE_LANG);\n        acceptElement(\"del\", CORE_LANG+\"cite,datetime\");\n        acceptElement(\"div\", CORE_LANG+\"align\");\n        acceptElement(\"head\", LANG); // profile attr removed\n        acceptElement(\"h1\", CORE_LANG+\"align\");\n        acceptElement(\"h2\", CORE_LANG+\"align\");\n        acceptElement(\"h3\", CORE_LANG+\"align\");\n        acceptElement(\"h4\", CORE_LANG+\"align\");\n        acceptElement(\"h5\", CORE_LANG+\"align\");\n        acceptElement(\"h6\", CORE_LANG+\"align\");\n        acceptElement(\"hr\", CORE_LANG+\"align,noshade,size,width\");\n        acceptElement(\"html\", LANG+\"xmlns\");\n        acceptElement(\"img\", CORE_LANG+\"align,alt,border,height,hspace,ismap,longdesc,src,usemap,vspace,width\");\n        acceptElement(\"ins\", CORE_LANG+\"cite\");\n        acceptElement(\"label\", CORE_LANG+\"for\");\n        //acceptElement(\"link\", CORE_LANG+\"charset,href,hreflang,media,ntarget,rel,rev,type\");\n\n        // NOTE: comment out noframes so its text shows up, since we are nuke frame-related tags\n        //acceptElement(\"noframes\", CORE_LANG);\n        // NOTE: comment out noscript so its text shows up, since we are nuking script tags\n        //acceptElement(\"noscript\", CORE_LANG); // maybe convert to always execute if we are stripping script?\n        acceptElement(\"p\", CORE_LANG+\"align\");\n        acceptElement(\"pre\", CORE_LANG+\"width\");\n        acceptElement(\"q\", CORE_LANG+\"cite\");\n        acceptElement(\"span\", CORE_LANG);\n\n        acceptElement(\"style\", CORE_LANG);\n        acceptElement(\"sub\",  CORE_LANG);\n        acceptElement(\"sup\",  CORE_LANG);\n\n        //acceptElement(\"title\", CORE_LANG);\n        acceptElement(\"title\", \"\");\n\n        if (ENABLE_FONT_STYLE_TAGS) {\n            acceptElement(\"b\",  CORE_LANG);\n            acceptElement(\"basefont\", CORE_LANG+\"color,face,size\");\n            acceptElement(\"big\", CORE_LANG);\n            acceptElement(\"font\", CORE_LANG+\"color,face,size\");\n            acceptElement(\"i\", CORE_LANG);\n            acceptElement(\"s\", CORE_LANG);\n            acceptElement(\"small\", CORE_LANG);\n            acceptElement(\"strike\", CORE_LANG);\n            acceptElement(\"tt\", CORE_LANG);\n            acceptElement(\"u\", CORE_LANG);\n        } else {\n            // allow the text, just strip the tags\n        }\n\n        if (ENABLE_LIST_TAGS) {\n            acceptElement(\"dir\", CORE_LANG+\"compact\");\n            acceptElement(\"dl\", CORE_LANG);\n            acceptElement(\"dt\", CORE_LANG);\n            acceptElement(\"li\", CORE_LANG+\"type,value\");\n            acceptElement(\"ol\", CORE_LANG+\"compact,start,type\");\n            acceptElement(\"ul\", CORE_LANG+\"compact,type\");\n            acceptElement(\"dd\", CORE_LANG);\n            acceptElement(\"menu\", CORE_LANG+\"compact\");\n        } else {\n            // allow the text, just strip the tags\n        }\n\n        if (ENABLE_PHRASE_TAGS) {\n            acceptElement(\"abbr\", CORE_LANG);\n            acceptElement(\"acronym\", CORE_LANG);\n            acceptElement(\"cite\", CORE_LANG);\n            acceptElement(\"code\", CORE_LANG);\n            acceptElement(\"dfn\", CORE_LANG);\n            acceptElement(\"em\", CORE_LANG);\n            acceptElement(\"kbd\", CORE_LANG);\n            acceptElement(\"samp\", CORE_LANG);\n            acceptElement(\"strong\", CORE_LANG);\n            acceptElement(\"var\", CORE_LANG);\n        } else {\n            // allow the text, just strip the tags\n        }\n\n        if (ENABLE_TABLE_TAGS) {\n            acceptElement(\"caption\", CORE_LANG+\"align\");\n            acceptElement(\"col\",CORE_LANG+\"alink,background,char,charoff,span,valign,width\");\n            acceptElement(\"colgroup\", CORE_LANG+\"alink,background,char,charoff,span,valign,width\");\n            acceptElement(\"table\", CORE_LANG+\"align,valign,background,bgcolor,border,cellpadding,cellspacing,frame,rules,summary,width\");\n            acceptElement(\"tbody\", CORE_LANG+\"align,background,char,charoff,valign\");\n            acceptElement(\"td\", CORE_LANG+\"abbr,align,axis,background,bgcolor,char,charoff,colspan,headers,height,nowrap,rowspan,scope,,valign,width\");\n            acceptElement(\"tfoot\", CORE_LANG+\"align,background,char,charoff,valign\");\n            acceptElement(\"th\", CORE_LANG+\"abbr,align,axis,background,bgcolor,char,charoff,colspan,headers,height,nowrap,rowspan,scope,valign,width\");\n            acceptElement(\"thead\", CORE_LANG+\"align,background,char,charoff,valign\");\n            acceptElement(\"tr\", CORE_LANG+\"align,background,bgcolor,char,charoff,valign\");\n        } else {\n            // allow the text, just strip the tags\n        }\n\n\n        if (ENABLE_INPUT_TAGS) {\n            acceptElement(\"area\", CORE_LANG+KBD+\"alt,coords,href,nohref,shape,target\");\n            acceptElement(\"button\", CORE_LANG+KBD+\"disabled,name,type,value\");\n            acceptElement(\"fieldset\", CORE_LANG);\n            acceptElement(\"form\", CORE_LANG+\"action,accept,acceptcharset,enctype,method,name,target\");\n            acceptElement(\"input\", CORE_LANG+\"accept,align,alt,checked,disabled,maxlength,name,readonly,size,src,type,value\");\n            acceptElement(\"legend\", CORE_LANG+\"align\");\n            acceptElement(\"map\", CORE_LANG+\"name\");\n            acceptElement(\"optgroup\", CORE_LANG+\"disabled,label\");\n            acceptElement(\"option\", CORE_LANG+KBD+\"disabled,label,selected,value\");\n            acceptElement(\"select\", CORE_LANG+KBD+\"disabled,multiple,name,size\");\n            acceptElement(\"textarea\", CORE_LANG+\"cols,disabled,name,readonly,rows\");\n        } else {\n            removeElement(\"area\");\n            removeElement(\"button\");\n            removeElement(\"fieldset\");\n            removeElement(\"form\");\n            removeElement(\"input\");\n            removeElement(\"legend\");\n            removeElement(\"map\");\n            removeElement(\"optgroup\");\n            removeElement(\"option\");\n            removeElement(\"select\");\n            removeElement(\"textarea\");\n        }\n\n        // completely remove these elements and all enclosing tags/text\n        removeElement(\"applet\");\n        removeElement(\"frame\");\n        removeElement(\"frameset\");\n        removeElement(\"iframe\");\n        removeElement(\"object\");\n        removeElement(\"script\");\n\n        // don't remove \"content\" of these tags since they have none.\n        //removeElement(\"meta\");\n        //removeElement(\"param\");\n    }\n\n    /**\n     * @param neuterImages\n     */\n    public DefangFilter(boolean neuterImages) {\n        mNeuterImages = neuterImages;\n        if (ZThreadLocal.getRequestContext() != null) {\n            this.reqVirtualHost = ZThreadLocal.getRequestContext().getVirtualHost();\n        }\n    }\n\n    /**\n     * Specifies that the given element should be accepted and, optionally,\n     * which attributes of that element should be kept.\n     *\n     * @param element The element to accept.\n     * @param attributes The comma-seperated list of attributes to be kept or null if no\n     *                   attributes should be kept for this element.\n     *\n     * see #removeElement\n     */\n    public static void acceptElement(String element, String attributes) {\n        element = element.toLowerCase();\n        HashSet<String> set = mAttrSetCache.get(attributes);\n        if (set != null) {\n            //System.out.println(element+\" cached set \"+set.size());\n            mAcceptedElements.put(element, set);\n            return;\n        }\n        set = new HashSet<String>();\n        String attrs[] = attributes.toLowerCase().split(\",\");\n        if (attrs != null && attrs.length > 0) {\n            for (int i=0; i < attrs.length; i++) {\n                //deal with consecutive commas\n                if (attrs[i].length() > 0)\n                    set.add(attrs[i]);\n            }\n        }\n        mAcceptedElements.put(element, set);\n        mAttrSetCache.put(attributes, set);\n    }\n\n    /**\n     * Specifies that the given element should be completely removed. If an\n     * element is encountered during processing that is on the remove list,\n     * the element's start and end tags as well as all of content contained\n     * within the element will be removed from the processing stream.\n     *\n     * @param element The element to completely remove.\n     */\n    public static void removeElement(String element) {\n        String key = element.toLowerCase();\n        Object value = NULL;\n        mRemovedElements.put(key, value);\n    }\n\n    //\n    // XMLDocumentHandler methods\n    //\n\n    // since Xerces-J 2.2.0\n\n    /** Start document. */\n    @Override\n    public void startDocument(XMLLocator locator, String encoding,\n                              NamespaceContext nscontext, Augmentations augs)\n    throws XNIException {\n        mRemovalElementCount = 0;\n        super.startDocument(locator, encoding, nscontext, augs);\n    }\n\n    // old methods\n\n    /** Start document. */\n    @Override public void startDocument(XMLLocator locator, String encoding, Augmentations augs)\n    throws XNIException {\n        startDocument(locator, encoding, null, augs);\n    }\n\n    /** Start prefix mapping. */\n    @Override public void startPrefixMapping(String prefix, String uri, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.startPrefixMapping(prefix, uri, augs);\n        }\n    }\n\n    /** Start element. */\n    @Override public void startElement(QName element, XMLAttributes attributes, Augmentations augs)\n    throws XNIException {\n        String name = element.localpart;\n        if (mRemovalElementName == null) {\n            if (handleOpenTag(element, attributes))\n                super.startElement(element, attributes, augs);\n        } else {\n            if (name.equalsIgnoreCase(mRemovalElementName))\n                mRemovalElementCount++;\n        }\n        if (name.equalsIgnoreCase(\"style\"))\n            mStyleDepth++;\n    }\n\n    /** Empty element. */\n    @Override public void emptyElement(QName element, XMLAttributes attributes, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null && handleOpenTag(element, attributes)) {\n            super.emptyElement(element, attributes, augs);\n        }\n    }\n\n    /** Comment. */\n    @Override public void comment(XMLString text, Augmentations augs)\n    throws XNIException {\n        // we can safely ignore comments\n        // they can only provide loop holes for hackers to exploit\n        // e.g. CDATA sections are reported as comments with our HTML parser configuration\n    }\n\n    /** Processing instruction. */\n    @Override public void processingInstruction(String target, XMLString data, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.processingInstruction(target, data, augs);\n        }\n    }\n\n    /** Characters. */\n    @Override public void characters(XMLString text, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            if (mStyleDepth > 0) {\n                String result = sanitizeStyleValue(text.toString());\n                super.characters(new XMLString(result.toCharArray(), 0, result.length()), augs);\n            } else {\n                super.characters(text, augs);\n            }\n        }\n    }\n\n    private static final Pattern COMMENT = Pattern.compile(LC.defang_comment.value());\n    // matches functions (like url(), expression(), etc), except rgb()\n    private static final Pattern STYLE_UNWANTED_FUNC =\n            Pattern.compile(LC.defang_style_unwanted_func.value(), Pattern.CASE_INSENSITIVE);\n\n    private static String sanitizeStyleValue(String value) {\n        // remove comments\n        value = COMMENT.matcher(value).replaceAll(\"\");\n        // strip off unwanted functions\n        return STYLE_UNWANTED_FUNC.matcher(value).replaceAll(\"\");\n    }\n\n    /** Ignorable whitespace. */\n    @Override public void ignorableWhitespace(XMLString text, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.ignorableWhitespace(text, augs);\n        }\n    }\n\n    /** Start general entity. */\n    @Override public void startGeneralEntity(String name, XMLResourceIdentifier id, String encoding, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.startGeneralEntity(name, id, encoding, augs);\n        }\n    }\n\n    /** Text declaration. */\n    @Override public void textDecl(String version, String encoding, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.textDecl(version, encoding, augs);\n        }\n    }\n\n    /** End general entity. */\n    @Override public void endGeneralEntity(String name, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.endGeneralEntity(name, augs);\n        }\n    }\n\n    /** Start CDATA section. */\n    @Override public void startCDATA(Augmentations augs) throws XNIException {\n        if (mRemovalElementName == null) {\n            super.startCDATA(augs);\n        }\n    }\n\n    /** End CDATA section. */\n    @Override public void endCDATA(Augmentations augs) throws XNIException {\n        if (mRemovalElementName == null) {\n            super.endCDATA(augs);\n        }\n    }\n\n    /** End element. */\n    @Override public void endElement(QName element, Augmentations augs)\n    throws XNIException {\n        String name = element.localpart;\n        if (mRemovalElementName == null) {\n            if (elementAccepted(element.rawname))\n                super.endElement(element, augs);\n        } else {\n            if (name.equalsIgnoreCase(mRemovalElementName) && --mRemovalElementCount == 0)\n                mRemovalElementName = null;\n        }\n        if (name.equalsIgnoreCase(\"style\"))\n            mStyleDepth--;\n    }\n\n    /** End prefix mapping. */\n    @Override public void endPrefixMapping(String prefix, Augmentations augs)\n    throws XNIException {\n        if (mRemovalElementName == null) {\n            super.endPrefixMapping(prefix, augs);\n        }\n    }\n\n    //\n    // Protected methods\n    //\n\n    /** Returns true if the specified element is accepted. */\n    protected static boolean elementAccepted(String element) {\n        String key = element.toLowerCase();\n        return mAcceptedElements.containsKey(key);\n    }\n\n    /** Returns true if the specified element should be removed. */\n    protected static boolean elementRemoved(String element) {\n        String key = element.toLowerCase();\n        return mRemovedElements.containsKey(key);\n    }\n\n    /** Handles an open tag. */\n    protected boolean handleOpenTag(QName element, XMLAttributes attributes) {\n        String eName = element.rawname.toLowerCase();\n        if (eName.equals(\"base\")) {\n            int index = attributes.getIndex(\"href\");\n            if (index != -1) {\n                mBaseHref = attributes.getValue(index);\n                if (mBaseHref != null) {\n                    try {\n                        mBaseHrefURI = new URI(mBaseHref);\n                    } catch (URISyntaxException e) {\n                        if (!mBaseHref.endsWith(\"/\"))\n                            mBaseHref += \"/\";\n                    }\n                }\n            }\n        }\n        if (elementAccepted(element.rawname)) {\n            HashSet<String> value = mAcceptedElements.get(eName);\n            if (value != NULL) {\n                HashSet<String> anames = value;\n                int attributeCount = attributes.getLength();\n                for (int i = 0; i < attributeCount; i++) {\n                    String aName = attributes.getQName(i).toLowerCase();\n                    // remove the attribute if it isn't in the list of accepted names\n                    // or it has invalid content\n                    if (!anames.contains(aName) || removeAttrValue(eName, aName, attributes, i)) {\n                        attributes.removeAttributeAt(i--);\n                        attributeCount--;\n                    } else {\n                        sanitizeAttrValue(eName, aName, attributes, i);\n                    }\n                }\n            } else {\n                attributes.removeAllAttributes();\n            }\n\n            if (eName.equals(\"img\") || eName.equals(\"input\")) {\n                fixUrlBase(attributes, \"src\");\n            } else if (eName.equals(\"a\") || eName.equals(\"area\")) {\n                fixUrlBase(attributes, \"href\");\n            }\n            fixUrlBase(attributes, \"background\");\n\n\n            if (eName.equals(\"a\") || eName.equals(\"area\")) {\n                fixATag(attributes);\n            }\n            if (mNeuterImages) {\n                String srcValue = Strings.nullToEmpty(attributes.getValue(\"src\"));\n                if (eName.equals(\"img\") || eName.equals(\"input\")) {\n                    if (VALID_EXT_URL.matcher(srcValue).find() ||\n                       (!VALID_INT_IMG.matcher(srcValue).find() &&\n                       !VALID_IMG_FILE.matcher(srcValue).find())) {\n                            neuterTag(attributes, \"src\", \"df\");\n                        } else if (!VALID_INT_IMG.matcher(srcValue).find() &&\n                                    VALID_IMG_FILE.matcher(srcValue).find() &&\n                                    !VALID_CONVERTD_FILE.matcher(srcValue).find()) {\n                            neuterTag(attributes, \"src\", \"pn\");\n                        }\n                }\n                neuterTag(attributes, \"background\", \"df\");\n            }\n            return true;\n        } else if (elementRemoved(element.rawname)) {\n            mRemovalElementName = element.rawname;\n            mRemovalElementCount = 1;\n        }\n        return false;\n    }\n\n    private void fixUrlBase(XMLAttributes attributes, String attrName) {\n        int index = attributes.getIndex(attrName);\n        if (index != -1) {\n            String value = attributes.getValue(index);\n            if (mBaseHref != null && value != null && value.indexOf(\":\") == -1) {\n                if (mBaseHrefURI != null) {\n                    try {\n                        attributes.setValue(index, mBaseHrefURI.resolve(value).toString());\n                        return;\n                    } catch (IllegalArgumentException e) {\n                        // ignore and do string-logic\n                    }\n                }\n                attributes.setValue(index, mBaseHref+value);\n            }\n        }\n    }\n\n    /**\n     * @param attributes\n     */\n    private void neuterTag(XMLAttributes attributes, String aName, String prefix) {\n        String df_aName = prefix + aName;\n        int dfIndex = attributes.getIndex(df_aName);\n        int index = attributes.getIndex(aName);\n        if (index != -1) {\n            String aValue = attributes.getValue(index);\n            if (dfIndex != -1) {\n                attributes.setValue(dfIndex, aValue);\n            } else {\n                attributes.addAttribute(new QName(\"\", df_aName, df_aName, null), \"CDATA\", aValue);\n            }\n            attributes.removeAttributeAt(index);\n            // remove dups if there are multiple src attributes\n            index = attributes.getIndex(aName);\n            while (index != -1) {\n                attributes.removeAttributeAt(index);\n                index = attributes.getIndex(aName);\n            }\n        }\n    }\n\n    /**\n     * make sure all <a> tags have a target=\"_blank\" attribute set.\n     * @param attributes\n     */\n    private void fixATag(XMLAttributes attributes) {\n        // BEGIN: bug 7927\n        int index = attributes.getIndex(\"href\");\n        if (index == -1)\t// links that don't have a href don't need target=\"_blank\"\n            return;\n        String href = attributes.getValue(index);\n        if (href.indexOf('#') == 0) // LOCAL links don't need target=\"_blank\"\n            return;\n        // END: bug 7927\n        index = attributes.getIndex(\"target\");\n        if (index != -1) {\n            attributes.setValue(index, \"_blank\");\n        } else {\n            attributes.addAttribute(new QName(\"\", \"target\", \"target\", null), \"CDATA\", \"_blank\");\n        }\n    }\n    /**\n     * Checks to see if an attr value should just be removed\n     * @param eName The element name\n     * @param aName The attribute name\n     * @param attributes The set of the attribtues\n     * @param i The index of the attribute\n     * @return true if the attr should be removed, false if not\n     */\n    private boolean removeAttrValue(String eName, String aName, XMLAttributes attributes, int i) {\n        String value = attributes.getValue(i);\n        // get rid of any spaces that might throw off the regex\n        value = value == null? null: value.trim();\n\n\t\tif (aName.equalsIgnoreCase(\"href\")) {\n\t\t\tif (VALID_EXT_URL.matcher(value).find()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsanitizeAttrValue(eName, aName, attributes, i);\n\t\t} else if (aName.equalsIgnoreCase(\"longdesc\")\n\t\t\t\t|| aName.equalsIgnoreCase(\"usemap\")) {\n\t\t\tif (!VALID_EXT_URL.matcher(value).find()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n        // We'll treat the SRC a little different since deleting it\n        // may annoy the front end. Here, we'll check for\n        // a valid url as well as just a valid filename in the\n        // case that its an inline image\n        if(aName.equals(\"src\")) {\n            if (!(VALID_EXT_URL.matcher(value).find() ||\n                VALID_INT_IMG.matcher(value).find() ||\n                VALID_IMG_FILE.matcher(value).find())) {\n                attributes.setValue(i, \"#\");\n                return false;\n            }\n        }\n        return false;\n    }\n    /**\n     * sanitize an attr value. For now, this means stirpping out Java Script entity tags &{...},\n     * and <script> tags.\n     *\n     *\n     */\n    private void sanitizeAttrValue(String eName, String aName, XMLAttributes attributes, int i) {\n        String value = attributes.getValue(i);\n        String result = AV_JS_ENTITY.matcher(value).replaceAll(\"JS-ENTITY-BLOCKED\");\n        result = AV_SCRIPT_TAG.matcher(result).replaceAll(\"SCRIPT-TAG-BLOCKED\");\n\n        if (aName.equalsIgnoreCase(\"href\")) {\n            result = AV_JAVASCRIPT.matcher(result).replaceAll(\"JAVASCRIPT-BLOCKED\");\n        }\n        if (aName.equalsIgnoreCase(\"style\")) {\n            result = sanitizeStyleValue(value);\n        }\n\n        if (!result.equals(value)) {\n            attributes.setValue(i, result);\n        }\n\n        if (aName.equalsIgnoreCase(\"action\") && sameHostFormPostCheck == true && this.reqVirtualHost != null) {\n            try {\n                URL url = new URL(value);\n                 String formActionHost = url.getHost().toLowerCase();\n\n                if (formActionHost.equalsIgnoreCase(reqVirtualHost)) {\n                    value = value.replace(formActionHost, \"SAMEHOSTFORMPOST-BLOCKED\");\n                    attributes.setValue(i, value);\n                }\n            } catch (MalformedURLException e) {\n                ZimbraLog.soap\n                    .info(\"Failure while trying to block mailicious code. Check for URL \"\n                        + \" match between the host and the action URL of a FORM.\"\n                        + \"Error parsing URL, possible relative URL.\" + e.getMessage());\n                attributes.setValue(i, \"SAMEHOSTFORMPOST-BLOCKED\");\n            }\n\n        }\n    }\n\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-mailbox",
    "commit": "fa5feee2a9255632adb6c124c6396eda215bc71a",
    "commit_msg": "(split)Bug: 84337\nPrivacy leak and possible XSS in ZWC with Chrome 30 on Win 7 x64 when viewing a conversation\n\n- Added a regex in defanger to strip any @import followed by url\n- Added unit test\n-Verified in dev environment that with this modification the '@import url' is removed from style element\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=84337\n\nCopied from Perforce\n Change: 486799",
    "original_file": "DefangFilter.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 23,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2010 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.imap;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.TimerTask;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.soap.SoapProtocol;\nimport com.zimbra.common.util.ByteUtil;\nimport com.zimbra.common.util.Constants;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.imap.ImapHandler.ImapExtension;\nimport com.zimbra.cs.index.SearchParams;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.index.ZimbraHit;\nimport com.zimbra.cs.index.ZimbraQueryResults;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.OperationContext;\nimport com.zimbra.cs.mailbox.SearchFolder;\nimport com.zimbra.cs.service.util.ItemId;\nimport com.zimbra.cs.session.Session;\nimport com.zimbra.cs.util.Zimbra;\n\npublic class ImapSessionManager {\n    private static final LinkedHashMap<ImapSession, Object> sSessionMap = new LinkedHashMap<ImapSession, Object>(128, (float) 0.75, true);\n\n    static void recordAccess(ImapSession session) {\n        synchronized (sSessionMap) {\n            // LinkedHashMap bumps to beginning of iterator order on access\n            sSessionMap.get(session);\n        }\n    }\n\n    static void uncacheSession(ImapSession session) {\n        synchronized (sSessionMap) {\n            sSessionMap.remove(session);\n        }\n    }\n\n    private static final long SERIALIZER_INTERVAL_MSEC = DebugConfig.imapSessionSerializerFrequency * Constants.MILLIS_PER_SECOND;\n    private static SessionSerializerTask sSerializerTask = null;\n\n    static void startup() {\n        synchronized (sSessionMap) {\n            if (SERIALIZER_INTERVAL_MSEC > 0 && sSerializerTask == null) {\n                Zimbra.sTimer.schedule(sSerializerTask = new SessionSerializerTask(), SERIALIZER_INTERVAL_MSEC, SERIALIZER_INTERVAL_MSEC);\n                ZimbraLog.imap.debug(\"initializing IMAP session serializer task\");\n            }\n        }\n    }\n\n    // things to do during the task:\n    //   1. deserialize/reserialize sessions with notification overflow\n    //   2. serialize enough sessions to get under the max memory footprint\n    //   3. prune noninteractive sessions beyond a specified count\n    //   4. maybe checkpoint a few \"dirty\" sessions if we're not doing anything else?\n    static class SessionSerializerTask extends TimerTask {\n        private static final long SESSION_INACTIVITY_SERIALIZATION_TIME = DebugConfig.imapSessionInactivitySerializationTime * Constants.MILLIS_PER_SECOND;\n        private static final int TOTAL_SESSION_FOOTPRINT_LIMIT = DebugConfig.imapTotalNonserializedSessionFootprintLimit;\n        private static final int MAX_NONINTERACTIVE_SESSIONS = DebugConfig.imapNoninteractiveSessionLimit;\n\n        @Override public void run() {\n            ZimbraLog.imap.debug(\"running IMAP session serializer task\");\n\n            long cutoff = SESSION_INACTIVITY_SERIALIZATION_TIME > 0 ? System.currentTimeMillis() - SESSION_INACTIVITY_SERIALIZATION_TIME : Long.MIN_VALUE;\n\n            List<ImapSession> overflow = new ArrayList<ImapSession>();\n            List<ImapSession> pageable = new ArrayList<ImapSession>();\n            List<ImapSession> droppable = new ArrayList<ImapSession>();\n\n            synchronized (sSessionMap) {\n                // first, figure out the set of sessions that'll need to be brought into memory and reserialized\n                int footprint = 0, maxOverflow = 0, noninteractive = 0;\n                for (ImapSession session : sSessionMap.keySet()) {\n                    if (session.requiresReload()) {\n                        overflow.add(session);\n                        // note that these will add to the memory footprint temporarily, so need the largest size...\n                        maxOverflow = Math.max(maxOverflow, session.getEstimatedSize());\n                    }\n                }\n                footprint += Math.min(maxOverflow, TOTAL_SESSION_FOOTPRINT_LIMIT - 1000);\n\n                // next, get the set of in-memory sessions that need to get serialized out\n                for (ImapSession session : sSessionMap.keySet()) {\n                    int size = session.getEstimatedSize();\n                    // want to serialize enough sessions to get below the memory threshold\n                    // also going to serialize anything that's been idle for a while\n                    if (!session.isInteractive() && ++noninteractive > MAX_NONINTERACTIVE_SESSIONS)\n                        droppable.add(session);\n                    else if (!session.isSerialized() && session.getLastAccessTime() < cutoff)\n                        pageable.add(session);\n                    else if (footprint + size > TOTAL_SESSION_FOOTPRINT_LIMIT)\n                        pageable.add(session);\n                    else\n                        footprint += size;\n                }\n            }\n\n            for (ImapSession session : pageable) {\n                try {\n                    ZimbraLog.imap.debug(\"  ** paging out session due to staleness or total memory footprint: %s (sid %s)\", session.getPath(), session.getSessionId());\n                    session.unload();\n                } catch (Exception e) {\n                    ZimbraLog.imap.warn(\"error serializing session; clearing\", e);\n                    // XXX: make sure this doesn't result in a loop\n                    quietRemoveSession(session);\n                }\n            }\n\n            for (ImapSession session : overflow) {\n                try {\n                    ZimbraLog.imap.debug(\"  ** loading/unloading paged session due to queued notification overflow: %s (sid %s)\", session.getPath(), session.getSessionId());\n                    session.reload();\n                    session.unload();\n                } catch (Exception e) {\n                    ZimbraLog.imap.warn(\"error deserializing overflowed session; clearing\", e);\n                    // XXX: make sure this doesn't result in a loop\n                    quietRemoveSession(session);\n                }\n            }\n\n            for (ImapSession session : droppable) {\n                ZimbraLog.imap.debug(\"  ** removing session due to having too many noninteractive sessions: %s (sid %s)\", session.getPath(), session.getSessionId());\n                // only noninteractive sessions get added to droppable list, so this next conditional should never be true\n                quietRemoveSession(session);\n            }\n        }\n\n        private static void quietRemoveSession(ImapSession session) {\n            // XXX: make sure this doesn't result in a loop\n            try {\n                if (session.isInteractive())\n                    session.cleanup();\n                session.detach();\n            } catch (Exception e) {\n                ZimbraLog.imap.warn(\"skipping error while trying to remove session\", e);\n            }\n        }\n    }\n\n\n    static class InitialFolderValues {\n        final int uidnext, modseq;\n        int firstUnread = -1;\n\n        InitialFolderValues(Folder folder) {\n            uidnext = folder.getImapUIDNEXT();\n            modseq = folder.getImapMODSEQ();\n        }\n    }\n\n    static final boolean CONSISTENCY_CHECK = DebugConfig.imapCacheConsistencyCheck;\n\n    static Pair<ImapSession, InitialFolderValues> openFolder(ImapPath path, byte params, ImapHandler handler) throws ServiceException {\n        boolean debug = ZimbraLog.imap.isDebugEnabled();\n        if (debug)  ZimbraLog.imap.debug(\"  ** opening folder: \" + path);\n\n        if (!path.isSelectable())\n            throw ServiceException.PERM_DENIED(\"cannot select folder: \" + path);\n        if ((params & ImapFolder.SELECT_CONDSTORE) != 0)\n            handler.activateExtension(ImapExtension.CONDSTORE);\n\n        Folder folder = (Folder) path.getFolder();\n        int folderId = folder.getId();\n        Mailbox mbox = folder.getMailbox();\n        // don't have a session when the folder is loaded...\n        OperationContext octxt = handler.getCredentials().getContext();\n\n        mbox.beginTrackingImap();\n\n        List<ImapMessage> i4list = null;\n        // *always* recalculate the contents of search folders\n        if (folder instanceof SearchFolder)\n            i4list = loadVirtualFolder(octxt, (SearchFolder) folder);\n\n        synchronized (mbox) {\n            // need mInitialRecent to be set *before* loading the folder so we can determine what's \\Recent\n            folder = mbox.getFolderById(octxt, folderId);\n            int recentCutoff = folder.getImapRECENTCutoff();\n\n            if (i4list == null) {\n                List<Session> listeners = mbox.getListeners(Session.Type.IMAP);\n                // first option is to duplicate an existing registered session\n                //   (could try to just activate an inactive session, but this logic is simpler for now)\n                i4list = duplicateExistingSession(folderId, listeners);\n                // no matching session means we next check for serialized folder data\n                if (i4list == null)\n                    i4list = duplicateSerializedFolder(folder);\n                // do the consistency check, if requested\n                if (CONSISTENCY_CHECK)\n                    i4list = consistencyCheck(i4list, mbox, octxt, folderId);\n                // no matching serialized session means we have to go to the DB to get the messages\n                if (i4list == null)\n                    i4list = mbox.openImapFolder(octxt, folderId);\n            }\n\n            Collections.sort(i4list);\n            // check messages for imapUid <= 0 and assign new IMAP IDs if necessary\n            renumberMessages(octxt, mbox, i4list);\n\n            ImapFolder i4folder = new ImapFolder(path, params, handler);\n\n            // don't rely on the <code>Folder</code> object being updated in place\n            folder = mbox.getFolderById(octxt, folderId);\n            // can't set these until *after* loading the folder because UID renumbering affects them\n            InitialFolderValues initial = new InitialFolderValues(folder);\n\n            StringBuilder added = debug ? new StringBuilder(\"  ** added: \") : null;\n            for (ImapMessage i4msg : i4list) {\n                i4folder.cache(i4msg, i4msg.imapUid > recentCutoff);\n                if (initial.firstUnread == -1 && (i4msg.flags & Flag.BITMASK_UNREAD) != 0)\n                    initial.firstUnread = i4msg.sequence;\n                if (debug)  added.append(' ').append(i4msg.msgId);\n            }\n            i4folder.setInitialSize();\n            if (debug)  ZimbraLog.imap.debug(added);\n\n            ImapSession session = null;\n            try {\n                session = new ImapSession(i4folder, handler);\n                session.register();\n                synchronized (sSessionMap) {\n                    sSessionMap.put(session, null);\n                }\n                return new Pair<ImapSession, InitialFolderValues>(session, initial);\n            } catch (ServiceException e) {\n                if (session != null)\n                    session.unregister();\n                throw e;\n            }\n        }\n    }\n\n    /** Fetches the messages contained within a search folder.  When a search\n     *  folder is IMAP-visible, it appears in folder listings, is SELECTable\n     *  READ-ONLY, and appears to have all matching messages as its contents.\n     *  If it is not visible, it will be completely hidden from all IMAP\n     *  commands.\n     * @param octxt   Encapsulation of the authenticated user.\n     * @param search  The search folder being exposed. */\n    private static List<ImapMessage> loadVirtualFolder(OperationContext octxt, SearchFolder search) throws ServiceException {\n        List<ImapMessage> i4list = new ArrayList<ImapMessage>();\n\n        Set<MailItem.Type> types = ImapFolder.getTypeConstraint(search);\n        if (types.isEmpty()) {\n            return i4list;\n        }\n\n        SearchParams params = new SearchParams();\n        params.setQueryStr(search.getQuery());\n        params.setIncludeTagDeleted(true);\n        params.setTypes(types);\n        params.setSortBy(SortBy.DATE_ASCENDING);\n        params.setChunkSize(1000);\n        params.setMode(Mailbox.SearchResultMode.IMAP);\n\n        Mailbox mbox = search.getMailbox();\n        try {\n            ZimbraQueryResults zqr = mbox.index.search(SoapProtocol.Soap12, octxt, params);\n            try {\n                for (ZimbraHit hit = zqr.getNext(); hit != null; hit = zqr.getNext())\n                    i4list.add(hit.getImapMessage());\n            } finally {\n                zqr.doneWithSearchResults();\n            }\n        } catch (ServiceException e) {\n            throw e;\n        } catch (Exception e) {\n            throw ServiceException.FAILURE(\"failure opening search folder\", e);\n        }\n        return i4list;\n    }\n\n    private static List<ImapMessage> duplicateExistingSession(int folderId, List<Session> sessionList) {\n        for (Session session : sessionList) {\n            ImapSession i4listener = (ImapSession) session;\n            if (i4listener.getFolderId() == folderId) {\n                //   FIXME: may want to prefer loaded folders over paged-out folders\n                synchronized (i4listener) {\n                    try {\n                        // found a matching session, so just copy its contents!\n                        ZimbraLog.imap.debug(\"  ** copying message data from existing session: \" + i4listener.getPath());\n\n                        ImapFolder i4selected = i4listener.getImapFolder();\n                        List<ImapMessage> i4list = new ArrayList<ImapMessage>(i4selected.getSize());\n                        for (ImapMessage i4msg : i4selected) {\n                            if (!i4msg.isExpunged())\n                                i4list.add(new ImapMessage(i4msg));\n                        }\n\n                        // if we're duplicating an inactive session, nuke that other session\n                        // XXX: watch out for deadlock between this and the SessionCache\n                        if (!i4listener.isInteractive())\n                            i4listener.unregister();\n\n                        return i4list;\n                    } catch (IOException ioe) {\n                        ZimbraLog.imap.warn(\"skipping error while trying to page in for copy (\" + i4listener.getPath() + \")\", ioe);\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private static List<ImapMessage> duplicateSerializedFolder(Folder folder) {\n        try {\n            ImapFolder i4folder = mSerializer.deserialize(cacheKey(folder));\n            if (i4folder == null)\n                return null;\n\n            ZimbraLog.imap.debug(\"  ** copying message data from serialized session: \" + folder.getPath());\n\n            List<ImapMessage> i4list = new ArrayList<ImapMessage>(i4folder.getSize());\n            for (ImapMessage i4msg : i4folder) {\n                if (!i4msg.isExpunged())\n                    i4list.add(i4msg.reset());\n            }\n            return i4list;\n        } catch (IOException ioe) {\n            if (!(ioe instanceof FileNotFoundException))\n                ZimbraLog.imap.warn(\"skipping error while trying to deserialize for copy (\" + new ItemId(folder) + \")\", ioe);\n            return null;\n        }\n    }\n\n    private static List<ImapMessage> consistencyCheck(List<ImapMessage> i4list, Mailbox mbox, OperationContext octxt, int folderId) {\n        if (i4list == null)\n            return i4list;\n\n        String fid = mbox.getAccountId() + \":\" + folderId;\n        try {\n            List<ImapMessage> actualContents = mbox.openImapFolder(octxt, folderId);\n            if (i4list.size() != actualContents.size()) {\n                ZimbraLog.imap.error(\"IMAP session cache consistency check failed (%s): inconsistent list lengths\", fid);\n                return actualContents;\n            }\n            for (Iterator<ImapMessage> it1 = i4list.iterator(), it2 = actualContents.iterator(); it1.hasNext() || it2.hasNext(); ) {\n                ImapMessage msg1 = it1.next(), msg2 = it2.next();\n                if (msg1.msgId != msg2.msgId || msg1.imapUid != msg2.imapUid) {\n                    ZimbraLog.imap.error(\"IMAP session cache consistency check failed (%s): id mismatch (%d/%d vs %d/%d)\",\n                            fid, msg1.msgId, msg1.imapUid, msg2.msgId, msg2.imapUid);\n                    return actualContents;\n                } else if (msg1.tags != msg2.tags || msg1.flags != msg2.flags || msg1.sflags != msg2.sflags) {\n                    ZimbraLog.imap.error(\"IMAP session cache consistency check failed (%s): flag/tag/sflag mismatch (%X/%X/%X vs %X/%X/%X)\",\n                            fid, msg1.flags, msg1.tags, msg1.sflags, msg2.flags, msg2.tags, msg2.sflags);\n                    return actualContents;\n                }\n            }\n            return i4list;\n        } catch (ServiceException e) {\n            ZimbraLog.imap.info(\"  ** error caught during IMAP session cache consistency check; falling back to reload\", e);\n            return null;\n        }\n    }\n\n    private static void renumberMessages(OperationContext octxt, Mailbox mbox, List<ImapMessage> i4sorted)\n    throws ServiceException {\n        List<ImapMessage> unnumbered = new ArrayList<ImapMessage>();\n        List<Integer> renumber = new ArrayList<Integer>();\n        while (!i4sorted.isEmpty() && i4sorted.get(0).imapUid <= 0) {\n            ImapMessage i4msg = i4sorted.remove(0);\n            unnumbered.add(i4msg);  renumber.add(i4msg.msgId);\n        }\n        if (!renumber.isEmpty()) {\n            List<Integer> newIds = mbox.resetImapUid(octxt, renumber);\n            for (int i = 0; i < newIds.size(); i++)\n                unnumbered.get(i).imapUid = newIds.get(i);\n            i4sorted.addAll(unnumbered);\n        }\n    }\n\n\n    private static final boolean TERMINATE_ON_CLOSE = DebugConfig.imapTerminateSessionOnClose;\n    private static final boolean SERIALIZE_ON_CLOSE = DebugConfig.imapSerializeSessionOnClose;\n\n    static void closeFolder(ImapSession session, boolean isUnregistering) {\n        // XXX: does this require synchronization?\n\n        // detach session from handler and jettison session state from folder\n        if (session.isInteractive())\n            session.inactivate();\n\n        // no fancy stuff for search folders since they're always recalculated on load\n        if (session.isVirtual()) {\n            session.detach();\n            return;\n        }\n\n        // checkpoint the folder data if desired\n        if (SERIALIZE_ON_CLOSE) {\n            try {\n                // could use session.serialize() if we want to leave it in memory...\n                ZimbraLog.imap.debug(\"  ** paging session during close: \" + session.getPath());\n                session.unload();\n            } catch (Exception e) {\n                ZimbraLog.imap.warn(\"  ** skipping error while trying to serialize during close (\" + session.getPath() + \")\", e);\n            }\n        }\n\n        if (isUnregistering)\n            return;\n\n        // recognize if we're not configured to allow sessions to hang around after end of SELECT\n        if (TERMINATE_ON_CLOSE) {\n            session.detach();\n            return;\n        }\n\n        // if there are still other listeners on this folder, this session is unnecessary\n        Mailbox mbox = session.getMailbox();\n        if (mbox != null) {\n            synchronized (mbox) {\n                for (Session listener : mbox.getListeners(Session.Type.IMAP)) {\n                    ImapSession i4listener = (ImapSession) listener;\n                    if (i4listener != session && i4listener.getFolderId() == session.getFolderId()) {\n                        session.detach();\n                        recordAccess(i4listener);\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n\n    public static String cacheKey(ImapSession session) throws ServiceException {\n        Mailbox mbox = session.getMailbox();\n        if (mbox == null)\n            mbox = MailboxManager.getInstance().getMailboxByAccountId(session.getTargetAccountId());\n\n        String cachekey = cacheKey(mbox.getFolderById(session.getFolderId()));\n        // if there are unnotified expunges, *don't* use the default cache key\n        //   ('+' is a good separator because it alpha-sorts before the '.' of the filename extension)\n        return session.hasExpunges() ? cachekey + \"+\" + session.getQualifiedSessionId() : cachekey;\n    }\n\n    public static String cacheKey(Folder folder) {\n        Mailbox mbox = folder.getMailbox();\n        int modseq = folder instanceof SearchFolder ? mbox.getLastChangeID() : folder.getImapMODSEQ();\n        int uvv = folder instanceof SearchFolder ? mbox.getLastChangeID() : ImapFolder.getUIDValidity(folder);\n        // 0-pad the MODSEQ and UVV so alpha ordering sorts properly\n        return String.format(\"%s_%d_%010d_%010d\", mbox.getAccountId(), folder.getId(), modseq, uvv);\n    }\n\n    private static final FolderSerializer mSerializer = new DiskSerializer();\n\n    static void serialize(String cachekey, ImapFolder i4folder) throws IOException {\n        mSerializer.serialize(cachekey, i4folder);\n    }\n\n    static ImapFolder deserialize(String cachekey) throws IOException {\n        return mSerializer.deserialize(cachekey);\n    }\n\n    interface FolderSerializer {\n        void serialize(String cachekey, ImapFolder i4folder) throws IOException;\n        ImapFolder deserialize(String cachekey) throws IOException;\n    }\n\n    static class DiskSerializer implements FolderSerializer {\n        private static final String CACHE_DATA_SUBDIR = \"data\" + File.separator + \"mailboxd\" + File.separator + \"imap\" + File.separator + \"cache\";\n        private static final File sCacheDir = new File(LC.zimbra_home.value() + File.separator + CACHE_DATA_SUBDIR);\n        private static final String IMAP_CACHEFILE_SUFFIX = \".i4c\";\n\n        DiskSerializer() {\n            sCacheDir.mkdirs();\n\n            // iterate over all serialized folders and delete all but the most recent\n            File[] allCached = sCacheDir.listFiles();\n            Arrays.sort(allCached, new Comparator<File>() {\n                @Override public int compare(File o1, File o2)  { return o1.getName().compareTo(o2.getName()); }\n            });\n            File previous = null;\n            String lastOwner = \"\", lastId = \"\";\n            for (File cached : allCached) {\n                String[] parts = cached.getName().split(\"_\");\n                if (previous != null && parts.length >= 4) {\n                    if (lastOwner.equals(parts[0]) && lastId.equals(parts[1]))\n                        previous.delete();\n                    else\n                        removeSessionFromFilename(previous);\n                }\n                lastOwner = parts[0];  lastId = parts[1];\n                previous = cached;\n            }\n            removeSessionFromFilename(previous);\n        }\n\n        /** Renames the passed-in <code>File</code> by removing everything\n         *  from the <tt>+</tt> character to the extension.  If the filename\n         *  does not contain '<tt>+</tt>', does nothing. */\n        private static void removeSessionFromFilename(File file) {\n            if (file == null)\n                return;\n            String filename = file.getName();\n            if (filename.indexOf(\"+\") != -1)\n                file.renameTo(new File(sCacheDir, filename.substring(0, filename.lastIndexOf(\"+\")) + IMAP_CACHEFILE_SUFFIX));\n        }\n\n        @Override public void serialize(String cachekey, ImapFolder i4folder) throws IOException {\n            File pagefile = new File(sCacheDir, cachekey + IMAP_CACHEFILE_SUFFIX);\n            if (pagefile.exists())\n                return;\n\n            FileOutputStream fos = null;\n            ObjectOutputStream oos = null;\n            try {\n                oos = new ObjectOutputStream(fos = new FileOutputStream(pagefile));\n                oos.writeObject(i4folder);\n            } catch (IOException ioe) {\n                ByteUtil.closeStream(oos);  oos = null;\n                ByteUtil.closeStream(fos);  fos = null;\n                pagefile.delete();\n                throw ioe;\n            } finally {\n                ByteUtil.closeStream(oos);\n                ByteUtil.closeStream(fos);\n            }\n        }\n\n        @Override public ImapFolder deserialize(String cachekey) throws IOException {\n            File pagefile = new File(sCacheDir, cachekey + IMAP_CACHEFILE_SUFFIX);\n            if (!pagefile.exists())\n                throw new FileNotFoundException(\"unable to deserialize folder state (pagefile not found)\");\n\n            FileInputStream fis = null;\n            ObjectInputStream ois = null;\n            try {\n                // read serialized ImapFolder from cache\n                ois = new ObjectInputStream(fis = new FileInputStream(pagefile));\n                return (ImapFolder) ois.readObject();\n            } catch (Exception e) {\n                ByteUtil.closeStream(ois);  ois = null;\n                ByteUtil.closeStream(fis);  fis = null;\n                pagefile.delete();\n                // IOException(String, Throwable) exists only since 1.6.\n                IOException ioe = new IOException(\"unable to deserialize folder state\");\n                ioe.initCause(e);\n                throw ioe;\n            } finally {\n                ByteUtil.closeStream(ois);\n                ByteUtil.closeStream(fis);\n            }\n        }\n    }\n}\n",
    "vulnerability_type": "Insecure Deserialization",
    "repo": "zm-mailbox",
    "commit": "41acee1d9f4bf33f2c2048049cb87e716bcce264",
    "commit_msg": "(split)bug:51321 IMAP cache using memcached\n- If memcached is available in the deployment (MemcachedConnector.isConnected() == true), MemcachedImapCache is used for caching ImapFolders which can get LRUed, and DiskImapCache for paging out live sessions which can't get LRUed. If memcached is not available, DiskImapCache is used for both cases.\n- Factored out DiskImapCache from ImapSessionManager.\n- Refactored the singleton implementation of ImapSessionManager.\n- Refactored the cache error handling by pretending as if it's a cache miss rather than throwing IOException.\n- Added back ImapSession serialization scheduler, which was somehow lost when NioServer was initially introduced.\n\nhttps://reviewboard.eng.vmware.com/r/200877/\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=51321\n\nCopied from Perforce\n Change: 270876",
    "original_file": "ImapSessionManager.java",
    "confidence_score": 0.8
  }
]