[
  {
    "serial_no": 1,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Writer;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\n\npublic class Derby extends Db {\n\n    private Map<Db.Error, String> mErrorCodes;\n    private Map<String, String> mIndexNames;\n\n    Derby() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DEADLOCK_DETECTED,        \"40000\");\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW,            \"23505\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT,    \"23503\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, \"23503\");\n        mErrorCodes.put(Db.Error.NO_SUCH_DATABASE,         \"42Y07\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE,            \"42X05\");\n\n        // indexes have different names under Derby\n        mIndexNames = new HashMap<String, String>();\n        mIndexNames.put(\"i_type\",           \"i_mail_item_type\");\n        mIndexNames.put(\"i_parent_id\",      \"fk_mail_item_parent_id\");\n        mIndexNames.put(\"i_folder_id_date\", \"i_mail_item_folder_id_date\");\n        mIndexNames.put(\"i_index_id\",       \"i_mail_item_index_id\");\n        mIndexNames.put(\"i_unread\",         \"i_mail_item_unread\");\n        mIndexNames.put(\"i_date\",           \"i_mail_item_date\");\n        mIndexNames.put(\"i_mod_metadata\",   \"i_mail_item_mod_metadata\");\n        mIndexNames.put(\"i_tags_date\",      \"i_mail_item_tags_date\");\n        mIndexNames.put(\"i_flags_date\",     \"i_mail_item_flags_date\");\n        mIndexNames.put(\"i_volume_id\",      \"i_mail_item_volume_id\");\n        mIndexNames.put(\"i_change_mask\",    \"i_mail_item_change_mask\");\n        mIndexNames.put(\"i_name_folder_id\", \"i_mail_item_name_folder_id\");\n    }\n\n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case BITWISE_OPERATIONS:         return false;\n            case BOOLEAN_DATATYPE:           return false;\n            case BROKEN_IN_CLAUSE:           return true;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return true;\n            case CLOB_COMPARISON:            return false;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return false;\n            case LIMIT_CLAUSE:               return false;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return true;\n            case REPLACE_INTO:               return false;\n            case ROW_LEVEL_LOCKING:          return true;\n            case UNIQUE_NAME_INDEX:          return false;\n            case AVOID_OR_IN_WHERE_CLAUSE:   return true;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Db.Error error) {\n        String code = mErrorCodes.get(error);\n        return (code != null && e.getSQLState().equals(code));\n    }\n\n    @Override String forceIndexClause(String index) {\n        String localIndex = mIndexNames.get(index);\n        if (localIndex == null) {\n            ZimbraLog.misc.warn(\"could not find derby equivalent from index \" + index);\n            return \"\";\n        }\n        return \" -- DERBY-PROPERTIES \" + (localIndex.startsWith(\"fk_\") ? \"constraint=\" : \"index=\") + localIndex + '\\n';\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"CASE WHEN \" + expr1 + \" IS NULL THEN \" + expr2 + \" ELSE \" + expr1 + \" END\";\n    }\n\n    @Override DbPool.PoolConfig getPoolConfig() {\n        return new DerbyConfig();\n    }\n    \n    @Override public boolean databaseExists(Connection conn, String databaseName)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        int numSchemas = 0;\n\n        try {\n            stmt = conn.prepareStatement(\n                \"SELECT COUNT(*) FROM SYS.SYSSCHEMAS \" +\n                \"WHERE schemaname = ?\");\n            stmt.setString(1, databaseName.toUpperCase());\n            rs = stmt.executeQuery();\n            rs.next();\n            numSchemas = rs.getInt(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to determine whether database exists\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return (numSchemas > 0);\n    }\n\n    @Override void shutdown() {\n    \ttry {\n    \t\tDriverManager.getConnection(\"jdbc:derby:\" + System.getProperty(\"derby.system.home\", LC.zimbra_home.value() + File.separator + \"derby\") + \";shutdown=true\");\n    \t} catch (Exception x) {\n    \t\t//an exception is always throw with a 08006 status to indicate shutdown\n    \t}\n    }\n\n    public static OutputStream disableDerbyLogFile(){\n        return new OutputStream() {\n            public void write(int b) {\n                // Ignore all log messages\n            }\n        };\n    }\n    \n    static final class DerbyConfig extends DbPool.PoolConfig {\n        DerbyConfig() {\n        \tProperties props = new Properties();\n        \ttry {\n                String propsfile = LC.get(\"zdesktop_derby_properties\");\n                if (propsfile == null || propsfile.equals(\"\"))\n                    propsfile = LC.derby_properties.value();\n        \t\tprops.load(new FileInputStream(propsfile));\n        \t} catch (FileNotFoundException x) {\n        \t} catch (IOException x) {\n        \t\tthrow new RuntimeException(x);\n        \t}\n\n        \tfor (Enumeration<?> e = props.propertyNames(); e.hasMoreElements(); ) {\n        \t\tString key = (String) e.nextElement();\n        \t\tSystem.setProperty(key, props.getProperty(key));\n        \t}\n\n            mDriverClassName = \"org.apache.derby.jdbc.EmbeddedDriver\";\n            mPoolSize = 12;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:derby:\" + System.getProperty(\"derby.system.home\", LC.zimbra_home.value() + File.separator + \"derby\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getDerbyProperties();\n\n            ZimbraLog.misc.debug(\"Setting connection pool size to \" + mPoolSize);\n        }\n\n        private static Properties getDerbyProperties() {\n            Properties props = new Properties();\n\n            props.put(\"cacheResultSetMetadata\", \"true\");\n            props.put(\"cachePrepStmts\", \"true\");\n            props.put(\"prepStmtCacheSize\", \"25\");        \n            props.put(\"autoReconnect\", \"true\");\n            props.put(\"useUnicode\", \"true\");\n            props.put(\"characterEncoding\", \"UTF-8\");\n            props.put(\"dumpQueriesOnException\", \"true\");\n            props.put(\"user\", LC.zimbra_mysql_user.value());\n            props.put(\"password\", LC.zimbra_mysql_password.value());\n\n            return props;\n        }\n    }\n\n    @Override public String toString() {\n        return \"derby\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the Derby versions tool\\n\" +\n                \"INSERT INTO zimbra.config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version'),\\n\" + \n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version'),\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version'),\\n\" +\n                \"\\t('offline.db.version', '\" + 2 + \"', 'offline db schema version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            if (output != null)\n                output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "d83d1dfa755247a7599d78e937498601129ec5ef",
    "commit_msg": "(split)bug: 38509\n\nAdd support for LC-based control over max # of databases attachable for a single SQLite connection.  The localconfig key for this is \"sqlite_max_attached_databases\"; defaults to 7.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=38509\n\nCopied from Perforce\n Change: 160923",
    "original_file": "Derby.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 2,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n    private String pageSize;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"column id is not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return true;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        cacheSize = LC.get(\"sqlite_cache_size\");\n        if (cacheSize.equals(\"0\"))\n            cacheSize = null;\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" + (cacheSize == null ? \"default\" : cacheSize) + \" page cache\");\n\n        pageSize = LC.get(\"sqlite_page_size\");\n        if (pageSize.equals(\"0\"))\n            pageSize = null;\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" + (pageSize == null ? \"default\" : pageSize + \"-byte\") + \" page size\");\n\n        super.startup(pool, poolSize);\n    }\n\n    @Override void postCreate(java.sql.Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            pragmas(conn, null);\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(java.sql.Connection conn, String dbname, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        \n        try {\n            String prefix = dbname == null || dbname.equals(\"zimbra\") ? \"\" : dbname + \".\";\n            (stmt = conn.prepareStatement(\"PRAGMA \" + prefix + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    void pragmas(java.sql.Connection conn, String dbname) throws SQLException {\n        pragma(conn, dbname, \"foreign_keys\", \"ON\");\n        pragma(conn, dbname, \"fullfsync\", \"OFF\");\n        pragma(conn, dbname, \"journal_mode\", \"PERSIST\");\n        pragma(conn, dbname, \"synchronous\", \"NORMAL\");\n        pragma(conn, dbname, \"encoding\", \"\\\"UTF-8\\\"\");\n\n        if (cacheSize != null) {\n            pragma(conn, dbname, \"cache_size\", cacheSize);\n            // leaving this uncommented seems to break subsequent PRAGMAs\n//            pragma(conn, dbname, \"default_cache_size\", cacheSize);\n        }\n        if (pageSize != null) {\n            pragma(conn, dbname, \"default_page_size\", pageSize);\n            pragma(conn, dbname, \"page_size\", pageSize);\n        }\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n                \n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    @SuppressWarnings(\"unused\")\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n            pragmas(conn.getConnection(), dbname);\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.error(\"database \" + dbname + \" attach failed\", e);\n            if (!\"database is already attached\".equals(e.getMessage()))\n                throw e;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n        \n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    @Override protected int getInClauseBatchSize() {\n        return 200;\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "42fb495e7c760bf2187f46b2a1fee8da1e42b1dc",
    "commit_msg": "(split)bug: 43649 add twice daily sqlite \"analyze\" optimization\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=43649\n\nCopied from Perforce\n Change: 222907",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 3,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport com.google.common.collect.HashMultimap;\nimport com.google.common.collect.Multimap;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.util.ZimbraApplication;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Date;\n\npublic class DbPendingAclPush {\n\n    public static String TABLE_PENDING_ACL_PUSH = \"pending_acl_push\";\n\n    private static boolean supported;\n\n    static {\n         supported = ZimbraApplication.getInstance().supports(DbPendingAclPush.class);\n    }\n\n    public static void queue(Mailbox mbox, int itemId) throws ServiceException {\n        if (!supported)\n            return;\n        if (mbox == null)\n            return;\n        ZimbraLog.mailbox.debug(\"Queuing for ACL push - mailbox %s item %s\", mbox.getId(), itemId);\n        DbConnection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            stmt = conn.prepareStatement(\n                    command + \" INTO \" + TABLE_PENDING_ACL_PUSH + \" (mailbox_id, item_id, date) VALUES (?, ?, ?)\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, itemId);\n            stmt.setLong(3, System.currentTimeMillis());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\n                    \"Unable to queue for ACL push - mailbox \" + mbox.getId() + \" item \" + itemId, e);\n        } finally {\n            conn.closeQuietly(stmt);\n        }\n\n        // unit tests using hsqldb could potentially cause integrity constraint violation\n        // because hsqldb does not support REPLACE command and if this method is called twice in\n        // the same millisecond with the same (mailbox_id, item_id). Sleeping for 2ms would\n        // take care of this.\n        try {\n            Thread.sleep(2);\n        } catch (InterruptedException ignored) {\n        }\n    }\n\n    public static Multimap<Integer, Integer> getEntries(Date uptoTime) throws ServiceException {\n        Multimap<Integer, Integer> mboxIdToItemIds = HashMultimap.create();\n        DbConnection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        ZimbraLog.misc.debug(\"Getting entries recorded before %s for ACL push\", uptoTime);\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                    \"SELECT mailbox_id, item_id FROM \" + TABLE_PENDING_ACL_PUSH + \" WHERE date < ?\");\n            stmt.setLong(1, uptoTime.getTime());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                mboxIdToItemIds.put(rs.getInt(1), rs.getInt(2));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get entries recorded before \" + uptoTime + \" for ACL push\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n        return mboxIdToItemIds;\n    }\n\n    public static void deleteEntries(Date uptoTime) throws ServiceException {\n        ZimbraLog.misc.debug(\"Deleting entries for ACL push before %s\", uptoTime);\n        DbConnection conn = null;\n        PreparedStatement stmt = null;\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                    \"DELETE FROM \" + TABLE_PENDING_ACL_PUSH + \" WHERE date < ?\");\n            stmt.setLong(1, uptoTime.getTime());\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete UID's\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "e5bf6cde467d2c315fc1c2147ab52902ed3c3402",
    "commit_msg": "(split)bug: 67380 - SendShareNotificationTest.shareByAdmin unit test failure - java.sql.SQLIntegrityConstraintViolationException\n\nNeed to worry about integrity constraint violation only when db does not support REPLACE.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=67380\n\nCopied from Perforce\n Change: 339122",
    "original_file": "DbPendingAclPush.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 4,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.cs.mailbox.ScheduledTask;\n\n/**\n * Database persistence code for <tt>DataSourceTask</tt>s.\n */\npublic class DbScheduledTask {\n\n    public static String TABLE_SCHEDULED_TASK = \"scheduled_task\";\n\n    /**\n     * Saves the given task to the database.\n     */\n    public static void createTask(DbConnection conn, ScheduledTask task)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        ZimbraLog.scheduler.debug(\"Creating %s\", task);\n\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\n                \"INSERT INTO \" + TABLE_SCHEDULED_TASK  +\n                \" (class_name, name, mailbox_id, exec_time, interval_millis, metadata) \" +\n                \"VALUES (?, ?, ?, ?, ?, ?)\");\n            stmt.setString(1, task.getClass().getName());\n            stmt.setString(2, task.getName());\n            stmt.setInt(3, task.getMailboxId());\n            stmt.setTimestamp(4, DbUtil.dateToTimestamp(task.getExecTime()));\n            if (task.getIntervalMillis() > 0) {\n                stmt.setLong(5, task.getIntervalMillis());\n            } else {\n                stmt.setNull(5, Types.INTEGER);\n            }\n            stmt.setString(6, getEncodedMetadata(task));\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to create \" + task, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Retrieves scheduled tasks from the database.\n     *\n     * @param className the <tt>ScheduledTask</tt> class name, or <tt>null</tt>\n     * for all classes\n     * @param mailboxId the mailbox ID, or <tt>0</tt> for all mailboxes\n     */\n    public static List<ScheduledTask> getTasks(String className, int mailboxId)\n    throws ServiceException {\n        ZimbraLog.scheduler.debug(\"Retrieving tasks for class %s, mailbox %d\", className, mailboxId);\n\n        List<ScheduledTask> tasks = new ArrayList<ScheduledTask>();\n\n        synchronized (DbMailbox.getSynchronizer()) {\n            DbConnection conn = null;\n            PreparedStatement stmt = null;\n            ResultSet rs = null;\n            try {\n                conn = DbPool.getConnection();\n                String sql =\n                    \"SELECT class_name, name, mailbox_id, exec_time, interval_millis, metadata \" +\n                    \"FROM \" + TABLE_SCHEDULED_TASK;\n                if (className != null) {\n                    sql += \" WHERE class_name = ?\";\n                }\n                if (mailboxId > 0) {\n                    if (className == null) {\n                        sql += \" WHERE mailbox_id = ?\";\n                    } else {\n                        sql += \" AND mailbox_id = ?\";\n                    }\n                }\n                stmt = conn.prepareStatement(sql);\n                int i = 1;\n                if (className != null) {\n                    stmt.setString(i++, className);\n                }\n                if (mailboxId > 0) {\n                    stmt.setInt(i++, mailboxId);\n                }\n\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    className = rs.getString(\"class_name\");\n                    String name = rs.getString(\"name\");\n                    ScheduledTask task = null;\n\n                    // Instantiate task\n                    try {\n                        Object obj = Class.forName(className).newInstance();\n                        if (obj instanceof ScheduledTask) {\n                            task = (ScheduledTask) obj;\n                        } else {\n                            ZimbraLog.scheduler.warn(\"Class %s is not an instance of ScheduledTask for task %s\",\n                                className, name);\n                            continue;\n                        }\n                    } catch (Exception e) {\n                        ZimbraLog.scheduler.warn(\"Unable to instantiate class %s for task %s.  \" +\n                            \"Class must be an instance of %s and have a constructor with no arguments.\",\n                            className, name, ScheduledTask.class.getSimpleName(), e);\n                        continue;\n                    }\n\n                    // Set member vars\n                    task.setMailboxId(rs.getInt(\"mailbox_id\"));\n                    task.setExecTime(DbUtil.timestampToDate(rs.getTimestamp(\"exec_time\")));\n                    task.setIntervalMillis(rs.getLong(\"interval_millis\"));\n\n                    try {\n                        setProperties(task, rs.getString(\"metadata\"));\n                    } catch (ServiceException e) {\n                        ZimbraLog.scheduler.warn(\"Unable to read metadata for %s.  Not scheduling this task.\", task, e);\n                        continue;\n                    }\n\n                    tasks.add(task);\n                }\n            } catch (SQLException e) {\n                throw ServiceException.FAILURE(\"Unable to get all DataSourceTasks\", e);\n            } finally {\n                DbPool.closeResults(rs);\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            }\n        }\n\n        ZimbraLog.scheduler.info(\"Loaded %d scheduled data source tasks\", tasks.size());\n        return tasks;\n    }\n\n    public static void updateTask(DbConnection conn, ScheduledTask task)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        ZimbraLog.scheduler.debug(\"Updating %s\", task);\n\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\n                \"UPDATE  \" + TABLE_SCHEDULED_TASK  +\n                \" SET mailbox_id = ?, exec_time = ?, interval_millis = ?, metadata = ? \" +\n                \"WHERE class_name = ? AND name = ?\");\n            stmt.setInt(1, task.getMailboxId());\n            stmt.setTimestamp(2, DbUtil.dateToTimestamp(task.getExecTime()));\n            if (task.getIntervalMillis() > 0) {\n                stmt.setLong(3, task.getIntervalMillis());\n            } else {\n                stmt.setNull(3, Types.INTEGER);\n            }\n            stmt.setString(4, getEncodedMetadata(task));\n            stmt.setString(5, task.getClass().getName());\n            stmt.setString(6, task.getName());\n\n            int numRows = stmt.executeUpdate();\n            if (numRows != 1) {\n                String msg = String.format(\"Unexpected number of rows (%d) updated for %s\", numRows, task);\n                throw ServiceException.FAILURE(msg, null);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to update \" + task, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void deleteTask(String className, String taskName)\n    throws ServiceException {\n        synchronized (DbMailbox.getSynchronizer()) {\n            DbConnection conn = null;\n            try {\n                conn = DbPool.getConnection();\n                deleteTask(conn, className, taskName);\n                conn.commit();\n            } finally {\n                DbPool.quietClose(conn);\n            }\n        }\n    }\n\n    public static void deleteTask(DbConnection conn, String className, String taskName)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        ZimbraLog.scheduler.debug(\"Deleting scheduled task from the database.  className=%s, taskName=%s\",\n            className, taskName);\n\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + TABLE_SCHEDULED_TASK  +\n                \" WHERE class_name = ? AND name = ?\");\n            stmt.setString(1, className);\n            stmt.setString(2, taskName);\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete scheduled task: className=\" +\n                className+ \", taskName=\" + taskName, e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static String getEncodedMetadata(ScheduledTask task) {\n        boolean hasProperties = false;\n        Metadata metadata = new Metadata();\n        Set<String> keys = task.getPropertyNames();\n        for (String key : keys) {\n            hasProperties = true;\n            metadata.put(key, task.getProperty(key));\n        }\n        if (!hasProperties) {\n            return null;\n        }\n        return metadata.toString();\n    }\n\n    private static void setProperties(ScheduledTask task, String encodedMetadata) throws ServiceException {\n        if (StringUtil.isNullOrEmpty(encodedMetadata)) {\n            return;\n        }\n\n        Metadata metadata = new Metadata(encodedMetadata);\n        Map<String, ?> map = metadata.asMap();\n        for (Map.Entry<String, ?> entry : map.entrySet()) {\n            if (entry.getValue() instanceof String) {\n                task.setProperty(entry.getKey(), (String) entry.getValue());\n            }\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "DbScheduledTask.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 5,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        return false;\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override public String scriptCommandDelimiter() {\n        return \"%\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        Map<String, String> pragmas = getCustomPragmas();\n\n        LinkedList<java.sql.Connection> connections = new LinkedList<java.sql.Connection>();\n        for (int i = 0; i < poolSize; i++) {\n            java.sql.Connection conn = pool.getConnection();\n            if (i == 0)\n                ZimbraLog.dbconn.info(\"sqlite driver running in \" + conn.getMetaData().getDriverVersion() + \" mode\");\n\n            try {\n                conn.setAutoCommit(true);\n                pragma(conn, \"synchronous\", \"NORMAL\");\n                pragma(conn, \"fullfsync\", \"0\");\n                pragma(conn, \"journal_mode\", \"PERSIST\");\n//                pragma(conn, \"locking_mode\", \"EXCLUSIVE\");\n                pragma(conn, \"legacy_file_format\", \"OFF\");\n//                pragma(conn, \"read_uncommitted\", \"1\");\n\n                for (Map.Entry<String, String> pragma : pragmas.entrySet())\n                    pragma(conn, pragma.getKey(), pragma.getValue());\n            } finally {\n                connections.add(conn);\n                conn.setAutoCommit(false);\n            }\n        }\n        for (java.sql.Connection conn : connections)\n            conn.close();\n\n        super.startup(pool, poolSize);\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private Map<String, String> getCustomPragmas() {\n        String propsfile = LC.get(\"sqlite_pragma_file\");\n        if (propsfile == null || propsfile.trim().equals(\"\"))\n            return Collections.emptyMap();\n\n        try {\n            Properties props = new Properties();\n            props.load(new FileInputStream(propsfile));\n            ZimbraLog.dbconn.info(\"reading custom sqlite pragmas from conf file: \" + propsfile);\n\n            Map<String, String> pragmas = new HashMap<String, String>(props.size() * 3 / 2);\n            for (Map.Entry<Object, Object> foo : props.entrySet())\n                pragmas.put((String) foo.getKey(), (String) foo.getValue());\n            return pragmas;\n        } catch (FileNotFoundException x) {\n            ZimbraLog.dbconn.info(\"no sqlite pragma conf file found; will use standard config\");\n        } catch (IOException x) {\n            ZimbraLog.dbconn.warn(\"exception reading from sqlite pragma conf file (\" + propsfile + \"); will use standard config\", x);\n        }\n        return Collections.emptyMap();\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = 7;\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(conn.getConnection());\n    }\n\n    private void recordAttachedDatabase(Connection conn, String dbname) {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(conn.getConnection(), attachedDBs);\n        }\n    }\n\n    @Override void registerDatabaseInterest(Connection conn, String dbname) throws SQLException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                if (detachDatabase(conn, it.next()))\n                    it.remove();\n            }\n        }\n\n        attachDatabase(conn, dbname);\n        recordAttachedDatabase(conn, dbname);\n    }\n\n    private void attachDatabase(Connection conn, String dbname) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.sqltrace.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // XXX: since it's so easy to end up with an empty SQLite database, make sure that the tables we want are actually in there\n        //   (yes, this assumes that we're looking for a MBOXGROUP database, which is beyond the scope of this method's contract)\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + dbname + \".sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= DbMailbox.sTables.length) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"foo\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.sqltrace.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    static String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    static final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            try {\n                String poolsize = LC.get(\"sqlite_pool_size\");\n                if (poolsize != null && !poolsize.trim().equals(\"\"))\n                    mPoolSize = Integer.parseInt(poolsize);\n            } catch (NumberFormatException nfe) {\n                ZimbraLog.system.warn(\"exception parsing 'sqlite_pool_size' config; defaulting pool size to \" + mPoolSize, nfe);\n            }\n            ZimbraLog.misc.info(\"setting connection pool size to \" + mPoolSize);\n        }\n\n        private static Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            if (output != null)\n                output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "76480739ac1daa242be3c9f704a59a0263c56009",
    "commit_msg": "(split)bug: 29563\n\nLog the loaded PRAGMAs when we read custom SQLite PRAGMAs from a preferences file.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 115307",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 6,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Formatter;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.DataSource;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.Metadata;\n\n\npublic class DbDataSource {\n\n    public static class DataSourceItem {\n        public int folderId;\n\tpublic int itemId;\n\tpublic String remoteId;\n\tpublic Metadata md;\n\tpublic int itemFlags = -1;\n\t\n\tpublic DataSourceItem(int f, int i, String r, Metadata m) {\n\t    folderId = f;\n\t    itemId = i;\n\t    remoteId = r;\n\t    md = m;\n\t}\n\n        public DataSourceItem(int f, int i, String r, Metadata m, int fl) {\n            this(f, i, r, m);\n            itemFlags = fl;\n        }\n    }\n\t\n    public static final String TABLE_DATA_SOURCE_ITEM = \"data_source_item\";\n\n    public static void addMapping(DataSource ds, DataSourceItem item) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        String dataSourceId = ds.getId();\n\n        if (item.remoteId == null)\n            item.remoteId = \"\";\n        \n        ZimbraLog.datasource.debug(\"Adding mapping for dataSource %s: itemId(%d), remoteId(%s)\", ds.getName(), item.itemId, item.remoteId);\n        \n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"INSERT INTO \");\n            sb.append(getTableName(mbox));\n            sb.append(\" (\");\n            sb.append(DbMailItem.MAILBOX_ID);\n            sb.append(\"data_source_id, item_id, folder_id, remote_id, metadata) VALUES (\");\n            sb.append(DbMailItem.MAILBOX_ID_VALUE);\n            sb.append(\"?, ?, ?, ?, ?)\");\n            if (Db.supports(Db.Capability.ON_DUPLICATE_KEY)) {\n            \tsb.append(\" ON DUPLICATE KEY UPDATE data_source_id = ?, item_id = ?, folder_id = ?, remote_id = ?, metadata = ?\");\n            }\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, dataSourceId);\n            stmt.setInt(i++, item.itemId);\n            stmt.setInt(i++, item.folderId);\n            stmt.setString(i++, item.remoteId);\n            stmt.setString(i++, DbMailItem.checkMetadataLength((item.md == null) ? null : item.md.toString()));\n            if (Db.supports(Db.Capability.ON_DUPLICATE_KEY)) {\n                stmt.setString(i++, dataSourceId);\n                stmt.setInt(i++, item.itemId);\n                stmt.setInt(i++, item.folderId);\n                stmt.setString(i++, item.remoteId);\n                stmt.setString(i++, DbMailItem.checkMetadataLength((item.md == null) ? null : item.md.toString()));\n            }\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            if (!Db.supports(Db.Capability.ON_DUPLICATE_KEY) && Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                DbPool.closeStatement(stmt);\n                DbPool.quietClose(conn);\n            \tupdateMapping(ds, item);\n            } else {\n                throw ServiceException.FAILURE(\"Unable to add mapping for dataSource \"+ds.getName(), e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void updateMapping(DataSource ds, DataSourceItem item) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\"Updating mapping for dataSource %s: itemId(%d), remoteId(%s)\", ds.getName(), item.itemId, item.remoteId);\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"UPDATE \");\n            sb.append(getTableName(mbox));\n            sb.append(\" SET folder_id = ?, remote_id = ?, metadata = ? WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\" item_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            stmt.setInt(i++, item.folderId);\n            stmt.setString(i++, item.remoteId);\n            stmt.setString(i++, DbMailItem.checkMetadataLength((item.md == null) ? null : item.md.toString()));\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setInt(i++, item.itemId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to update mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void deleteMappings(DataSource ds, Collection<Integer> itemIds) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\"Deleting %d mappings for dataSource %s\", itemIds.size(), ds.getName());\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"DELETE FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\" data_source_id = ? AND item_id IN \");\n            sb.append(DbUtil.suitableNumberOfVariables(itemIds));\n            stmt = conn.prepareStatement(sb.toString());\n            \n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            for (int itemId : itemIds)\n            \tstmt.setInt(i++, itemId);\n\n            int numRows = stmt.executeUpdate();\n            conn.commit();\n            ZimbraLog.datasource.debug(\"Deleted %d mappings for %s\", numRows, ds.getName());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void deleteAllMappings(DataSource ds) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\"Deleting all mappings for dataSource %s\", ds.getName());\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"DELETE FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\" data_source_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            int numRows = stmt.executeUpdate();\n            conn.commit();\n            ZimbraLog.datasource.debug(\"Deleted %d mappings for %s\", numRows, ds.getName());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void deleteMapping(DataSource ds, int itemId) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\"Deleting mappings for dataSource %s itemId %d\", ds.getName(), itemId);\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"DELETE FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\" data_source_id = ? AND\");\n            sb.append(\" item_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setInt(i++, itemId);\n            int numRows = stmt.executeUpdate();\n            conn.commit();\n            ZimbraLog.datasource.debug(\"Deleted %d mappings for %s\", numRows, ds.getName());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static Collection<DataSourceItem> deleteAllMappingsInFolder(DataSource ds, int folderId) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n    \tArrayList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\"Deleting all mappings for dataSource %s in folder %d\", ds.getName(), folderId);\n        try {\n            String dataSourceTable = getTableName(mbox);\n            String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : dataSourceTable+\".mailbox_id = ? AND \";\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"DELETE FROM \");\n            sb.append(dataSourceTable);\n            sb.append(\" WHERE \");\n            sb.append(IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ? AND folder_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setInt(i++, folderId);\n            int numRows = stmt.executeUpdate();\n            conn.commit();\n            stmt.close();\n            ZimbraLog.datasource.debug(\"Deleted %d mappings for %s\", numRows, ds.getName());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn items;\n    }\n\n    public static boolean hasMapping(DataSource ds, int itemId) throws ServiceException {\n    \tDataSourceItem item = getMapping(ds, itemId);\n    \treturn item.remoteId != null;\n    }\n    \n    public static Collection<DataSourceItem> getAllMappings(DataSource ds) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n    \tArrayList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        \n        ZimbraLog.datasource.debug(\"Get all mappings for %s\", ds.getName());\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"SELECT item_id, folder_id, remote_id, metadata FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n            \tMetadata md = null;\n            \tString buf = rs.getString(4);\n            \tif (buf != null)\n            \t\tmd = new Metadata(buf);\n            \titems.add(new DataSourceItem(rs.getInt(2), rs.getInt(1), rs.getString(3), md));\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn items;\n    }\n    \n    public static Collection<DataSourceItem> getAllMappingsInFolder(DataSource ds, int folderId) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n    \tArrayList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        \n        ZimbraLog.datasource.debug(\"Get all mappings for %s in folder %d\", ds.getName(), folderId);\n        try {\n            String thisTable = getTableName(mbox);\n            String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : thisTable+\".mailbox_id = ? AND \";\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"SELECT item_id, remote_id, \").append(thisTable).append(\".metadata FROM \");\n            sb.append(thisTable);\n            sb.append(\" WHERE \");\n            sb.append(IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ? AND folder_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setInt(i++, folderId);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n            \tMetadata md = null;\n            \tString buf = rs.getString(3);\n            \tif (buf != null)\n            \t\tmd = new Metadata(buf);\n            \titems.add(new DataSourceItem(folderId, rs.getInt(1), rs.getString(2), md));\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn items;\n    }\n\n    public static Collection<DataSourceItem> getAllMappingsAndFlagsInFolder(DataSource ds, int folderId) throws ServiceException {\n        Mailbox mbox = ds.getMailbox();\n        ArrayList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        \n        ZimbraLog.datasource.debug(\"Get all mappings for %s in folder %d\", ds.getName(), folderId);\n        try {\n            String thisTable = getTableName(mbox);\n            String IN_THIS_MAILBOX_AND = DebugConfig.disableMailboxGroups ? \"\" : thisTable+\".mailbox_id = ? AND \";\n            String MBOX_JOIN = DebugConfig.disableMailboxGroups ? \" \" : thisTable + \".mailbox_id = mi.mailbox_id AND \";\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"SELECT item_id, remote_id, \").append(thisTable).append(\".metadata, mi.unread, mi.flags FROM \");\n            sb.append(thisTable);\n            sb.append(\"  LEFT OUTER JOIN \" + DbMailItem.getMailItemTableName(mbox)).append(\" mi \");\n            sb.append(\"  ON \" ).append(MBOX_JOIN).append(thisTable).append(\".item_id = mi.id \");\n            sb.append(\" WHERE \");\n            sb.append(IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ? AND \").append(thisTable).append(\".folder_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setInt(i++, folderId);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                Metadata md = null;\n                String buf = rs.getString(3);\n                int unread = rs.getInt(4);\n                int flags = rs.getInt(5);\n                \n                if (buf != null)\n                    md = new Metadata(buf);\n                flags = unread > 0 ? (flags | Flag.BITMASK_UNREAD) : (flags & ~Flag.BITMASK_UNREAD);\n                items.add(new DataSourceItem(folderId, rs.getInt(1), rs.getString(2), md, flags));\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n        return items;\n    }\n\n    public static Collection<DataSourceItem> getAllMappingsForRemoteIdPrefix(DataSource ds, int folderId, String prefix)\n        throws ServiceException {\n        Mailbox mbox = ds.getMailbox();\n    \tList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        String db = DbMailbox.getDatabaseName(mbox);\n        String dst = db + \".data_source_item\";\n        String mit = db + \".mail_item\";\n        try {\n            conn = DbPool.getConnection();\n            Formatter fmt = new Formatter();\n            fmt.format(\"SELECT item_id, remote_id, %s.metadata FROM %s\", dst, dst);\n            fmt.format(\" INNER JOIN %s ON %s.item_id = %s.id\", mit, dst, mit);\n            fmt.format(\" WHERE %s.mailbox_id = ?\", dst);\n            fmt.format(\" AND data_source_id = ? AND folder_id = ?\");\n            if (prefix != null) {\n                fmt.format(\" AND remote_id LIKE '%s%%'\", prefix);\n            }\n            stmt = conn.prepareStatement(fmt.toString());\n            stmt.setInt(1, mbox.getId());\n            stmt.setString(2, ds.getId());\n            stmt.setInt(3, folderId);\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                String s = rs.getString(3);\n                Metadata md = s != null ? new Metadata(s) : null;\n                items.add(new DataSourceItem(folderId, rs.getInt(1), rs.getString(2), md));\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get mapping for data source \" + ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n        return items;\n    }\n    \n    public static DataSourceItem getMapping(DataSource ds, int itemId) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        int folderId = 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        String remoteId = null;\n    \tMetadata md = null;\n    \t\n        ZimbraLog.datasource.debug(\"Get mapping for %s, itemId=%d\", ds.getName(), itemId);\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"SELECT folder_id, remote_id, metadata FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ? AND item_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setInt(i++, itemId);\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                folderId = rs.getInt(1);\n            \tremoteId = rs.getString(2);\n            \tString buf = rs.getString(3);\n            \tif (buf != null)\n            \t    md = new Metadata(buf);\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn new DataSourceItem(folderId, itemId, remoteId, md);\n    }\n\n    public static DataSourceItem getReverseMapping(DataSource ds, String remoteId) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        int folderId = 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        int itemId = 0;\n        Metadata md = null;\n    \t\n        ZimbraLog.datasource.debug(\"Get reverse mapping for %s, remoteId=%s\", ds.getName(), remoteId);\n        try {\n            conn = DbPool.getConnection();\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"SELECT item_id, folder_id, metadata FROM \");\n            sb.append(getTableName(mbox));\n            sb.append(\" WHERE \");\n            sb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            sb.append(\"  data_source_id = ? AND remote_id = ?\");\n            stmt = conn.prepareStatement(sb.toString());\n            int i = 1;\n            i = DbMailItem.setMailboxId(stmt, mbox, i);\n            stmt.setString(i++, ds.getId());\n            stmt.setString(i++, remoteId);\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n            \titemId = rs.getInt(1);\n            \tfolderId = rs.getInt(2);\n            \tString buf = rs.getString(3);\n            \tif (buf != null)\n            \t\tmd = new Metadata(buf);\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get reverse mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn new DataSourceItem(folderId, itemId, remoteId, md);\n    }\n\n    public static Collection<DataSourceItem> getReverseMappings(DataSource ds, Collection<String> remoteIds) throws ServiceException {\n    \tMailbox mbox = ds.getMailbox();\n        Connection conn = null;\n        int folderId = 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        int itemId = 0;\n        String remoteId;\n        Metadata md = null;\n        List<List<String>> splitIds = ListUtil.split(remoteIds, Db.getINClauseBatchSize());\n        ArrayList<DataSourceItem> items = new ArrayList<DataSourceItem>();\n    \t\n        ZimbraLog.datasource.debug(\"Get reverse mappings for %s\", ds.getName());\n        try {\n            conn = DbPool.getConnection();\n            for (List<String> curIds : splitIds) {\n            \tStringBuilder sb = new StringBuilder();\n            \tsb.append(\"SELECT item_id, remote_id, folder_id, metadata FROM \");\n            \tsb.append(getTableName(mbox));\n            \tsb.append(\" WHERE \");\n            \tsb.append(DbMailItem.IN_THIS_MAILBOX_AND);\n            \tsb.append(\"  data_source_id = ? AND remote_id IN \");\n            \tsb.append(DbUtil.suitableNumberOfVariables(curIds));\n            \tstmt = conn.prepareStatement(sb.toString());\n            \tint i = 1;\n            \ti = DbMailItem.setMailboxId(stmt, mbox, i);\n            \tstmt.setString(i++, ds.getId());\n                for (String uid : curIds)\n                    stmt.setString(i++, uid);\n            \trs = stmt.executeQuery();\n            \twhile (rs.next()) {\n            \t\titemId = rs.getInt(1);\n            \t\tremoteId = rs.getString(2);\n            \t\tfolderId = rs.getInt(3);\n            \t\tString buf = rs.getString(4);\n            \t\tif (buf != null)\n            \t\t\tmd = new Metadata(buf);\n            \t\titems.add( new DataSourceItem(folderId, itemId, remoteId, md));\n            \t}\n                rs.close();\n                stmt.close();\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get reverse mapping for dataSource \"+ds.getName(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    \treturn items;\n    }\n\n    public static String getTableName(Mailbox mbox) {\n        return DbMailbox.qualifyTableName(mbox, TABLE_DATA_SOURCE_ITEM);\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "d679a9a78b98b3eed2b7b13d2c34c0e3a0b60f27",
    "commit_msg": "(split)bug: 37476\n\nEnclose all database accesses with appropriate synchronization blocks to avoid conflicts in the case where the underlying database does not support row-level locking.  In the case where the database *does* have this support (i.e. everything but SQLite), we're synchronizing on a new Object, which shouldn't slow things down too much.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=37476\n\nCopied from Perforce\n Change: 161770",
    "original_file": "DbDataSource.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 7,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\nimport org.apache.commons.pool.impl.GenericObjectPool;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Strings;\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic final class SQLite extends Db {\n\n    private static final String PRAGMA_JOURNAL_MODE_DEFAULT = \"DELETE\";\n    private static final String PRAGMA_SYNCHRONOUS_DEFAULT  = \"FULL\";\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n    private String journalMode;\n    private String pageSize;\n    private String syncMode;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_CHILD_EXISTS, \"foreign key\");\n        mErrorCodes.put(Db.Error.FOREIGN_KEY_NO_PARENT, \"foreign key\");\n        mErrorCodes.put(Db.Error.TOO_MANY_SQL_PARAMS, \"too many SQL variables\");\n        mErrorCodes.put(Db.Error.BUSY, \"SQLITE_BUSY\");\n        mErrorCodes.put(Db.Error.LOCKED, \"database is locked\");\n        mErrorCodes.put(Db.Error.CANTOPEN, \"SQLITE_CANTOPEN\");\n    }\n\n    @Override\n    boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case NON_BMP_CHARACTERS:         return true;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return true;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n            case SQL_PARAM_LIMIT:            return true;\n            case DUMPSTER_TABLES:            return false;\n        }\n        return false;\n    }\n\n    @Override\n    boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage() != null && e.getMessage().contains(code);\n    }\n\n    @Override\n    String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override\n    String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override\n    public String bitAND(String expr1, String expr2) {\n        return expr1 + \" & \" + expr2;\n    }\n\n    @Override\n    PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override\n    void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        cacheSize = LC.sqlite_cache_size.value();\n        if (cacheSize.equals(\"0\"))\n            cacheSize = null;\n        journalMode = LC.sqlite_journal_mode.value();\n        pageSize = LC.sqlite_page_size.value();\n        if (pageSize.equals(\"0\"))\n            pageSize = null;\n        syncMode = LC.sqlite_sync_mode.value();\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" +\n            (cacheSize == null ? \"default\" : cacheSize) + \" cache cache, \" +\n            (pageSize == null ? \"default\" : pageSize) + \" page size, \" +\n            journalMode + \" journal mode, \" + syncMode + \" sync mode\");\n        super.startup(pool, poolSize);\n    }\n\n    @Override\n    void postCreate(Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            pragmas(conn, null);\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(Connection conn, String dbname, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n\n        try {\n            String prefix = dbname == null || dbname.equals(\"zimbra\") ? \"\" : dbname + \".\";\n            (stmt = conn.prepareStatement(\"PRAGMA \" + prefix + key +\n                (value == null ? \"\" : \" = \" + value))).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    void pragmas(Connection conn, String dbname) throws SQLException {\n        /*\n         * auto_vacuum causes databases to be locked permanently\n         * pragma(conn, dbname, \"auto_vacuum\", \"2\");\n         */\n        pragma(conn, dbname, \"foreign_keys\", \"ON\");\n        if (journalMode != null && !journalMode.equalsIgnoreCase(PRAGMA_JOURNAL_MODE_DEFAULT))\n            pragma(conn, dbname, \"journal_mode\", journalMode);\n        if (syncMode != null && !syncMode.equalsIgnoreCase(PRAGMA_SYNCHRONOUS_DEFAULT))\n            pragma(conn, dbname, \"synchronous\", syncMode);\n        if (cacheSize != null)\n            pragma(conn, dbname, \"cache_size\", cacheSize);\n        if (pageSize != null)\n            pragma(conn, dbname, \"page_size\", pageSize);\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 6;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(DbConnection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private Connection getInnermostConnection(Connection conn) {\n        Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override\n    public void optimize(DbConnection conn, String dbname, int level)\n        throws ServiceException {\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            PreparedStatement stmt = null;\n\n            try {\n                if (!autocommit)\n                    conn.getConnection().setAutoCommit(true);\n                if (dbname == null)\n                    dbname = \"zimbra\";\n                registerDatabaseInterest(conn, dbname);\n                if (level > 0 && dbname.endsWith(\"zimbra\")) {\n                    if (level == 2)\n                        (stmt = conn.prepareStatement(\"VACUUM\")).execute();\n                    else\n                        pragma(conn.getConnection(), dbname, \"incremental_vacuum\", null);\n                }\n                (stmt = conn.prepareStatement(\"ANALYZE \" + dbname)).execute();\n                ZimbraLog.dbconn.debug(\"sqlite \" +\n                    (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname);\n            } finally {\n                if (!autocommit) {\n                    try {\n                        conn.getConnection().setAutoCommit(autocommit);\n                    } catch (SQLException sqle) {\n                        ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                        DbPool.quietClose(conn);\n                        throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                    }\n                }\n\n                DbPool.quietCloseStatement(stmt);\n            }\n        } catch (Exception e) {\n            throw ServiceException.FAILURE(\"sqlite \" +\n                (level > 0 ? \"vacuum\" : \"analyze\") + ' ' + dbname + \" error\", e);\n        }\n    }\n\n    @Override\n    public void registerDatabaseInterest(DbConnection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n\n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(DbConnection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n            pragmas(conn.getConnection(), dbname);\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.error(\"database \" + dbname + \" attach failed\", e);\n            if (!\"database is already attached\".equals(e.getMessage()))\n                throw e;\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors \" + dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.quietCloseStatement(stmt);\n        }\n\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(DbConnection conn, String dbname) throws ServiceException {\n        PreparedStatement stmt = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit) {\n                conn.getConnection().setAutoCommit(true);\n            }\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n            return true;\n        } catch (SQLException e) {\n            if (!deleted.containsKey(dbname)) { \n                ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n                return false;\n            } else {\n                return true;\n            }\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private void releaseMboxDbLock(Integer mboxId) {\n        if (mboxId != null) {\n            ReentrantLock lock = null;\n            lock = lockMap.get(mboxId);\n            if (lock != null && lock.isHeldByCurrentThread()) {\n                lock.unlock();\n                ZimbraLog.dbconn.trace(\"unlocked mbox %d\",mboxId);\n            }\n        }\n    }\n\n    @Override\n    void preClose(DbConnection conn) {\n        releaseMboxDbLock(conn.mboxId);\n    }\n\n\n    private static ConcurrentMap<Integer, ReentrantLock> lockMap = new ConcurrentHashMap<Integer, ReentrantLock>();\n\n    private boolean checkLockMap(int mboxId) {\n        for (Entry<Integer, ReentrantLock> entry : lockMap.entrySet()) {\n            if (entry.getKey().intValue() != mboxId && entry.getValue().isHeldByCurrentThread()) {\n                ZimbraLog.dbconn.debug(\"already holding db lock for mbox %d\",entry.getKey());\n                if (entry.getKey().intValue() != -1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    void preOpen(Integer mboxId) {\n        ZimbraLog.dbconn.trace(\"trying to lock mbox %d\",mboxId);\n        assert(checkLockMap(mboxId));\n        ReentrantLock lock = lockMap.get(mboxId);\n        if (lock == null) {\n            lock = new ReentrantLock();\n            ReentrantLock added = lockMap.putIfAbsent(mboxId, lock);\n            if (added != null) {\n                lock = added;\n            }\n        }\n        boolean locked = false;\n        long timeoutSecs = 180;\n        //lock with timeout in case external call sites cause a deadlock\n        //(e.g. one site locks some object before opening connection; another incorrectly locks same object after opening connection)\n        //in case of timeout we'll fall through and let sqlite_busy retry handler sort it out\n        try {\n            locked = lock.tryLock(timeoutSecs, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n        }\n        if (!locked) {\n            ZimbraLog.dbconn.warn(\"Unable to get db lock for mbox %d\",mboxId);\n        } else {\n            ZimbraLog.dbconn.trace(\"locked mbox %d\",mboxId);\n        }\n    }\n\n    @Override\n    void abortOpen(Integer mboxId) {\n        releaseMboxDbLock(mboxId);\n    }\n\n    @Override\n    public boolean databaseExists(DbConnection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        boolean autocommit = true;\n        try {\n            autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            if (!autocommit) {\n                try {\n                    conn.getConnection().setAutoCommit(autocommit);\n                } catch (SQLException sqle) {\n                    ZimbraLog.dbconn.warn(\"failed to reset autocommit to false. probably caused by prior errors %s\", dbname);\n                    DbPool.quietClose(conn);\n                    throw ServiceException.FAILURE(\"failed to reset autocommit to false\",sqle);\n                }\n            }\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private ConcurrentMap<String,Boolean> deleted = new ConcurrentHashMap<String, Boolean>();\n\n    @Override\n    void deleteDatabaseFile(DbConnection conn, String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        try {\n            detachDatabase(conn, dbname);\n        } catch (ServiceException se) {\n            ZimbraLog.dbconn.warn(\"failed to detach while deleting\");\n        }\n        deleted.put(dbname,true);\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n        new File(getDatabaseFilename(dbname) + \"-journal\").delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\");\n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n            whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_GROW; //we use a small pool. we can easily starve when any code requires more than one connection to complete a single operation\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            if (LC.sqlite_shared_cache_enabled.booleanValue())\n                props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override\n    public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override\n    public String toString() {\n        return \"SQLite\";\n    }\n\n    @Override\n    protected int getInClauseBatchSize() {\n        return 200;\n    }\n    \n    @Override\n    public void checkParamLimit(int numParams) throws ServiceException {\n        if (numParams > 999) {\n            throw ServiceException.FAILURE(\"SQLite parameter limit will be exceeded\",\n                new SQLException(mErrorCodes.get(Db.Error.TOO_MANY_SQL_PARAMS)));\n        }\n    }\n\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    @Override\n    public String concat(String... fieldsToConcat) {\n        Joiner joiner = Joiner.on(\" || \").skipNulls();\n        return joiner.join(fieldsToConcat);\n    }\n\n    @Override\n    public String sign(String field) {\n        return \"CASE WHEN(\" + field + \")>0 THEN '1' WHEN(\" + field + \")<0 THEN '-1' ELSE '0' END\";\n    }\n\n    @Override\n    public String lpad(String field, int padSize, String padString) {\n        return \"SUBSTR('\" + Strings.repeat(padString, padSize) + \"' || \" + field + \", -\" + padSize + \", \" + padSize + \")\";\n    }\n\n    @Override\n    public String limit(int offset, int limit) {\n        return \"LIMIT \" + offset + \",\" + limit;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "426ea2339ffa0bbf8b3b8245effdb2b526e116cd",
    "commit_msg": "(split)bug: 72299\n\nSplit DB search cononstraints for folders as too many folders involved could hit SQLite's limit on SQLITE_MAX_VARIABLE_NUMBER.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=72299\n\nCopied from Perforce\n Change: 394722",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 8,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.DataSource;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.mailbox.Mailbox;\n\n\npublic class DbPop3Message {\n\n    public static final String TABLE_POP3_MESSAGE = \"pop3_message\";\n    \n    /**\n     * Persists <code>uid</code> so we remember not to import the message again.\n     */\n    public static void storeUid(Mailbox mbox, String dataSourceId, String uid, int itemId)\n    throws ServiceException\n    {\n        if (StringUtil.isNullOrEmpty(uid)) {\n            return;\n        }\n        \n        Connection conn = null;\n        PreparedStatement stmt = null;\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"INSERT INTO \" + getTableName(mbox) +\n                \" (mailbox_id, data_source_id, uid, item_id) \" +\n                \"VALUES (?, ?, ?, ?)\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setString(2, dataSourceId);\n            stmt.setString(3, uid);\n            stmt.setInt(4, itemId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to store UID\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    /**\n     * Deletes all persisted UID's for the given mailbox/data source.\n     */\n    public static void deleteUids(Mailbox mbox, String dataSourceId)\n    throws ServiceException {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n\n        ZimbraLog.mailbox.debug(\"Deleting UID's for %s\", dataSourceId);\n        \n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + getTableName(mbox) +\n                \" WHERE mailbox_id = ? AND data_source_id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setString(2, dataSourceId);\n            int numRows = stmt.executeUpdate();\n            conn.commit();\n            ZimbraLog.mailbox.debug(\"Deleted %d UID's\", numRows);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete UID's\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    /**\n     * Returns the set of persisted UID's that are also in the <code>uids</code>\n     * collection.\n     */\n    public static Set<String> getMatchingUids(Mailbox mbox, DataSource ds,\n                                              Collection<String> uids)\n    throws ServiceException {\n        ZimbraLog.mailbox.debug(\"%s: looking for uids that match a set of size %d\", ds, uids.size());\n        \n        List<List<String>> splitIds = ListUtil.split(uids, Db.getINClauseBatchSize());\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        Set<String> matchingUids = new HashSet<String>();\n\n        try {\n            conn = DbPool.getConnection();\n            for (List<String> curIds : splitIds) {\n                stmt = conn.prepareStatement(\n                    \"SELECT uid \" +\n                    \"FROM \" + getTableName(mbox) +\n                    \" WHERE mailbox_id = ? AND data_source_id = ? AND uid IN \" +\n                    DbUtil.suitableNumberOfVariables(curIds));\n\n                int i = 1;\n                stmt.setInt(i++, mbox.getId());\n                stmt.setString(i++, ds.getId());\n                for (String uid : curIds) {\n                    stmt.setString(i++, uid);\n                }\n                rs = stmt.executeQuery();\n                while (rs.next()) {\n                    matchingUids.add(rs.getString(1));\n                }\n                rs.close();\n                stmt.close();\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get UID's\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n\n        ZimbraLog.mailbox.debug(\"Found %d matching UID's\", matchingUids.size());\n        return matchingUids;\n    }\n\n    public static String getTableName(int mailboxId, int groupId) {\n        return String.format(\"%s.%s\", DbMailbox.getDatabaseName(groupId), TABLE_POP3_MESSAGE);\n    }\n\n    public static String getTableName(Mailbox mbox) {\n        return DbMailbox.getDatabaseName(mbox) + \".\" + TABLE_POP3_MESSAGE;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "ea4340b7620fbcc9042728b38750dacc03d85045",
    "commit_msg": "(split)bug: 29563\n\nSQLite is now database-per-mailbox.  (Those DBs are all in /opt/zimbra/sqlite for now.)  The \"debug_disable_mailbox_group\" localconfig debug key is back and does the right thing again.\n\nFixed some INSERT SELECT syntax issues with SQLite.  Fixed a SQLite REPLACE INTO issue.  Updated data source DB code to work with SQLite.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 105347",
    "original_file": "DbPop3Message.java",
    "confidence_score": 1.0
  },
  {
    "serial_no": 9,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        return false;\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override public String scriptCommandDelimiter() {\n        return \"%\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        Map<String, String> pragmas = getCustomPragmas();\n\n        LinkedList<java.sql.Connection> connections = new LinkedList<java.sql.Connection>();\n        for (int i = 0; i < poolSize; i++) {\n            java.sql.Connection conn = pool.getConnection();\n            if (i == 0)\n                ZimbraLog.dbconn.info(\"sqlite driver running in \" + conn.getMetaData().getDriverVersion() + \" mode\");\n\n            try {\n                conn.setAutoCommit(true);\n                pragma(conn, \"synchronous\", \"NORMAL\");\n                pragma(conn, \"fullfsync\", \"0\");\n                pragma(conn, \"journal_mode\", \"PERSIST\");\n//                pragma(conn, \"locking_mode\", \"EXCLUSIVE\");\n                pragma(conn, \"legacy_file_format\", \"OFF\");\n//                pragma(conn, \"read_uncommitted\", \"1\");\n\n                for (Map.Entry<String, String> pragma : pragmas.entrySet())\n                    pragma(conn, pragma.getKey(), pragma.getValue());\n            } finally {\n                connections.add(conn);\n                conn.setAutoCommit(false);\n            }\n        }\n        for (java.sql.Connection conn : connections)\n            conn.close();\n\n        super.startup(pool, poolSize);\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private Map<String, String> getCustomPragmas() {\n        String propsfile = LC.get(\"sqlite_pragma_file\");\n        if (propsfile == null || propsfile.trim().equals(\"\"))\n            return Collections.emptyMap();\n\n        try {\n            Properties props = new Properties();\n            props.load(new FileInputStream(propsfile));\n            ZimbraLog.dbconn.info(\"reading custom sqlite pragmas from conf file: \" + propsfile);\n\n            Map<String, String> pragmas = new HashMap<String, String>(props.size() * 3 / 2);\n            for (Map.Entry<Object, Object> foo : props.entrySet()) {\n                String key = (String) foo.getKey(), value = (String) foo.getValue();\n                pragmas.put(key, value);\n                ZimbraLog.dbconn.info(\"  found custom pragma: '\" + key + \"' => '\" + value + \"'\");\n            }\n            return pragmas;\n        } catch (FileNotFoundException x) {\n            ZimbraLog.dbconn.info(\"no sqlite pragma conf file found; will use standard config\");\n        } catch (IOException x) {\n            ZimbraLog.dbconn.warn(\"exception reading from sqlite pragma conf file (\" + propsfile + \"); will use standard config\", x);\n        }\n        return Collections.emptyMap();\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = 7;\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(conn.getConnection());\n    }\n\n    private void recordAttachedDatabase(Connection conn, String dbname) {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(conn.getConnection(), attachedDBs);\n        }\n    }\n\n    @Override void registerDatabaseInterest(Connection conn, String dbname) throws SQLException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                if (detachDatabase(conn, it.next()))\n                    it.remove();\n            }\n        }\n\n        attachDatabase(conn, dbname);\n        recordAttachedDatabase(conn, dbname);\n    }\n\n    private void attachDatabase(Connection conn, String dbname) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.sqltrace.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // XXX: since it's so easy to end up with an empty SQLite database, make sure that the tables we want are actually in there\n        //   (yes, this assumes that we're looking for a MBOXGROUP database, which is beyond the scope of this method's contract)\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + dbname + \".sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= DbMailbox.sTables.length) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"foo\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.sqltrace.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    static String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    static final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            try {\n                String poolsize = LC.get(\"sqlite_pool_size\");\n                if (poolsize != null && !poolsize.trim().equals(\"\"))\n                    mPoolSize = Integer.parseInt(poolsize);\n            } catch (NumberFormatException nfe) {\n                ZimbraLog.system.warn(\"exception parsing 'sqlite_pool_size' config; defaulting pool size to \" + mPoolSize, nfe);\n            }\n            ZimbraLog.misc.info(\"setting connection pool size to \" + mPoolSize);\n        }\n\n        private static Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            if (output != null)\n                output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "4b032ec9b12147369a2a259871c416a4a2716387",
    "commit_msg": "(split)bug: 29563\n\nMove the MAILBOX, MAILBOX_METADATA, and OUT_OF_OFFICE tables into the per-user database for SQLite.  There is a vestigal ZIMBRA.MAILBOX table left for now to allow account-to-mailbox mapping.  As a result, no longer any need for the \"debug_defer_mailbox_updates\" localconfig key.\n\nStill need to figure out what to do with \"scheduled tasks\".\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 147050",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 10,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Oct 28, 2004\n */\npackage com.zimbra.cs.db;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ByteUtil;\nimport com.zimbra.cs.service.util.SyncToken;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\n\npublic class DbMailbox {\n\n    public static final int CI_ID;\n    public static final int CI_GROUP_ID;\n    public static final int CI_ACCOUNT_ID;\n    public static final int CI_INDEX_VOLUME_ID;\n    public static final int CI_ITEM_ID_CHECKPOINT;\n    public static final int CI_CONTACT_COUNT;\n    public static final int CI_SIZE_CHECKPOINT;\n    public static final int CI_CHANGE_CHECKPOINT;\n    public static final int CI_TRACKING_SYNC;\n    public static final int CI_TRACKING_IMAP;\n    public static final int CI_LAST_BACKUP_AT;\n    public static final int CI_COMMENT;\n    public static final int CI_LAST_SOAP_ACCESS;\n    public static final int CI_NEW_MESSAGES;\n    public static final int CI_IDX_DEFERRED_COUNT;\n    public static final int CI_HIGHEST_INDEXED;    \n    \n    static {\n        int pos = 1;\n        // Order must match the order of column definition in zimbra.mailbox\n        // table in db.sql script.\n        CI_ID = pos++;\n        CI_GROUP_ID = pos++;\n        CI_ACCOUNT_ID = pos++;\n        CI_INDEX_VOLUME_ID = pos++;\n        CI_ITEM_ID_CHECKPOINT = pos++;\n        CI_CONTACT_COUNT = pos++;\n        CI_SIZE_CHECKPOINT = pos++;\n        CI_CHANGE_CHECKPOINT = pos++;\n        CI_TRACKING_SYNC = pos++;\n        CI_TRACKING_IMAP = pos++;\n        CI_LAST_BACKUP_AT = pos++;\n        CI_COMMENT = pos++;\n        CI_LAST_SOAP_ACCESS = pos++;\n        CI_NEW_MESSAGES = pos++;\n        CI_IDX_DEFERRED_COUNT = pos++;\n        CI_HIGHEST_INDEXED = pos++;\n    }\n\n    public static final int CI_METADATA_MAILBOX_ID = 1;\n    public static final int CI_METADATA_SECTION    = 2;\n    public static final int CI_METADATA_METADATA   = 3;\n\n    public static final int CI_SCHEDULED_TASK_MAILBOX_ID = 3;\n    public static final int CI_OUT_OF_OFFICE_MAILBOX_ID = 1;\n\n    static final String DB_PREFIX_MAILBOX_GROUP = \"mboxgroup\";\n    static final String TABLE_MAILBOX       = \"mailbox\";\n    static final String TABLE_METADATA      = \"mailbox_metadata\";\n    static final String TABLE_OUT_OF_OFFICE = \"out_of_office\";\n\n    private static int MAX_COMMENT_LENGTH = 255;\n\n    public static class MailboxIdentifier {\n        public final long id;\n        public final long groupId;\n\n        public MailboxIdentifier(long mbox_id, long group_id) {\n            id = mbox_id;  groupId = group_id;\n        }\n\n        @Override public String toString() {\n            return \"[mailbox \" + id + \", group \" + groupId + \"]\";\n        }\n\n        @Override public boolean equals(Object obj) {\n            if (obj == this)\n                return true;\n            else if (obj instanceof Number)\n                return ((Number) obj).intValue() == id;\n            else if (obj instanceof MailboxIdentifier)\n                return ((MailboxIdentifier) obj).id == id;\n            else\n                return false;\n        }\n\n        @Override public int hashCode() {\n            return (int) (id % Integer.MAX_VALUE);\n        }\n    }\n\n    /**\n     * Gets the next mailbox id.  If <tt>mailboxId</tt> is {@link Mailbox#ID_AUTO_INCREMENT} or\n     * greater than the current <tt>next_mailbox_id</tt> value in the <tt>current_volumes</tt>\n     * table, <tt>next_mailbox_id</tt>.\n     */\n    public synchronized static MailboxIdentifier getNextMailboxId(Connection conn, long mailboxId)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        boolean explicitId = (mailboxId != Mailbox.ID_AUTO_INCREMENT);\n        ZimbraLog.mailbox.debug(\"Getting next mailbox id.  requested mailboxId=%d.\", mailboxId);\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (explicitId) {\n                stmt = conn.prepareStatement(\"UPDATE current_volumes\" +\n                        \" SET next_mailbox_id = ? WHERE next_mailbox_id <= ?\");\n                stmt.setLong(1, mailboxId + 1);\n                stmt.setLong(2, mailboxId);\n                stmt.executeUpdate();\n            } else {\n                // Update first, then select, so that two threads don't select the same id.\n                // Probably unnecessary due to \"synchronized static\", but call me old fashioned.\n                stmt = conn.prepareStatement(\"UPDATE current_volumes\" +\n                        \" SET next_mailbox_id = next_mailbox_id + 1\");\n                stmt.executeUpdate();\n                stmt.close();  stmt = null;\n\n                stmt = conn.prepareStatement(\"SELECT next_mailbox_id - 1 FROM current_volumes\");\n                rs = stmt.executeQuery();\n                if (rs.next())\n                    mailboxId = rs.getLong(1);\n                else\n                    throw ServiceException.FAILURE(\"Unable to assign next new mailbox id\", null);\n            }\n\n            MailboxIdentifier newId = new MailboxIdentifier(mailboxId, calculateMailboxGroupId(mailboxId));\n            ZimbraLog.mailbox.debug(\"Returning mailboxId=%d, groupId=%d.\", newId.id, newId.groupId);\n            return newId;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting next mailbox id, mailboxId=\" + mailboxId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public synchronized static Mailbox.MailboxData createMailbox(Connection conn, long requestedMailboxId, String accountId,\n                                                                 String comment, int lastBackupAt)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        String limitClause = Db.supports(Db.Capability.LIMIT_CLAUSE) ? \" ORDER BY index_volume_id LIMIT 1\" : \"\";\n\n        // Get mailbox id.\n        MailboxIdentifier newMboxId = getNextMailboxId(conn, requestedMailboxId);\n        long mailboxId = newMboxId.id;\n        long groupId = newMboxId.groupId;\n\n        // Make sure the group database exists before we start doing DMLs.\n        createMailboxDatabase(conn, mailboxId, groupId);\n\n        if (comment != null && comment.length() > MAX_COMMENT_LENGTH)\n            comment = comment.substring(0, MAX_COMMENT_LENGTH);\n        if (comment != null)\n            removeFromDeletedAccount(conn, comment);\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // first, get the current volume to put Lucene files in\n            stmt = conn.prepareStatement(\"SELECT index_volume_id FROM current_volumes\" + limitClause);\n            rs = stmt.executeQuery();\n            if (!rs.next())\n                throw ServiceException.FAILURE(\"cannot create mailbox: no rows in database table ZIMBRA.CURRENT_VOLUME\", null);\n            short indexVolume = rs.getShort(1);\n            if (rs.next())\n                ZimbraLog.mbxmgr.warn(\"bad state: too many rows in database table ZIMBRA.CURRENT_VOLUME\");\n            rs.close();    rs = null;\n            stmt.close();  stmt = null;\n\n            if (DebugConfig.disableMailboxGroups) {\n                Db.getInstance().registerDatabaseInterest(conn, getDatabaseName(groupId));\n\n                if (!DebugConfig.externalMailboxDirectory) {\n                    // then create the primary lookup row in ZIMBRA.MAILBOX\n                    stmt = conn.prepareStatement(\"INSERT INTO mailbox (account_id, id, last_backup_at, comment)\" +\n                            \" VALUES (?, ?, ?, ?)\");\n                    stmt.setString(1, accountId.toLowerCase());\n                    stmt.setLong(2, mailboxId);\n                    if (lastBackupAt >= 0)\n                        stmt.setInt(3, lastBackupAt);\n                    else\n                        stmt.setNull(3, Types.INTEGER);\n                    stmt.setString(4, comment);\n                    stmt.executeUpdate();\n                    stmt.close();  stmt = null;\n                }\n\n                // finally, create the row in MBOXGROUPnn.MAILBOX for mutable state and counts \n                stmt = conn.prepareStatement(\"INSERT INTO \" + qualifyTableName(groupId, TABLE_MAILBOX) +\n                        \"(id, account_id, index_volume_id, item_id_checkpoint)\" +\n                        \" VALUES (?, ?, ?, \" + (Mailbox.FIRST_USER_ID - 1) + \")\");\n                stmt.setLong(1, mailboxId);\n                stmt.setString(2, accountId.toLowerCase());\n                stmt.setShort(3, indexVolume);\n                stmt.executeUpdate();\n            } else {\n                // then create the primary lookup row in ZIMBRA.MAILBOX\n                stmt = conn.prepareStatement(\"INSERT INTO mailbox\" +\n                        \"(account_id, id, group_id, index_volume_id, item_id_checkpoint, last_backup_at, comment)\" +\n                        \" VALUES (?, ?, ?, ?, \" + (Mailbox.FIRST_USER_ID - 1) + \", ?, ?)\");\n                stmt.setString(1, accountId.toLowerCase());\n                stmt.setLong(2, mailboxId);\n                stmt.setLong(3, groupId);\n                stmt.setInt(4, indexVolume);\n                if (lastBackupAt >= 0)\n                    stmt.setInt(5, lastBackupAt);\n                else\n                    stmt.setNull(5, Types.INTEGER);\n                stmt.setString(6, comment);\n                stmt.executeUpdate();\n            }\n\n            Mailbox.MailboxData data = new Mailbox.MailboxData();\n            data.accountId = accountId;\n            data.id = mailboxId;\n            data.lastItemId = Mailbox.FIRST_USER_ID - 1;\n            data.schemaGroupId = groupId;\n            data.indexVolumeId = indexVolume;\n            return data;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"writing new mailbox row for account \" + accountId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Create a database for the specified mailbox.\n     * \n     * @throws ServiceException if the database creation fails */\n    public static void createMailboxDatabase(Connection conn, long mailboxId, long groupId)\n    throws ServiceException {\n        ZimbraLog.mailbox.debug(\"createMailboxDatabase(\" + mailboxId + \")\");\n\n        File file = new File(LC.mailboxd_directory.value() + \"/../db/create_database.sql\");\n\n        PreparedStatement stmt = null;\n        try {\n            String dbname = getDatabaseName(groupId);\n            if (Db.getInstance().databaseExists(conn, dbname)) {\n                // If database didn't exist we would end up doing CREATE DATABASE which does implicit commit.\n                // Let's do an explicit here so pending transactions always committed on exit from this method\n                // whether we create a database or not.\n                conn.commit();\n                return;\n            }\n\n            Db.getInstance().precreateDatabase(dbname);\n\n            // create the new database\n            ZimbraLog.mailbox.info(\"Creating database \" + dbname);\n            Db.getInstance().registerDatabaseInterest(conn, dbname);\n\n            String template = new String(ByteUtil.getContent(file));\n            Map<String, String> vars = new HashMap<String, String>();\n            vars.put(\"DATABASE_NAME\", dbname);\n            String script = StringUtil.fillTemplate(template, vars);\n            // note that DbUtil.executeScript ends with a COMMIT\n            DbUtil.executeScript(conn, new StringReader(script));\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"unable to read SQL statements from \" + file.getPath(), e);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"createMailboxDatabase(\" + mailboxId + \")\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // Tables are listed in order of creation.  dropMailboxFromGroup() drops them\n    // in reverse order.\n    static final List<String> sTables = new ArrayList<String>();\n        static {\n            if (DebugConfig.disableMailboxGroups) {\n                sTables.add(TABLE_MAILBOX);\n                sTables.add(TABLE_METADATA);\n                sTables.add(TABLE_OUT_OF_OFFICE);\n            }\n            sTables.add(DbMailItem.TABLE_MAIL_ITEM);\n            sTables.add(DbMailItem.TABLE_OPEN_CONVERSATION);\n            sTables.add(DbMailItem.TABLE_APPOINTMENT);\n            sTables.add(DbMailItem.TABLE_REVISION);\n            sTables.add(DbMailItem.TABLE_TOMBSTONE);\n            sTables.add(DbImapFolder.TABLE_IMAP_FOLDER);\n            sTables.add(DbImapMessage.TABLE_IMAP_MESSAGE);\n            sTables.add(DbPop3Message.TABLE_POP3_MESSAGE);\n            sTables.add(DbDataSource.TABLE_DATA_SOURCE_ITEM);\n        };\n\n    private static void dropMailboxFromGroup(Connection conn, Mailbox mbox)\n    throws ServiceException {\n        long mailboxId = mbox.getId();\n        ZimbraLog.mailbox.info(\"clearing contents of mailbox \" + mailboxId + \", group \" + mbox.getSchemaGroupId());\n\n        if (DebugConfig.disableMailboxGroups && Db.supports(Db.Capability.FILE_PER_DATABASE)) {\n            Db.getInstance().deleteDatabaseFile(getDatabaseName(mbox));\n            return;\n        }\n\n        if (conn == null)\n            conn = mbox.getOperationConnection();\n        else\n            Db.registerDatabaseInterest(conn, mbox);\n\n        try {\n            if (Db.supports(Db.Capability.DISABLE_CONSTRAINT_CHECK))\n                conn.disableForeignKeyConstraints();\n\n            // delete from tables in reverse order\n            for (int i = sTables.size() - 1; i >= 0; i--) {\n                String tableName = sTables.get(i);\n                if (tableName == null)\n                    continue;\n                PreparedStatement stmt = null;\n                try {\n                    stmt = conn.prepareStatement(\"DELETE FROM \" + qualifyTableName(mbox, tableName) +\n                            (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = \" + mailboxId));\n                    stmt.executeUpdate();\n                } finally {\n                    DbPool.closeStatement(stmt);\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"dropMailboxFromGroup(\" + mailboxId + \")\", e);\n        } finally {\n            try {\n                if (Db.supports(Db.Capability.DISABLE_CONSTRAINT_CHECK))\n                    conn.enableForeignKeyConstraints();\n            } catch (ServiceException e) {\n                ZimbraLog.mailbox.error(\"error enabling foreign key constraints during mailbox deletion\", e);\n                // don't rethrow to avoid masking any exception from DELETE statements\n            }\n        }\n    }\n\n    public static void clearMailboxContent(Mailbox mbox) throws ServiceException {\n        clearMailboxContent(null, mbox);\n    }\n\n    public static void clearMailboxContent(Connection conn, Mailbox mbox) throws ServiceException {\n        dropMailboxFromGroup(conn, mbox);\n    }\n\n    public static void renameMailbox(Mailbox mbox, String newName) throws ServiceException {\n        if (DebugConfig.externalMailboxDirectory)\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        long mailboxId = mbox.getId();\n        ZimbraLog.mailbox.info(\"Renaming email/comment of mailbox \" + mailboxId + \" to \" + newName);\n\n        Connection conn = mbox.getOperationConnection();\n\n        try {\n            PreparedStatement stmt = null;\n            try {\n                stmt = conn.prepareStatement(\"UPDATE mailbox SET comment = ?, last_backup_at = NULL WHERE id = ?\");\n                stmt.setString(1, newName);\n                stmt.setLong(2, mailboxId);\n                stmt.executeUpdate();\n            } finally {\n                DbPool.closeStatement(stmt);\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"renameMailbox(\" + mailboxId + \")\", e);\n        }\n    }\n\n    public static void clearMailboxContactCount(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_MAILBOX) +\n                    \" SET contact_count = NULL WHERE id = ?\");\n            stmt.setLong(1, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"clearing contact count for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void recordLastSoapAccess(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_MAILBOX) +\n                    \" SET last_soap_access = ? WHERE id = ?\");\n            stmt.setInt(1, (int) (mbox.getLastSoapAccessTime() / 1000));\n            stmt.setLong(2, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating last SOAP access time for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void updateMailboxStats(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_MAILBOX) +\n                    \" SET item_id_checkpoint = ?, contact_count = ?, change_checkpoint = ?,\" +\n                    \"  size_checkpoint = ?, new_messages = ?, idx_deferred_count = ?, highest_indexed = ?\" +\n                    \" WHERE id = ?\");\n            int pos = 1;\n            stmt.setInt(pos++, mbox.getLastItemId());\n            stmt.setInt(pos++, mbox.getContactCount());\n            stmt.setInt(pos++, mbox.getLastChangeID());\n            stmt.setLong(pos++, mbox.getSize());\n            stmt.setInt(pos++, mbox.getRecentMessageCount());\n            stmt.setInt(pos++, mbox.getIndexDeferredCount());\n            stmt.setString(pos++, mbox.getHighestFlushedToIndex().toString());\n            stmt.setLong(pos++, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"updating mailbox statistics for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void startTrackingSync(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_MAILBOX) +\n                    \" SET tracking_sync = ? WHERE id = ? AND tracking_sync <= 0\");\n            stmt.setInt(1, mbox.getLastChangeID());\n            stmt.setLong(2, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"turning on sync tracking for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void startTrackingImap(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_MAILBOX) +\n                    \" SET tracking_imap = 1 WHERE id = ?\");\n            stmt.setLong(1, mbox.getId());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"turning on imap tracking for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static String getConfig(Mailbox mbox, String section) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT metadata FROM \" + qualifyZimbraTableName(mbox, TABLE_METADATA) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"section = ?\");\n            int pos = 1;\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setLong(pos++, mbox.getId());\n            stmt.setString(pos++, section);\n            rs = stmt.executeQuery();\n            if (rs.next())\n                return rs.getString(1);\n            return null;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting metadata section '\" + section + \"' in mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static void updateConfig(Mailbox mbox, String section, Metadata config) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        Connection conn = mbox.getOperationConnection();\n        PreparedStatement stmt = null;\n        try {\n            if (config == null) {\n                stmt = conn.prepareStatement(\"DELETE FROM \" + qualifyZimbraTableName(mbox, TABLE_METADATA) +\n                        \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"section = ?\");\n                int pos = 1;\n                if (!DebugConfig.disableMailboxGroups)\n                    stmt.setLong(pos++, mbox.getId());\n                stmt.setString(pos++, section.toUpperCase());\n                stmt.executeUpdate();\n                stmt.close();\n            } else {\n                // We try INSERT first even though it's the less common case, to avoid MySQL\n                // deadlock.  See bug 19404 for more info.\n                try {\n                    String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n                    stmt = conn.prepareStatement(command + \" INTO \" + qualifyZimbraTableName(mbox, TABLE_METADATA) +\n                            \" (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"mailbox_id, \") + \"section, metadata)\" +\n                            \" VALUES (\" + (DebugConfig.disableMailboxGroups ? \"\" : \"?, \") + \"?, ?)\");\n                    int pos = 1;\n                    if (!DebugConfig.disableMailboxGroups)\n                        stmt.setLong(pos++, mbox.getId());\n                    stmt.setString(pos++, section);\n                    stmt.setString(pos++, config.toString());\n                    stmt.executeUpdate();\n                } catch (SQLException e) {\n                    if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                        stmt = conn.prepareStatement(\"UPDATE \" + qualifyZimbraTableName(mbox, TABLE_METADATA) +\n                                \" SET metadata = ? WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"section = ?\");\n                        int pos = 1;\n                        stmt.setString(pos++, config.toString());\n                        if (!DebugConfig.disableMailboxGroups)\n                            stmt.setLong(pos++, mbox.getId());\n                        stmt.setString(pos++, section);\n                        int numRows = stmt.executeUpdate();\n                        if (numRows != 1) {\n                            String msg = String.format(\"Unexpected number of rows (%d) updated for section %s\", numRows, section);\n                            throw ServiceException.FAILURE(msg, e);\n                        }\n                    }\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"setting metadata section '\" + section + \"' in mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Returns the zimbra IDs and mailbox IDs for all mailboxes on the\n     *  system.  Note that mailboxes are created lazily, so there may be\n     *  accounts homed on this system for whom there is is not yet a mailbox\n     *  and hence are not included in the returned <code>Map</code>.\n     * \n     * @param conn  An open database connection.\n     * @return A <code>Map</code> whose keys are zimbra IDs and whose values\n     *         are the corresponding numeric mailbox IDs.\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><code>service.FAILURE</code> - an error occurred while accessing\n     *        the database; a SQLException is encapsulated</ul> */\n    public static Map<String, Long> listMailboxes(Connection conn) throws ServiceException {\n        return listMailboxes(conn, MailboxManager.getInstance());\n    }\n\n    public static Map<String, Long> listMailboxes(Connection conn, MailboxManager mmgr) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mmgr));\n\n        HashMap<String, Long> result = new HashMap<String, Long>();\n        if (DebugConfig.externalMailboxDirectory)\n            return result;\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT account_id, id FROM mailbox\");\n            rs = stmt.executeQuery();\n            while (rs.next())\n                result.put(rs.getString(1).toLowerCase(), rs.getLong(2));\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching mailboxes\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /** Returns the zimbra IDs and approximate sizes for all mailboxes on\n     *  the system.  Note that mailboxes are created lazily, so there may be\n     *  accounts homed on this system for whom there is is not yet a mailbox\n     *  and hence are not included in the returned <code>Map</code>.  Sizes\n     *  are checkpointed frequently, but there is no guarantee that the\n     *  approximate sizes are currently accurate.\n     * \n     * @param conn  An open database connection.\n     * @return A <code>Map</code> whose keys are zimbra IDs and whose values\n     *         are the corresponding approximate mailbox sizes.\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><code>service.FAILURE</code> - an error occurred while accessing\n     *        the database; a SQLException is encapsulated</ul> */\n    public static Map<String, Long> getMailboxSizes(Connection conn, List<Long> mailboxIds) throws ServiceException {\n        // FIXME: wrong locking check for DB-per-user case\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        HashMap<String, Long> sizes = new HashMap<String, Long>();\n        if (DebugConfig.externalMailboxDirectory)\n            return sizes;\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (!DebugConfig.disableMailboxGroups) {\n                stmt = conn.prepareStatement(\"SELECT account_id, size_checkpoint FROM mailbox\");\n                rs = stmt.executeQuery();\n                while (rs.next())\n                    sizes.put(rs.getString(1).toLowerCase(), rs.getLong(2));\n            } else {\n                // FIXME: not taking mailbox locks in the non-ROW_LEVEL_LOCKING case\n                for (long mailboxId : mailboxIds) {\n                    // note that if groups are disabled, mailboxId == groupId\n                    Db.getInstance().registerDatabaseInterest(conn, getDatabaseName(mailboxId));\n\n                    stmt = conn.prepareStatement(\"SELECT account_id, size_checkpoint FROM \" + qualifyZimbraTableName(mailboxId, TABLE_MAILBOX));\n                    rs = stmt.executeQuery();\n                    while (rs.next())\n                        sizes.put(rs.getString(1).toLowerCase(), rs.getLong(2));\n                    rs.close();    rs = null;\n                    stmt.close();  stmt = null;\n\n                    // XXX: have to avoid having too many attached databases referenced in the same transaction?\n                    conn.commit();\n                }\n            }\n            return sizes;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching mailboxes\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static final int CHANGE_CHECKPOINT_INCREMENT = Math.max(1, LC.zimbra_mailbox_change_checkpoint_frequency.intValue());\n    public static final int ITEM_CHECKPOINT_INCREMENT   = 20;\n\n    public static Mailbox.MailboxData getMailboxStats(Connection conn, long mailboxId) throws ServiceException {\n        // no locking check because it's a mailbox-level op done before the Mailbox object is instantiated...\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (DebugConfig.disableMailboxGroups)\n                Db.getInstance().registerDatabaseInterest(conn, getDatabaseName(mailboxId));\n\n            // note that if groups are disabled, mailboxId == groupId\n            stmt = conn.prepareStatement(\n                    \"SELECT account_id,\" + (DebugConfig.disableMailboxGroups ? mailboxId : \" group_id\") + \",\" +\n                    \" size_checkpoint, contact_count, item_id_checkpoint, change_checkpoint, tracking_sync,\" +\n                    \" tracking_imap, index_volume_id, last_soap_access, new_messages, idx_deferred_count, highest_indexed \" +\n                    \"FROM \" + qualifyZimbraTableName(mailboxId, TABLE_MAILBOX) + \" WHERE id = ?\");\n            stmt.setLong(1, mailboxId);\n            rs = stmt.executeQuery();\n\n            if (!rs.next())\n                return null;\n            int pos = 1;\n            Mailbox.MailboxData mbd = new Mailbox.MailboxData();\n            mbd.id            = mailboxId;\n            mbd.accountId     = rs.getString(pos++).toLowerCase();\n            mbd.schemaGroupId = rs.getLong(pos++);\n            mbd.size          = rs.getLong(pos++);\n            if (rs.wasNull())\n                mbd.size = -1;\n            mbd.contacts      = rs.getInt(pos++);\n            if (rs.wasNull())\n                mbd.contacts = -1;\n            mbd.lastItemId    = rs.getInt(pos++);\n            mbd.lastChangeId  = rs.getInt(pos++);\n            mbd.trackSync     = rs.getInt(pos++);\n            mbd.trackImap     = rs.getBoolean(pos++);\n            mbd.indexVolumeId = rs.getShort(pos++);\n            mbd.lastWriteDate = rs.getInt(pos++);\n            mbd.recentMessages = rs.getInt(pos++);\n            mbd.idxDeferredCount = rs.getInt(pos++);\n\n            String highestModContentIndexed = rs.getString(pos++);\n            if (highestModContentIndexed == null || highestModContentIndexed.length() == 0)\n                mbd.highestModContentIndexed = new SyncToken(mbd.lastChangeId);\n            else {\n                try {\n                    mbd.highestModContentIndexed = new SyncToken(highestModContentIndexed);\n                } catch (MailServiceException e) {\n                    ZimbraLog.mailbox.warn(\"Exception loading index high water mark from DB.  \" +\n                    \t\t\"Using current mod_content value: \"+mbd.lastChangeId, e);\n                    mbd.highestModContentIndexed = new SyncToken(mbd.lastChangeId);\n                }\n            }\n            \n            mbd.lastBackupDate = -1;\n\n            // round lastItemId and lastChangeId up so that they get written on the next change\n            mbd.lastItemId += ITEM_CHECKPOINT_INCREMENT - 1;\n            mbd.lastChangeId += CHANGE_CHECKPOINT_INCREMENT - 1;\n            long rounding = mbd.lastItemId % ITEM_CHECKPOINT_INCREMENT;\n            if (rounding != ITEM_CHECKPOINT_INCREMENT - 1)\n                mbd.lastItemId -= rounding + 1;\n            rounding = mbd.lastChangeId % CHANGE_CHECKPOINT_INCREMENT;\n            if (rounding != CHANGE_CHECKPOINT_INCREMENT - 1)\n                mbd.lastChangeId -= rounding + 1;\n\n            rs.close();    rs = null;\n            stmt.close();  stmt = null;\n\n            stmt = conn.prepareStatement(\"SELECT section FROM \" + qualifyZimbraTableName(mailboxId, TABLE_METADATA) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setLong(1, mailboxId);\n            rs = stmt.executeQuery();\n\n            while (rs.next()) {\n                if (mbd.configKeys == null)\n                    mbd.configKeys = new HashSet<String>();\n                mbd.configKeys.add(rs.getString(1));\n            }\n\n            return mbd;\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.NO_SUCH_TABLE))\n                return null;\n            throw ServiceException.FAILURE(\"fetching stats on mailbox \" + mailboxId, e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n\n    /** Returns the object to synchronize all accesses to tables in the ZIMBRA\n     *  database on.  When the underlying database supports row-level locking,\n     *  this will be a new <code>Object</code> -- that is, effectively no\n     *  synchronization, since none is necessary.  If synchronization is needed\n     *  but the code is not encapsulated in a \n     *     <code>synchronized (DbMailbox.getSynchronizer()) { }</code>\n     *  block, calls to DbMailbox methods will assert.\n     * @see Db.Capability#ROW_LEVEL_LOCKING */\n    public static Object getSynchronizer() {\n        try {\n            if (!Db.supports(Db.Capability.ROW_LEVEL_LOCKING))\n                return MailboxManager.getInstance();\n        } catch (ServiceException e) { }\n\n        return new Object();\n    }\n\n    public static Object getZimbraSynchronizer(Mailbox mbox) throws ServiceException {\n        return DebugConfig.disableMailboxGroups ? mbox : MailboxManager.getInstance();\n    }\n\n\n    public static long calculateMailboxGroupId(long mailboxId) {\n        int groups = DebugConfig.numMailboxGroups;\n        // -1 / +1 operations are done so that the group id is never 0.\n        return (mailboxId - 1) % groups + 1;\n    }\n\n    /** Returns the name of the database that contains tables for the\n     *  specified <code>mailboxId</code>.  As a side effect, also registers\n     *  interest on that database with the specified {@link Connection} (if\n     *  not <tt>null</tt>). */\n    public static String getDatabaseName(Mailbox mbox) {\n        return getDatabaseName(mbox.getSchemaGroupId());\n    }\n\n    public static String getDatabaseName(long groupId) {\n        return DB_PREFIX_MAILBOX_GROUP + groupId;\n    }\n\n    /** Qualifies the name of a database table that may be in the per-user\n     *  database if {@link DebugConfig.disableMailboxGroups} is set and in\n     *  the <tt>ZIMBRA</tt> database otherwise. */\n    public static String qualifyZimbraTableName(Mailbox mbox, String tableName) {\n        return DebugConfig.disableMailboxGroups ? qualifyTableName(mbox, tableName) : tableName;\n    }\n\n    /** Qualifies the name of a database table that may be in the per-user\n     *  database if {@link DebugConfig.disableMailboxGroups} is set and in\n     *  the <tt>ZIMBRA</tt> database otherwise. */\n    public static String qualifyZimbraTableName(long mailboxId, String tableName) {\n        // note that if groups are disabled, mailboxId == groupId\n        return DebugConfig.disableMailboxGroups ? qualifyTableName(mailboxId, tableName) : tableName;\n    }\n\n    public static String qualifyTableName(Mailbox mbox, String tableName) {\n        return qualifyTableName(mbox.getSchemaGroupId(), tableName);\n    }\n\n    public static String qualifyTableName(long groupId, String tableName) {\n        return DB_PREFIX_MAILBOX_GROUP + groupId + '.' + tableName;\n    }\n\n\n    public static void removeFromDeletedAccount(Connection conn, String email)\n    throws ServiceException {\n        PreparedStatement stmt = null;\n        try {\n            // add the mailbox's account to deleted_account table\n            stmt = conn.prepareStatement(\"DELETE FROM deleted_account WHERE email = ?\");\n            stmt.setString(1, email.toLowerCase());\n            stmt.executeUpdate();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting row for \" + email + \" from deleted_account table\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static void addToDeletedAccount(Connection conn, Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        if (DebugConfig.externalMailboxDirectory)\n            return;\n\n        // Get email address for mailbox by querying the mailbox table.  We can't get it by\n        // calling mbox.getAccount().getName() because the account was already deleted from LDAP.\n        String email = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT comment FROM mailbox WHERE id = ?\");\n            stmt.setLong(1, mbox.getId());\n            rs = stmt.executeQuery();\n            if (rs.next())\n                email = rs.getString(1);\n            else\n                throw ServiceException.FAILURE(\"no email address found for mailbox \" + mbox.getId(), null);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting email address for mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        removeFromDeletedAccount(conn, email);\n\n        try {\n            // add the mailbox's account to deleted_account table\n            stmt = conn.prepareStatement(\n                    \"INSERT INTO deleted_account (email, account_id, mailbox_id, deleted_at) \" +\n                    \"SELECT ?, account_id, id, ? FROM mailbox WHERE id = ?\");\n            stmt.setString(1, email.toLowerCase());\n            stmt.setLong(2, System.currentTimeMillis() / 1000);\n            stmt.setLong(3, mbox.getId());\n            stmt.executeUpdate();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"marking mailbox \" + mbox.getId() + \" as deleted\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Returns a DeletedAccount object for the given email, if the account for the email\n     * address was previously deleted.  Returns null if account for the email was not\n     * deleted.\n     * @param conn\n     * @param email\n     * @return\n     * @throws ServiceException\n     */\n    public static DeletedAccount getDeletedAccount(Connection conn, String email)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\n                    \"SELECT email, account_id, mailbox_id, deleted_at \" +\n                    \"FROM deleted_account WHERE email = ?\");\n            stmt.setString(1, email.toLowerCase());\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                String emailCol = rs.getString(1);\n                String accountId = rs.getString(2).toLowerCase();\n                long mailboxId = rs.getLong(3);\n                long deletedAt = rs.getLong(4) * 1000;\n                return new DeletedAccount(emailCol, accountId, mailboxId, deletedAt);\n            } else {\n                return null;\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"checking if account \" + email + \" is deleted\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    public static class DeletedAccount {\n        private String mEmail;\n        private String mAccountId;\n        private long mMailboxId;\n        private long mDeletedAt;\n\n        public DeletedAccount(String email, String accountId, long mailboxId, long deletedAt) {\n            mEmail = email;\n            mAccountId = accountId;\n            mMailboxId = mailboxId;\n            mDeletedAt = deletedAt;\n        }\n\n        public String getEmail()      { return mEmail; }\n        public String getAccountId()  { return mAccountId; }\n        public long getMailboxId()    { return mMailboxId; }\n        public long getDeletedAt()    { return mDeletedAt; }\n    }\n\n    /**\n     * Deletes the row for the specified mailbox from the <code>mailbox</code> table.\n     *  \n     * @throws ServiceException if the database operation failed\n     */\n    public static void deleteMailbox(Connection conn, Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(getZimbraSynchronizer(mbox)));\n\n        addToDeletedAccount(conn, mbox);\n\n        PreparedStatement stmt = null;\n        try {\n            if (DebugConfig.disableMailboxGroups) {\n                // remove entry from MBOXGROUP database (is this redundant?)\n                stmt = conn.prepareStatement(\"DELETE FROM \" + qualifyTableName(mbox, TABLE_MAILBOX) +\n                        \" WHERE id = ?\");\n                stmt.setLong(1, mbox.getId());\n                stmt.executeUpdate();\n                stmt.close();\n            }\n\n            // remove entry from mailbox table\n            if (!DebugConfig.externalMailboxDirectory) {\n                stmt = conn.prepareStatement(\"DELETE FROM mailbox WHERE id = ?\");\n                stmt.setLong(1, mbox.getId());\n                stmt.executeUpdate();\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"deleting mailbox \" + mbox.getId(), e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    static Set<Long> getDistinctTagsets(Connection conn, Mailbox mbox) throws ServiceException {\n        Set<Long> tagsets = new HashSet<Long>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT DISTINCT(tags) FROM \" + DbMailItem.getMailItemTableName(mbox) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setLong(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next())\n                tagsets.add(rs.getLong(1));\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct tagsets\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return tagsets;\n    }\n\n    static Set<Long> getDistinctFlagsets(Connection conn, Mailbox mbox) throws ServiceException {\n        Set<Long> flagsets = new HashSet<Long>();\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT DISTINCT(flags) FROM \" + DbMailItem.getMailItemTableName(mbox) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            if (!DebugConfig.disableMailboxGroups)\n                stmt.setLong(1, mbox.getId());\n            rs = stmt.executeQuery();\n            while (rs.next())\n                flagsets.add(rs.getLong(1));\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct flagsets\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return flagsets;\n    }\n\n    /**\n     * Returns the account id's for the current server.\n     */\n    public static Set<String> listAccountIds(Connection conn) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        Set<String> accountIds = new HashSet<String>();\n        if (DebugConfig.externalMailboxDirectory)\n            return accountIds;\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT account_id FROM mailbox\");\n            rs = stmt.executeQuery();\n            while (rs.next())\n                accountIds.add(rs.getString(1).toLowerCase());\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct account ids\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return accountIds;\n    }\n  \n    public static List<Mailbox.MailboxData> getMailboxRawData(Connection conn) throws ServiceException {\n        List<Mailbox.MailboxData> results = new ArrayList<Mailbox.MailboxData>();\n        if (DebugConfig.externalMailboxDirectory)\n            return results;\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            if (!DebugConfig.disableMailboxGroups) {\n                assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n                stmt = conn.prepareStatement(\n                        \"SELECT id, group_id, account_id, index_volume_id, item_id_checkpoint,\" +\n                        \" contact_count, size_checkpoint, change_checkpoint, tracking_sync,\" +\n                        \" tracking_imap, last_backup_at, last_soap_access, new_messages,\" +\n                        \" idx_deferred_count, highest_indexed \" +\n                        \"FROM mailbox\");\n                rs = stmt.executeQuery();\n                readMailboxRawData(results, rs);\n            } else {\n                // FIXME: need an (impossible) assert for synchronization purposes\n\n                long[] mailboxIds = MailboxManager.getInstance().getMailboxIds();\n                for (long mailboxId : mailboxIds) {\n                    Db.getInstance().registerDatabaseInterest(conn, getDatabaseName(mailboxId));\n\n                    stmt = conn.prepareStatement(\n                            \"SELECT id, id, account_id, index_volume_id, item_id_checkpoint, contact_count, size_checkpoint,\" +\n                            \" change_checkpoint, tracking_sync, tracking_imap, -1, last_soap_access, new_messages,\" +\n                            \" idx_deferred_count, highest_indexed\" +\n                            \"FROM \" + qualifyZimbraTableName(mailboxId, TABLE_MAILBOX));\n                    rs = stmt.executeQuery();\n                    readMailboxRawData(results, rs);\n                    rs.close();    rs = null;\n                    stmt.close();  stmt = null;\n\n                    // XXX: have to avoid having too many attached databases referenced in the same transaction?\n                    conn.commit();\n                }\n            }\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"getting distinct account id's\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        return results;\n    }\n\n    private static void readMailboxRawData(List<Mailbox.MailboxData> results, ResultSet rs) throws SQLException {\n        while (rs.next()) {\n            Mailbox.MailboxData data = new Mailbox.MailboxData();\n            int pos = 1;\n            data.id = rs.getLong(pos++);\n            data.schemaGroupId = rs.getLong(pos++);\n            data.accountId = rs.getString(pos++).toLowerCase();\n            data.indexVolumeId = rs.getShort(pos++);\n            data.lastItemId = rs.getInt(pos++);\n            data.contacts = rs.getInt(pos++);\n            data.size = rs.getLong(pos++);\n            data.lastChangeId = rs.getInt(pos++);\n            data.trackSync = rs.getInt(pos++);\n            data.trackImap = rs.getBoolean(pos++);\n            data.lastBackupDate = rs.getInt(pos++);\n            // data.comment = rs.getString(pos++);\n            data.lastWriteDate = rs.getInt(pos++);\n            data.recentMessages = rs.getInt(pos++);\n            data.idxDeferredCount = rs.getInt(pos++);\n            \n            String highestModContentIndexed = rs.getString(pos++);\n            if (highestModContentIndexed == null || highestModContentIndexed.length() == 0)\n                data.highestModContentIndexed = new SyncToken(data.lastChangeId);\n            else {\n                try {\n                    data.highestModContentIndexed = new SyncToken(highestModContentIndexed);\n                } catch (ServiceException e) {\n                    ZimbraLog.mailbox.warn(\"Exception loading index high water mark from DB.  \" +\n                                           \"Using current mod_content value: \"+data.lastChangeId, e);\n                    data.highestModContentIndexed = new SyncToken(data.lastChangeId);\n                }\n            }\n            \n            results.add(data);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "42fb495e7c760bf2187f46b2a1fee8da1e42b1dc",
    "commit_msg": "(split)bug: 43649 add twice daily sqlite \"analyze\" optimization\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=43649\n\nCopied from Perforce\n Change: 222907",
    "original_file": "DbMailbox.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 11,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.DataSource;\nimport com.zimbra.cs.datasource.ImapFolder;\nimport com.zimbra.cs.datasource.ImapMessage;\nimport com.zimbra.cs.datasource.ImapMessageCollection;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.Mailbox;\n\n\npublic class DbImapMessage {\n\n    public static final String TABLE_IMAP_MESSAGE = \"imap_message\";\n    \n    /**\n     * Stores IMAP message tracker data.\n     */\n    public static void storeImapMessage(Mailbox mbox, int localFolderId, long remoteUid, int localItemId, int flags)\n    throws ServiceException\n    {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.datasource.debug(\n            \"Storing IMAP message tracker: mboxId=%d, localFolderId=%d, remoteUid=%d, localItemId=%d flags=%s\",\n            mbox.getId(), localFolderId, remoteUid, localItemId, Flag.bitmaskToFlags(flags));\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"INSERT INTO \" + getTableName(mbox) +\n                \" (mailbox_id, imap_folder_id, uid, item_id, flags) \" +\n                \"VALUES (?, ?, ?, ?, ?)\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, localFolderId);\n            stmt.setLong(3, remoteUid);\n            stmt.setInt(4, localItemId);\n            stmt.setInt(5, flags);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to store IMAP message data\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    public static void setUid(Mailbox mbox, int itemId, long uid)\n        throws ServiceException {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\n            \"Updating IMAP message tracker uid: mboxId=%d, localItemId=%d remoteUid=%x\",\n            mbox.getId(), itemId, uid);\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"UPDATE \" + getTableName(mbox) + \" SET uid = ?\" +\n                \" WHERE mailbox_id = ? AND item_id = ?\");\n            stmt.setLong(1, uid);\n            stmt.setInt(2, mbox.getId());\n            stmt.setInt(3, itemId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to update IMAP message data\", e);\n        } finally {\n            if (stmt != null) DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n    \n    public static void setFlags(Mailbox mbox, int itemId, int flags)\n        throws ServiceException\n    {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ZimbraLog.datasource.debug(\n            \"Updating IMAP message tracker flags: mboxId=%d, localItemId=%d flags=%s\",\n            mbox.getId(), itemId, Flag.bitmaskToFlags(flags));\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"UPDATE \" + getTableName(mbox) + \" SET flags = ?\" +\n                \" WHERE mailbox_id = ? AND item_id = ?\");\n            stmt.setInt(1, flags);\n            stmt.setInt(2, mbox.getId());\n            stmt.setInt(3, itemId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to update IMAP message data\", e);\n        } finally {\n            if (stmt != null) DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n    /**\n     * Deletes IMAP message tracker data.\n     */\n    public static void deleteImapMessage(Mailbox mbox, int localFolderId, int localItemId)\n    throws ServiceException\n    {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.datasource.debug(\n            \"Deleting IMAP message tracker: mboxId=%d, localFolderId=%d, msgId=%d\",\n            mbox.getId(), localFolderId, localItemId);\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + getTableName(mbox) +\n                \" WHERE mailbox_id = ? AND imap_folder_id = ? AND item_id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, localFolderId);\n            stmt.setInt(3, localItemId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete IMAP message data\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    } \n\n    /**\n     * Deletes IMAP message tracker data.\n     */\n    public static void deleteImapMessages(Mailbox mbox, int localFolderId)\n    throws ServiceException\n    {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        \n        ZimbraLog.datasource.debug(\n            \"Deleting all IMAP message trackers: mboxId=%d, localFolderId=%d\", mbox.getId(), localFolderId);\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"DELETE FROM \" + getTableName(mbox) +\n                \" WHERE mailbox_id = ? AND imap_folder_id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, localFolderId);\n            stmt.executeUpdate();\n            conn.commit();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to delete IMAP message data\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n\n    // Returns local message item id for specified folder id and remote uid\n    // if a tracker exists, otherwise returns 0.\n    public static int getLocalMessageId(Mailbox mbox, int localFolderId, long remoteUid)\n        throws ServiceException {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n\n        ZimbraLog.datasource.debug(\n            \"Getting local message id for tracked message: mboxId=%d, localFolderId=%d, remoteUid=%d\",\n            mbox.getId(), localFolderId, remoteUid);\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"SELECT item_id\" +\n                \" FROM \" + getTableName(mbox) +\n                \" WHERE mailbox_id = ? AND imap_folder_id = ? AND uid = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.setInt(2, localFolderId);\n            stmt.setLong(3, remoteUid);\n            rs = stmt.executeQuery();\n            return rs.next() ? rs.getInt(1) : 0;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get IMAP message data\", e);\n        } finally {\n            if (rs != null) DbPool.closeResults(rs);\n            if (stmt != null) DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n    }\n    \n    /**\n     * Returns a collection of tracked IMAP messages for the given data source.\n     */\n    public static ImapMessageCollection getImapMessages(Mailbox mbox, DataSource ds, ImapFolder imapFolder)\n    throws ServiceException {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        ImapMessageCollection imapMessages = new ImapMessageCollection();\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"SELECT imap.uid, imap.item_id, imap.flags as tflags, mi.unread, mi.flags \" +\n                \"FROM \" + getTableName(mbox) + \" imap \" +\n                \"  LEFT OUTER JOIN \" + DbMailItem.getMailItemTableName(mbox) + \" mi \" +\n                \"  ON imap.mailbox_id = mi.mailbox_id AND imap.item_id = mi.id \" + \n                \"WHERE imap.mailbox_id = ? AND imap.imap_folder_id = ?\");\n\n            int i = 1;\n            stmt.setInt(i++, mbox.getId());\n            stmt.setInt(i++, imapFolder.getItemId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                long uid = rs.getLong(\"uid\");\n                int itemId = rs.getInt(\"item_id\");\n                int flags = rs.getInt(\"flags\");\n                int unread = rs.getInt(\"unread\");\n                int tflags = rs.getInt(\"tflags\");\n                flags = unread > 0 ? (flags | Flag.BITMASK_UNREAD) : (flags & ~Flag.BITMASK_UNREAD);\n                imapMessages.add(new ImapMessage(uid, itemId, flags, tflags));\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get IMAP message data\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n\n        ZimbraLog.mailbox.debug(\"Found %d tracked IMAP messages for %s\",\n            imapMessages.size(), imapFolder.getRemotePath());\n        return imapMessages;\n    }\n\n    /**\n     * Returns a collection of tracked IMAP messages for the given data source.\n     * @return the new message ids, or an empty <tt>List</tt> if there are none.\n     */\n    public static List<Integer> getNewLocalMessageIds(Mailbox mbox, DataSource ds, ImapFolder imapFolder)\n    throws ServiceException {\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        List<Integer> newIds = new ArrayList<Integer>();\n\n        try {\n            conn = DbPool.getConnection();\n            stmt = conn.prepareStatement(\n                \"SELECT id FROM \" + DbMailItem.getMailItemTableName(mbox) + \" mi \" +\n                \"  LEFT OUTER JOIN \" + getTableName(mbox) + \" imap \" +\n                \"  ON imap.mailbox_id = mi.mailbox_id AND imap.item_id = mi.id \" + \n                \"WHERE mi.mailbox_id = ? AND mi.folder_id = ? AND imap.item_id IS NULL \" +\n                \"AND mi.type IN (\" + MailItem.TYPE_MESSAGE + \", \" + MailItem.TYPE_CHAT + \")\");\n\n            int i = 1;\n            stmt.setInt(i++, mbox.getId());\n            stmt.setInt(i++, imapFolder.getItemId());\n            rs = stmt.executeQuery();\n            while (rs.next()) {\n                newIds.add(rs.getInt(\"id\"));\n            }\n            rs.close();\n            stmt.close();\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"Unable to get new local message ids\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n            DbPool.quietClose(conn);\n        }\n\n        ZimbraLog.mailbox.debug(\"Found %d new local message ids for %s\",\n            newIds.size(), imapFolder.getRemotePath());\n        return newIds;\n    }\n\n    public static String getTableName(int mailboxId, int groupId) {\n        return String.format(\"%s.%s\", DbMailbox.getDatabaseName(groupId), TABLE_IMAP_MESSAGE);\n    }\n\n    public static String getTableName(Mailbox mbox) {\n        return DbMailbox.getDatabaseName(mbox) + \".\" + TABLE_IMAP_MESSAGE;\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "ea4340b7620fbcc9042728b38750dacc03d85045",
    "commit_msg": "(split)bug: 29563\n\nSQLite is now database-per-mailbox.  (Those DBs are all in /opt/zimbra/sqlite for now.)  The \"debug_disable_mailbox_group\" localconfig debug key is back and does the right thing again.\n\nFixed some INSERT SELECT syntax issues with SQLite.  Fixed a SQLite REPLACE INTO issue.  Updated data source DB code to work with SQLite.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=29563\n\nCopied from Perforce\n Change: 105347",
    "original_file": "DbImapMessage.java",
    "confidence_score": 1.0
  },
  {
    "serial_no": 12,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2016 Synacor, Inc.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software Foundation,\n * version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License along with this program.\n * If not, see <https://www.gnu.org/licenses/>.\n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Nov 28, 2004\n */\npackage com.zimbra.cs.session;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport com.zimbra.common.mailbox.MailboxStore;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.MailItem.Type;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.Metadata;\nimport com.zimbra.cs.mailbox.util.TypedIdList;\n\n\n/**\n * @param <T> - MailItem (local mailbox) | ZBaseItem (remote mailbox)\n*/\npublic abstract class PendingModifications<T> {\n    public static abstract class Change {\n        public static final int NONE             = 0x00000000;\n        public static final int UNREAD           = 0x00000001;\n        public static final int TAGS             = 0x00000002;\n        public static final int FLAGS            = 0x00000004;\n        public static final int CONFIG           = 0x00000008;\n        public static final int SIZE             = 0x00000010;\n        public static final int DATE             = 0x00000020;\n        public static final int SUBJECT          = 0x00000040;\n        public static final int IMAP_UID         = 0x00000080;\n        public static final int FOLDER           = 0x00000100;\n        public static final int PARENT           = 0x00000200;\n        public static final int CHILDREN         = 0x00000400;\n        public static final int SENDERS          = 0x00000800;\n        public static final int NAME             = 0x00001000;\n        public static final int COLOR            = 0x00002000;\n        public static final int POSITION         = 0x00004000;\n        public static final int QUERY            = 0x00008000;\n        public static final int CONTENT          = 0x00010000;\n        public static final int INVITE           = 0x00020000;\n        public static final int URL              = 0x00040000;\n        public static final int METADATA         = 0x00080000;\n        public static final int VIEW             = 0x00100000;\n        public static final int ACL              = 0x00200000;\n        public static final int CONFLICT         = 0x00400000;\n        public static final int LOCK             = 0x00800000;\n        public static final int SHAREDREM        = 0x01000000;\n        public static final int RETENTION_POLICY = 0x02000000;\n        public static final int DISABLE_ACTIVESYNC = 0x04000000;\n        public static final int INTERNAL_ONLY    = 0x10000000;\n        public static final int ALL_FIELDS       = ~0;\n\n        public Object what;\n        public int    why;\n        public Object preModifyObj;\n\n        Change(Object thing, int reason, Object preModifyObj) {\n            what = thing; // MailItem.Type for deletions\n            why = reason; // not applicable for deletions\n            this.preModifyObj = preModifyObj;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            toStringInit(sb);\n\n            if (why == 0) sb.append(\" **NONE**\");\n            if ((why & UNREAD) != 0)    sb.append(\" UNREAD\");\n            if ((why & TAGS) != 0)      sb.append(\" TAGS\");\n            if ((why & FLAGS) != 0)     sb.append(\" FLAGS\");\n            if ((why & CONFIG) != 0)    sb.append(\" CONFIG\");\n            if ((why & SIZE) != 0)      sb.append(\" SIZE\");\n            if ((why & DATE) != 0)      sb.append(\" DATE\");\n            if ((why & SUBJECT) != 0)   sb.append(\" SUBJECT\");\n            if ((why & IMAP_UID) != 0)  sb.append(\" IMAP_UID\");\n            if ((why & FOLDER) != 0)    sb.append(\" FOLDER\");\n            if ((why & PARENT) != 0)    sb.append(\" PARENT\");\n            if ((why & CHILDREN) != 0)  sb.append(\" CHILDREN\");\n            if ((why & SENDERS) != 0)   sb.append(\" SENDERS\");\n            if ((why & NAME) != 0)      sb.append(\" NAME\");\n            if ((why & COLOR) != 0)     sb.append(\" COLOR\");\n            if ((why & POSITION) != 0)  sb.append(\" POSITION\");\n            if ((why & QUERY) != 0)     sb.append(\" QUERY\");\n            if ((why & CONTENT) != 0)   sb.append(\" CONTENT\");\n            if ((why & INVITE) != 0)    sb.append(\" INVITE\");\n            if ((why & URL) != 0)       sb.append(\" URL\");\n            if ((why & METADATA) != 0)  sb.append(\" METADATA\");\n            if ((why & VIEW) != 0)      sb.append(\" VIEW\");\n            if ((why & ACL) != 0)       sb.append(\" ACL\");\n            if ((why & CONFLICT) != 0)  sb.append(\" CONFLICT\");\n            if ((why & LOCK) != 0)      sb.append(\" LOCK\");\n            if ((why & SHAREDREM) != 0) sb.append(\" SHAREDREM\");\n            if ((why & RETENTION_POLICY) != 0) sb.append(\" RETENTION_POLICY\");\n            if ((why & DISABLE_ACTIVESYNC) != 0) sb.append(\" DISABLE_ACTIVESYNC\");\n            if ((why & INTERNAL_ONLY) != 0)    sb.append(\" **INTERNAL**\");\n\n            return sb.toString();\n        }\n\n        protected abstract void toStringInit(StringBuilder sb);\n    }\n\n    public static class ModificationKey extends Pair<String, Integer> {\n        public ModificationKey(String accountId, Integer itemId) {\n            super(accountId, itemId);\n        }\n\n        public ModificationKey(ModificationKey mkey) {\n            super(mkey.getAccountId(), mkey.getItemId());\n        }\n\n        public String getAccountId() {\n            return getFirst();\n        }\n\n        public Integer getItemId() {\n            return getSecond();\n        }\n\n        public void setAccountId(String accountId) {\n            setFirst(accountId);\n        }\n\n        public void setItemId(Integer itemId) {\n            setSecond(itemId);\n        }\n    }\n\n\n    /**\n     * Set of all the MailItem types that are included in this structure\n     */\n    public Set<MailItem.Type> changedTypes = EnumSet.noneOf(MailItem.Type.class);\n\n    public LinkedHashMap<ModificationKey, T> created;\n    public Map<ModificationKey, Change> modified;\n    public Map<ModificationKey, Change> deleted;\n\n    public boolean hasNotifications() {\n        return (deleted  != null && !deleted.isEmpty()) ||\n               (created  != null && !created.isEmpty()) ||\n               (modified != null && !modified.isEmpty());\n    }\n\n    public int getScaledNotificationCount() {\n        int count = 0;\n        if (deleted != null)   count += (deleted.size() + 3) / 4;\n        if (created != null)   count += created.size();\n        if (modified != null)  count += modified.size();\n        return count;\n    }\n\n    public boolean overlapsWithAccount(String acctId) {\n        acctId = acctId == null ? null : acctId.toLowerCase();\n        if (deleted != null) {\n            for (ModificationKey mkey : deleted.keySet()) {\n                if (mkey.getAccountId().equals(acctId))\n                    return true;\n            }\n        }\n        if (created != null) {\n            for (ModificationKey mkey : created.keySet()) {\n                if (mkey.getAccountId().equals(acctId))\n                    return true;\n            }\n        }\n        if (modified != null) {\n            for (ModificationKey mkey : modified.keySet()) {\n                if (mkey.getAccountId().equals(acctId)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public abstract void recordCreated(T item);\n\n    public void recordDeleted(String acctId, int id, MailItem.Type type) {\n        if (type != MailItem.Type.UNKNOWN) {\n            changedTypes.add(type);\n        }\n        ModificationKey key = new ModificationKey(acctId, id);\n        delete(key, type, null);\n    }\n\n    public void recordDeleted(String acctId, TypedIdList idlist) {\n        changedTypes.addAll(idlist.types());\n        for (Map.Entry<MailItem.Type, List<TypedIdList.ItemInfo>> entry : idlist) {\n            MailItem.Type type = entry.getKey();\n            for (TypedIdList.ItemInfo iinfo : entry.getValue()) {\n                delete(new ModificationKey(acctId, iinfo.getId()), type, null);\n            }\n        }\n    }\n\n    public abstract void recordDeleted(T itemSnapshot);\n\n    public void recordDeleted(Map<ModificationKey, Change> deletes) {\n        if (deletes != null && !deletes.isEmpty()) {\n            for (Map.Entry<ModificationKey, Change> entry : deletes.entrySet()) {\n                changedTypes.add((MailItem.Type) entry.getValue().what);\n                delete(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    protected abstract void delete(ModificationKey key, MailItem.Type type, T itemSnapshot);\n\n    protected void delete(ModificationKey key, Change chg) {\n        if (created != null && created.remove(key) != null)\n            return;\n\n        if (modified != null) {\n            modified.remove(key);\n        }\n        if (deleted == null) {\n            deleted = new HashMap<ModificationKey, Change>();\n        }\n        Change existingChg = deleted.get(key);\n        if (existingChg == null) {\n            deleted.put(key, chg);\n        } else if (existingChg.preModifyObj == null) {\n            existingChg.preModifyObj = chg.preModifyObj;\n        }\n    }\n\n    public abstract void recordModified(ModificationKey mkey, Change chg);\n\n    public abstract void recordModified(MailboxStore mbox, int reason);\n\n    public abstract void recordModified(T item, int reason);\n\n    public abstract void recordModified(T item, int reason, T preModifyItem);\n\n    abstract PendingModifications<T> add(PendingModifications<T> other);\n\n    public void clear()  {\n        created = null;\n        deleted = null;\n        modified = null;\n        changedTypes.clear();\n    }\n\n    public static final class ModificationKeyMeta implements Serializable {\n\n        String accountId;\n        Integer itemId;\n\n        public ModificationKeyMeta(String accountId, int itemId) {\n            this.accountId = accountId;\n            this.itemId = itemId;\n        }\n\n    }\n\n    public static final class ChangeMeta implements Serializable {\n        public static enum ObjectType {\n            MAILBOX, MAILITEM, MAILITEMTYPE\n        }\n        public ObjectType whatType;\n        public String metaWhat;\n        public int    metaWhy;\n        public ObjectType preModifyObjType;\n        public String metaPreModifyObj;\n\n        public ChangeMeta(ObjectType type, String thing, int reason, ObjectType preModifyObjType, String preModifyObj) {\n            whatType = type;\n            metaWhat = thing; // MailItem.Type for deletions\n            metaWhy = reason; // not applicable for deletions\n            this.preModifyObjType = preModifyObjType;\n            metaPreModifyObj = preModifyObj;\n        }\n\n    }\n\n    private Map<ModificationKeyMeta, ChangeMeta> getSerializable(Map<ModificationKey, Change> map) {\n        if (map == null) {\n            return null;\n        }\n        Map<ModificationKeyMeta, ChangeMeta> ret = new LinkedHashMap<ModificationKeyMeta, ChangeMeta>();\n        Iterator<Entry<ModificationKey, Change>> iter = map.entrySet().iterator();\n        while (iter.hasNext()) {\n            Entry<ModificationKey, Change> entry = iter.next();\n            Change change = entry.getValue();\n            ChangeMeta.ObjectType whatType;\n            String metaWhat;\n            ChangeMeta.ObjectType metaPreModifyObjType = null;\n            String metaPreModifyObj = null;\n            if (change.what instanceof MailItem) {\n                whatType = ChangeMeta.ObjectType.MAILITEM;\n                metaWhat = ((MailItem) change.what).serializeUnderlyingData().toString();\n            } else if (change.what instanceof MailItem.Type) {\n                whatType = ChangeMeta.ObjectType.MAILITEMTYPE;\n                metaWhat = ((MailItem.Type) change.what).name();\n            } else if (change.what instanceof Mailbox) {\n                whatType = ChangeMeta.ObjectType.MAILBOX;\n                // do not serialize mailbox. let the other server load the mailbox again.\n                metaWhat = null;\n            } else {\n                ZimbraLog.session.warn(\"Unexpected mailbox change : \" + change.what);\n                continue;\n            }\n\n            if (change.preModifyObj instanceof MailItem) {\n                metaPreModifyObjType = ChangeMeta.ObjectType.MAILITEM;\n                metaPreModifyObj =  ((MailItem) change.preModifyObj).serializeUnderlyingData().toString();\n            } else if (change.preModifyObj instanceof MailItem.Type) {\n                metaPreModifyObjType = ChangeMeta.ObjectType.MAILITEMTYPE;\n                metaPreModifyObj = ((MailItem.Type) change.preModifyObj).name();\n            } else if (change.preModifyObj instanceof Mailbox) {\n                metaPreModifyObjType = ChangeMeta.ObjectType.MAILBOX;\n                metaPreModifyObj = null;\n            }\n\n            ModificationKeyMeta keyMeta = new ModificationKeyMeta(entry.getKey().getAccountId(), entry.getKey().getItemId());\n            ChangeMeta changeMeta = new ChangeMeta(whatType, metaWhat, change.why, metaPreModifyObjType, metaPreModifyObj);\n            ret.put(keyMeta, changeMeta);\n        }\n        return ret;\n    }\n\n    public byte[] getSerializedBytes() throws IOException {\n        // assemble temporary created, modified, deleted with Metadata\n        LinkedHashMap<ModificationKeyMeta, String> metaCreated = null;\n        Map<ModificationKeyMeta, ChangeMeta> metaModified = null;\n        Map<ModificationKeyMeta, ChangeMeta> metaDeleted = null;\n\n        if (created != null) {\n            metaCreated = new LinkedHashMap<ModificationKeyMeta, String>();\n            Iterator<Entry<ModificationKey, MailItem>> iter = created.entrySet().iterator();\n            while (iter.hasNext()) {\n                Entry<ModificationKey, MailItem> entry = iter.next();\n                ModificationKeyMeta keyMeta = new ModificationKeyMeta(entry.getKey().getAccountId(), entry.getKey().getItemId());\n                MailItem item = entry.getValue();\n                Metadata meta = item.serializeUnderlyingData();\n                metaCreated.put(keyMeta, meta.toString());\n            }\n        }\n        metaModified = getSerializable(modified);\n        metaDeleted = getSerializable(deleted);\n\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(changedTypes);\n        oos.writeObject(metaCreated);\n        oos.writeObject(metaModified);\n        oos.writeObject(metaDeleted);\n        oos.flush();\n        oos.close();\n        return bos.toByteArray();\n    }\n\n\n    private static Map<ModificationKey, Change> getOriginal(Mailbox mbox, Map<ModificationKeyMeta, ChangeMeta> map) throws ServiceException {\n        if (map == null) {\n            return null;\n        }\n        Map<ModificationKey, Change> ret = new LinkedHashMap<ModificationKey, Change>();\n        Iterator<Entry<ModificationKeyMeta, ChangeMeta>> iter = map.entrySet().iterator();\n        while (iter.hasNext()) {\n            Entry<ModificationKeyMeta, ChangeMeta> entry = iter.next();\n            ModificationKey key = new ModificationKey(entry.getKey().accountId, entry.getKey().itemId);\n            ChangeMeta changeMeta = entry.getValue();\n            Object what = null;\n            Object preModifyObj = null;\n            if (changeMeta.whatType == ChangeMeta.ObjectType.MAILITEM) {\n                Metadata meta = new Metadata(changeMeta.metaWhat);\n                MailItem.UnderlyingData ud = new MailItem.UnderlyingData();\n                ud.deserialize(meta);\n                what = MailItem.constructItem(mbox, ud, true);\n                if (what instanceof Folder) {\n                    Folder folder = ((Folder) what);\n                    folder.setParent(mbox.getFolderById(null, folder.getFolderId()));\n                }\n            } else if (changeMeta.whatType == ChangeMeta.ObjectType.MAILITEMTYPE) {\n                what = MailItem.Type.of(changeMeta.metaWhat);\n            } else if (changeMeta.whatType == ChangeMeta.ObjectType.MAILBOX) {\n                mbox.refreshMailbox(null);\n                what = mbox;\n            } else {\n                ZimbraLog.session.warn(\"Unexpected mailbox change type received : \" + changeMeta.whatType);\n                continue;\n            }\n\n            if (changeMeta.preModifyObjType == ChangeMeta.ObjectType.MAILITEM) {\n                Metadata meta = new Metadata(changeMeta.metaPreModifyObj);\n                MailItem.UnderlyingData ud = new MailItem.UnderlyingData();\n                ud.deserialize(meta);\n                preModifyObj = MailItem.constructItem(mbox, ud, true);\n                if (preModifyObj instanceof Folder) {\n                    Folder folder = ((Folder) preModifyObj);\n                    folder.setParent(mbox.getFolderById(null, folder.getFolderId()));\n                }\n            } else if (changeMeta.preModifyObjType == ChangeMeta.ObjectType.MAILITEMTYPE) {\n                preModifyObj = MailItem.Type.of(changeMeta.metaPreModifyObj);\n            } else if (changeMeta.whatType == ChangeMeta.ObjectType.MAILBOX) {\n                what = mbox;\n            } else {\n                ZimbraLog.session.warn(\"Unexpected mailbox change type received : \" + changeMeta.whatType);\n                continue;\n            }\n            Change change = new Change(what, changeMeta.metaWhy, preModifyObj);\n            ret.put(key, change);\n        }\n        return ret;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static PendingModifications deserialize(Mailbox mbox, byte[] data) throws IOException, ClassNotFoundException, ServiceException {\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        ObjectInputStream ois = new ObjectInputStream(bis);\n        PendingModifications pms = new PendingModifications();\n        pms.changedTypes = (Set<Type>) ois.readObject();\n\n        LinkedHashMap<ModificationKeyMeta, String> metaCreated = (LinkedHashMap<ModificationKeyMeta, String>) ois.readObject();\n        if (metaCreated != null) {\n            pms.created = new LinkedHashMap<ModificationKey, MailItem>();\n            Iterator<Entry<ModificationKeyMeta, String>> iter = metaCreated.entrySet().iterator();\n            while (iter.hasNext()) {\n                Entry<ModificationKeyMeta, String> entry = iter.next();\n                Metadata meta = new Metadata(entry.getValue());\n                MailItem.UnderlyingData ud = new MailItem.UnderlyingData();\n                ud.deserialize(meta);\n                MailItem item = MailItem.constructItem(mbox, ud, true);\n                if (item instanceof Folder) {\n                    Folder folder = ((Folder) item);\n                    folder.setParent(mbox.getFolderById(null, folder.getFolderId()));\n\n                }\n                ModificationKey key = new ModificationKey(entry.getKey().accountId, entry.getKey().itemId);\n                pms.created.put(key, item);\n            }\n        }\n\n        Map<ModificationKeyMeta, ChangeMeta> metaModified =  (Map<ModificationKeyMeta, ChangeMeta>) ois.readObject();\n        pms.modified = getOriginal(mbox, metaModified);\n\n        Map<ModificationKeyMeta, ChangeMeta> metaDeleted =  (Map<ModificationKeyMeta, ChangeMeta>) ois.readObject();\n        pms.deleted = getOriginal(mbox, metaDeleted);\n\n        return pms;\n    }\n}\n",
    "vulnerability_type": "Insecure Deserialization",
    "repo": "zm-mailbox",
    "commit": "53c2c67cc87545a9391a506d661716560d3c7f22",
    "commit_msg": "ZMS-265 Refactor serialization/deserializtion methods\n\nThe following methods are not used for IMAP-related operations\non any remote (Z*) items and are not required to be in the\nbase PendingModifications class. Have related them to\nPendingLocalModifications.\n\n- getSerializable\n- getSerializedBytes\n- getOriginal\n- deserialize\n  - In addition to relocating this method to PendingLocalModifications,\n    added a call to close the ObjectInputStream in a finally block.",
    "original_file": "PendingModifications.java",
    "confidence_score": 0.6
  },
  {
    "serial_no": 13,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.milter;\n\nimport org.apache.mina.common.IoSession;\nimport org.apache.mina.filter.codec.ProtocolEncoderAdapter;\nimport org.apache.mina.filter.codec.ProtocolEncoderOutput;\nimport org.apache.mina.common.ByteBuffer;\n\nimport com.zimbra.cs.mina.MinaStats;\n\npublic class MinaMilterEncoder extends ProtocolEncoderAdapter {\n    private final MinaStats stats;\n    \n    MinaMilterEncoder(MinaStats stats) {\n        this.stats = stats;\n    }\n    \n    @Override public void encode(IoSession session, Object msg, ProtocolEncoderOutput out) {\n        MilterPacket packet = (MilterPacket) msg;\n        \n        ByteBuffer buffer = ByteBuffer.allocate(4 + packet.getLength(), false);\n        buffer.setAutoExpand(true);\n        buffer.putInt(packet.getLength());\n        buffer.put(packet.getCommand());       \n        byte[] data = packet.getData();\n        if (data != null && data.length > 0)\n            buffer.put(data);\n        buffer.flip();\n        out.write(buffer);\n        \n        if (stats != null) {\n            stats.sentBytes.addAndGet(buffer.capacity());\n        }\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-mailbox",
    "commit": "dd4c72510f309a16282b22d66a497d3e9fa9fc16",
    "commit_msg": "Integrating from HELIX..\n\nChange 338524 by vmahajan@vmahajan_macbook on 2011/11/10 08:47:54\n\n        bug: 67021 - XSS vulnerability for MIME - *{width:ex\\pression( \n        eval(alert(\"XSS4\")));}\n\n        - Defanger now removes all functions (like url(), expression()) from \n        style value. Specific regular expressions are not very useful \n        because, e.g. expression function name could be encoded as \n        \"\\0065\\0078pression\", or \"&#x5c;0065&#x5c;0078pression\", or \n        expre\\ss\\ion, etc, and each of these are allowed by IE.\n        - Enabled defanger unit tests in HELIX branch.\n        - Added a new test.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=67021\n\nCopied from Perforce\n Change: 338532",
    "original_file": "NioMilterEncoder.java",
    "confidence_score": 1.0
  },
  {
    "serial_no": 14,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Oct 4, 2004\n */\npackage com.zimbra.common.util;\n\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.zimbra.common.service.ServiceException;\n\n/**\n * @author schemers\n */\npublic class StringUtil {\n    \n    /** A user-friendly equal that handles one or both nulls easily. */\n    public static boolean equal(String s1, String s2) {\n        if (s1 == null || s2 == null)\n            return s1 == s2;\n        return s1.equals(s2);\n    }\n\n\tpublic static String stripControlCharacters(String raw) {\n\t\tif (raw == null)\n\t\t\treturn null;\n\t\tint i;\n\t\tfor (i = 0; i < raw.length(); i++) {\n\t\t\tchar c = raw.charAt(i);\n\t\t\t// invalid control characters\n\t\t\tif (c < 0x20 && c != 0x09 && c != 0x0A && c != 0x0D)\n\t\t\t\tbreak;\n\t\t\t// byte-order markers and high/low surrogates\n\t\t\tif (c == 0xFFFE || c == 0xFFFF || (c > 0xD7FF && c < 0xE000))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= raw.length())\n\t\t\treturn raw;\n\t\tStringBuilder sb = new StringBuilder(raw.substring(0, i));\n\t\tfor ( ; i < raw.length(); i++) {\n\t\t\tchar c = raw.charAt(i);\n\t\t\tif (c >= 0x20 || c == 0x09 || c == 0x0A || c == 0x0D)\n\t\t\t\tif (c != 0xFFFE && c != 0xFFFF && (c <= 0xD7FF || c >= 0xE000))\n\t\t\t\t\tsb.append(c);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n    /** Returns whether the passed-in <code>String</code> is comprised only of\n     *  printable ASCII characters.  The \"printable ASCII characters\" are CR,\n     *  LF, TAB, and all characters from 0x20 to 0x7E. */\n    public static boolean isAsciiString(String str) {\n        if (str == null)\n            return false;\n        for (int i = 0, len = str.length(); i < len; i++) {\n            char c = str.charAt(i);\n            if ((c < 0x20 || c >= 0x7F) && c != '\\r' && c != '\\n' && c != '\\t')\n                return false;\n        }\n        return true;\n    }\n\n    /** Removes all spaces (and any character below 0x20) from the end of the\n     *  passed-in <code>String</code>.  If nothing was trimmed, the original\n     *  <code>String</code> is returned. */\n    public static String trimTrailingSpaces(String raw) {\n        if (raw == null)\n            return null;\n        int length = raw.length();\n        while (length > 0 && raw.charAt(length - 1) <= ' ')\n            length--;\n        return length == raw.length() ? raw : raw.substring(0, length);\n    }\n\n    /**\n     * add the name/value mapping to the map. If an entry doesn't exist, value remains\n     * a String. If an entry already exists as a String, convert to String[] and add new\n     * value. If entry already exists as a String[], grow array and add new value.\n     * @param result result map\n     * @param name\n     * @param value\n     */\n    public static void addToMultiMap(Map<String, Object> result, String name, String value) {\n        Object currentValue = result.get(name);\n        if (currentValue == null) {\n            result.put(name, value);\n        } else if (currentValue instanceof String){\n            result.put(name, new String[] { (String)currentValue, value});\n        } else if (currentValue instanceof String[]) {\n            String[] ov = (String[]) currentValue;\n            String[] nv = new String[ov.length+1];\n            System.arraycopy(ov, 0, nv, 0, ov.length);\n            nv[ov.length] = value;\n            result.put(name, nv);\n        }\n    }\n    \n    /**\n     * Convert an array of the form:\n     * \n     *    a1 v1 a2 v2 a2 v3\n     *    \n     * to a map of the form:\n     * \n     *    a1 -> v1\n     *    a2 -> [v2, v3]\n     */\n    public static Map<String, Object> keyValueArrayToMultiMap(String[] args, int offset) {\n        Map<String, Object> attrs = new HashMap<String, Object>();\n        for (int i = offset; i < args.length; i+=2) {\n            String n = args[i];\n            if (i+1 >= args.length)\n                throw new IllegalArgumentException(\"not enough arguments\");\n            String v = args[i+1];\n            addToMultiMap(attrs, n, v);\n        }\n        return attrs;\n    }\n\n    private static final int TERM_WHITESPACE = 1;\n    private static final int TERM_SINGLEQUOTE = 2;\n    private static final int TERM_DBLQUOTE = 3;    \n    \n    /**\n     * open the specified file and return the first line in the file, without the end of line character(s).\n     * @param file\n     * @return\n     * @throws IOException\n     */\n    public static String readSingleLineFromFile(String file) throws IOException {\n        InputStream is = null;\n        try {\n            is = new FileInputStream(file);\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));            \n            return in.readLine();\n        } finally {\n            ByteUtil.closeStream(is);\n        }\n    }\n    \n    /**\n     * read a line from \"in\", using readLine(). A trailing '\\\\' on the line will\n     * be treated as continuation and the next line will be read and appended to the line,\n     * without the \\\\.\n     * @param in\n     * @return complete line or null on end of file.\n     * @throws IOException\n     */\n    public static String readLine(BufferedReader in) throws IOException {\n        String line;\n        StringBuilder sb = null;\n        \n        while ((line = in.readLine()) != null) {\n            if (line.length() == 0) {\n                break;\n            } else if (line.charAt(line.length()-1) == '\\\\') {\n                if (sb == null) sb = new StringBuilder();\n                sb.append(line.substring(0, line.length()-1));\n            } else {\n                break;\n            }\n        }\n        \n        if (line == null) {\n            if (sb == null) {\n                return null;\n            } else {\n                return sb.toString();\n            }\n        } else {\n            if (sb == null) {\n                return line;\n            } else {\n                sb.append(line);\n                return sb.toString();\n            }\n        }\n    }\n    \n    public static List<String> parseSieveStringList(String value) throws ServiceException {\n        List<String> result = new ArrayList<String>();\n        if (value == null) return result;\n        value = value.trim();\n        if (value.length() == 0) return result;\n        int i = 0;\n        boolean inStr = false;\n        boolean inList = false;\n        StringBuilder sb = null;\n        while(i < value.length()) {\n            char ch = value.charAt(i++);\n            if (inStr) {\n                if (ch == '\"') {\n                    result.add(sb.toString());\n                    inStr = false;\n                } else {\n                    if (ch == '\\\\' && i < value.length())\n                        ch = value.charAt(i++);\n                    sb.append(ch);\n                }\n            } else {\n                if (ch == '\"') {\n                    inStr = true;\n                    sb = new StringBuilder();\n                } else if (ch == '[' && !inList) {\n                    inList = true;\n                } else if (ch ==']' && inList) {\n                    inList = false;\n                } else if (!Character.isWhitespace(ch)) {\n                    throw ServiceException.INVALID_REQUEST(\"unable to parse string list: \"+value, null);\n                }\n            }\n        }\n        if (inStr || inList) {\n            throw ServiceException.INVALID_REQUEST(\"unable to parse string list2: \"+value, null);\n        }\n        return result;\n    }\n\n\n    /**\n     * split a line into array of Strings, using a shell-style syntax for tokenizing words.\n     * \n     * @param line\n     * @return\n     */\n    public static String[] parseLine(String line) {\n        ArrayList<String> result = new ArrayList<String>();\n        \n        int i=0;\n        \n        StringBuilder sb = new StringBuilder(32);\n        int term = TERM_WHITESPACE;\n        boolean inStr = false;\n        \n        scan: \n            while (i < line.length()) {\n            char ch = line.charAt(i++);\n            boolean escapedTerm = false;\n            \n            if (ch == '\\\\' && i < line.length()) {\n                ch = line.charAt(i++);\n                switch (ch) {\n                    case '\\\\':\n                        break;\n                    case 'n':\n                        ch = '\\n';\n                        escapedTerm = true;\n                        break;\n                    case 't':\n                        ch = '\\t';\n                        escapedTerm = true;\n                        break;  \n                    case 'r':\n                        ch = '\\r';\n                        escapedTerm = true;\n                        break;                        \n                    case '\\'':\n                        ch = '\\'';\n                        escapedTerm = true;\n                        break;                        \n                    case '\"':\n                        ch = '\"';\n                        escapedTerm = true;\n                        break;\n                    default:\n                        escapedTerm = Character.isWhitespace(ch);\n                        break;\n                }\n            }\n                \n            if (inStr) {\n                if (!escapedTerm && (\n                            (term == TERM_WHITESPACE && Character.isWhitespace(ch)) ||\n                            (term == TERM_SINGLEQUOTE && ch == '\\'') ||\n                            (term == TERM_DBLQUOTE && ch == '\"'))) {\n                    inStr = false;\n                    result.add(sb.toString());\n                    sb = new StringBuilder(32);\n                    term = TERM_WHITESPACE;\n                    continue scan;\n                }\n                sb.append(ch);                \n            } else {\n                if (!escapedTerm) {\n                    switch (ch) {\n                    case '\\'':\n                        term = TERM_SINGLEQUOTE;\n                        inStr = true;\n                        continue scan;\n                    case '\"':\n                        term = TERM_DBLQUOTE;\n                        inStr = true;\n                        continue scan;\n                    default:\n                        if (Character.isWhitespace(ch))\n                            continue scan;\n                        inStr = true;\n                        sb.append(ch);\n                        break;\n                    }\n                } else {\n                    // we had an escaped terminator, start a new string\n                    inStr = true;\n                    sb.append(ch);\n                }\n            }\n        }\n\n        if (sb.length() > 0)\n            result.add(sb.toString());\n        \n        return result.toArray(new String[result.size()]);\n    }\n\n    private static void dump(String line) {\n        String[] result = parseLine(line);\n        System.out.println(\"line: \"+line);\n        for (int i=0; i < result.length; i++)\n            System.out.println(i+\": (\"+result[i]+\")\");\n        System.out.println();\n    }\n    \n    public static void main(String args[]) {\n        dump(\"this is a test\");\n        dump(\"this is 'a nother' test\");\n        dump(\"this is\\\\ test\");\n        dump(\"first Roland last 'Schemers' full 'Roland Schemers'\");\n        dump(\"multi 'Roland\\\\nSchemers'\");\n        dump(\"a\");\n        dump(\"\");\n        dump(\"\\\\  \\\\ \");\n        dump(\"backslash \\\\\\\\\");\n        dump(\"backslash \\\\f\");\n        dump(\"a           b\");\n    }\n\n    // A pattern that matches the beginning of a string followed by ${KEY_NAME} followed\n    // by the end.  There are three groups:  the beginning, KEY_NAME and the end.\n    // Pattern.DOTALL is required in case one of the values in the map has a newline\n    // in it.\n    private static Pattern templatePattern =\n        Pattern.compile(\"(.*)\\\\$\\\\{([^\\\\)]+)\\\\}(.*)\", Pattern.DOTALL);\n    \n    /**\n     * Substitutes all occurrences of the specified values into a template.  Keys\n     * for the values are specified in the template as <code>${KEY_NAME}</code>.\n     * @param template the template\n     * @param vars a <code>Map</code> filled with keys and values.  The keys must\n     * be <code>String</code>s. \n     * @return the template with substituted values\n     */\n    public static String fillTemplate(String template, Map vars)\n    {\n        if (template == null) {\n            return null;\n        }\n        \n        String line = template;\n        Matcher matcher = templatePattern.matcher(line);\n        \n        // Substitute multiple variables per line\n        while (matcher.matches()) {\n            String key = matcher.group(2);\n            Object value = vars.get(key);\n            if (value == null) {\n                ZimbraLog.misc.info(\"fillTemplate(): could not find key '\" + key + \"'\");\n                value = \"\";\n            }\n            line = matcher.group(1) + value + matcher.group(3);\n            matcher.reset(line);\n        }\n        return line;\n    }\n    \n    /**\n     * Joins an array of <code>short</code>s, separated by a delimiter.\n     */\n    public static String join(String delimiter, short[] array) {\n        if (array == null) {\n            return null;\n        }\n        \n        StringBuilder buf = new StringBuilder();\n        \n        for (int i = 0; i < array.length; i++) {\n            buf.append(array[i]);\n            if (i + 1 < array.length) {\n                buf.append(delimiter);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Joins an array of objects, separated by a delimiter.\n     */\n    public static String join(String delimiter, Object[] array) {\n        return (array == null ? null : join(delimiter, array, 0, array.length));\n    }\n\n    public static String join(String delimiter, Object[] array, final int start, final int count) {\n        if (array == null)\n            return null;\n\n        StringBuilder buf = new StringBuilder();\n        for (int i = start, end = start + count; i < end; i++) {\n            buf.append(array[i]);\n            if (i + 1 < end)\n                buf.append(delimiter);\n        }\n        return buf.toString();\n    }\n    \n    public static <E> String join(String delimiter, Collection<E> col) {\n        if (col == null) {\n            return null;\n        }\n        Object[] array = new Object[col.size()];\n        col.toArray(array);\n        return join(delimiter, array);\n    }\n    \n    /**\n     * Returns the simple class name (the name after the last dot)\n     * from a fully-qualified class name.  Behavior is the same as\n     * {@link FileUtil#getExtension}. \n     */\n    public static String getSimpleClassName(String className) {\n        return FileUtil.getExtension(className);\n    }\n    \n    /**\n     * Returns the simple class name (the name after the last dot)\n     * for the specified object.\n     */\n    public static String getSimpleClassName(Object o) {\n        if (o == null) {\n            return null;\n        }\n        return FileUtil.getExtension(o.getClass().getName());\n    }\n    \n    /**\n     * Returns <code>true</code> if the secified string is <code>null</code> or its\n     * length is <code>0</code>.\n     */\n    public static boolean isNullOrEmpty(String s) {\n        if (s == null || s.length() == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    private static final String[] JS_CHAR_ENCODINGS = {\n        \"\\\\u0000\", \"\\\\u0001\", \"\\\\u0002\", \"\\\\u0003\", \"\\\\u0004\", \"\\\\u0005\", \"\\\\u0006\", \"\\\\u0007\",\n        \"\\\\b\",     \"\\\\t\",     \"\\\\n\",     \"\\\\u000B\", \"\\\\f\",     \"\\\\r\",     \"\\\\u000E\", \"\\\\u000F\",\n        \"\\\\u0010\", \"\\\\u0011\", \"\\\\u0012\", \"\\\\u0013\", \"\\\\u0014\", \"\\\\u0015\", \"\\\\u0016\", \"\\\\u0017\",\n        \"\\\\u0018\", \"\\\\u0019\", \"\\\\u001A\", \"\\\\u001B\", \"\\\\u001C\", \"\\\\u001D\", \"\\\\u001E\", \"\\\\u001F\"\n    };\n\n    public static String jsEncode(Object obj) {\n        if (obj == null)\n            return \"\";\n        String replacement, str = obj.toString();\n        StringBuilder sb = null;\n        int i, last, length = str.length();\n        for (i = 0, last = -1; i < length; i++) {\n            char c = str.charAt(i);\n            switch (c) {\n                case '\\\\':      replacement = \"\\\\\\\\\";                break;\n                case '\"':       replacement = \"\\\\\\\"\";                break;\n                case '\\u2028':  replacement = \"\\\\u2028\";             break;\n                case '\\u2029':  replacement = \"\\\\u2029\";             break;\n                default:        if (c >= ' ')                        continue;\n                                replacement = JS_CHAR_ENCODINGS[c];  break;\n            }\n            if (sb == null)\n                sb = new StringBuilder(str.substring(0, i));\n            else\n                sb.append(str.substring(last, i));\n            sb.append(replacement);\n            last = i + 1;\n        }\n        return (sb == null ? str : sb.append(str.substring(last, i)).toString());\n    }\n\n    public static String jsEncodeKey(String key) {\n        return '\"' + key + '\"';\n    }\n\n    //\n    // HTML methods\n    //\n    private static final Pattern PAT_AMP = Pattern.compile(\"&\", Pattern.MULTILINE);\n    private static final Pattern PAT_LT = Pattern.compile(\"<\", Pattern.MULTILINE);\n    private static final Pattern PAT_GT = Pattern.compile(\">\", Pattern.MULTILINE);\n    private static final Pattern PAT_DBLQT = Pattern.compile(\"\\\"\", Pattern.MULTILINE);    \n\n    /**\n     * Escapes special characters with their HTML equivalents.\n     */\n    public static String escapeHtml(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, PAT_AMP, \"&amp;\");\n        s = replaceAll(s, PAT_LT, \"&lt;\");\n        s = replaceAll(s, PAT_GT, \"&gt;\");\n        s = replaceAll(s, PAT_DBLQT, \"&quot;\");\n        return s;\n    }\n\n    private static String replaceAll(String text, Pattern pattern, String replace) {\n        Matcher m = pattern.matcher(text);\n        StringBuffer sb = null;\n        while (m.find()) {\n            if (sb == null) sb = new StringBuffer();\n            m.appendReplacement(sb, replace);\n        }\n        if (sb != null) m.appendTail(sb);\n        return sb == null ? text : sb.toString();\n    }\n\n    /**\n     * Determines whether data can be encoded using <tt>requestedCharset</tt>.\n     *  \n     * @param data the data to be encoded\n     * @param requestedCharset the character set\n     * @return <tt>requestedCharset</tt> if encoding is supported, <tt>&quot;utf-8&quot;</tt>\n     * if not, or <tt>&quot;us-ascii&quot;</tt> if data is <tt>null</tt>.\n     */\n    public static String checkCharset(String data, String requestedCharset) {\n        if (data == null)\n            return \"us-ascii\";\n    \n        if (!requestedCharset.equalsIgnoreCase(\"utf-8\")) {\n            try {\n                Charset cset = Charset.forName(requestedCharset);\n                if (cset.canEncode() && cset.newEncoder().canEncode(data))\n                    return requestedCharset;\n            } catch (Exception e) {}\n        }\n        return \"utf-8\";\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-mailbox",
    "commit": "c12b7d1491df52a92f4b90c1d5ed7af5a363eb77",
    "commit_msg": "Bug: 22859\nxss problems in skin resources\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=22859\n\nCopied from Perforce\n Change: 78064",
    "original_file": "StringUtil.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 15,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.dbcp.DelegatingConnection;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbPool.PoolConfig;\n\npublic class SQLite extends Db {\n\n    private Map<Db.Error, String> mErrorCodes;\n    private String cacheSize;\n\n    SQLite() {\n        mErrorCodes = new HashMap<Db.Error, String>(6);\n        mErrorCodes.put(Db.Error.DUPLICATE_ROW, \"column id is not unique\");\n        mErrorCodes.put(Db.Error.NO_SUCH_TABLE, \"no such table\");\n    }\n    \n    @Override boolean supportsCapability(Db.Capability capability) {\n        switch (capability) {\n            case AVOID_OR_IN_WHERE_CLAUSE:   return false;\n            case BITWISE_OPERATIONS:         return true;\n            case BOOLEAN_DATATYPE:           return true;\n            case BROKEN_IN_CLAUSE:           return false;\n            case CASE_SENSITIVE_COMPARISON:  return true;\n            case CAST_AS_BIGINT:             return false;\n            case CLOB_COMPARISON:            return true;\n            case DISABLE_CONSTRAINT_CHECK:   return false;\n            case FILE_PER_DATABASE:          return true;\n            case FORCE_INDEX_EVEN_IF_NO_SORT:  return false;\n            case LIMIT_CLAUSE:               return true;\n            case MULTITABLE_UPDATE:          return false;\n            case ON_DUPLICATE_KEY:           return false;\n            case ON_UPDATE_CASCADE:          return false;\n            case READ_COMMITTED_ISOLATION:   return false;\n            case REPLACE_INTO:               return true;\n            case REQUEST_UTF8_UNICODE_COLLATION:  return false;\n            case ROW_LEVEL_LOCKING:          return false;\n            case UNIQUE_NAME_INDEX:          return false;\n        }\n        return false;\n    }\n\n    @Override boolean compareError(SQLException e, Error error) {\n        // XXX: the SQLite JDBC driver doesn't yet expose SQLite error codes, which sucks\n        String code = mErrorCodes.get(error);\n        return code != null && e.getMessage().contains(code);\n    }\n\n    @Override String forceIndexClause(String index) {\n        // don't think we can direct the sqlite optimizer...\n        return \"\";\n    }\n\n    @Override String getIFNULLClause(String expr1, String expr2) {\n        return \"IFNULL(\" + expr1 + \", \" + expr2 + \")\";\n    }\n\n    @Override PoolConfig getPoolConfig() {\n        return new SQLiteConfig();\n    }\n\n\n    @Override void startup(org.apache.commons.dbcp.PoolingDataSource pool, int poolSize) throws SQLException {\n        \n        cacheSize = LC.get(\"sqlite_cache_size\");\n        ZimbraLog.dbconn.info(\"sqlite driver running with \" + cacheSize + \" page cache\");\n        super.startup(pool, poolSize);\n    }\n\n    void postCreate(java.sql.Connection conn) throws SQLException {\n        try {\n            conn.setAutoCommit(true);\n            if (cacheSize != null)\n                pragma(conn, \"cache_size\", cacheSize);\n            pragma(conn, \"synchronous\", \"NORMAL\");\n        } finally {\n            conn.setAutoCommit(false);\n        }\n    }\n\n    private void pragma(java.sql.Connection conn, String key, String value) throws SQLException {\n        PreparedStatement stmt = null;\n        try {\n            (stmt = conn.prepareStatement(\"PRAGMA \" + key + \" = \" + value)).execute();\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n    private static final int DEFAULT_CONNECTION_POOL_SIZE = 12;\n\n    private static final int MAX_ATTACHED_DATABASES = readConfigInt(\"sqlite_max_attached_databases\", \"max # of attached databases\", 7);\n\n    private static final HashMap<java.sql.Connection, LinkedHashMap<String, String>> sAttachedDatabases =\n            new HashMap<java.sql.Connection, LinkedHashMap<String, String>>(DEFAULT_CONNECTION_POOL_SIZE);\n\n    private LinkedHashMap<String, String> getAttachedDatabases(Connection conn) {\n        return sAttachedDatabases.get(getInnermostConnection(conn.getConnection()));\n    }\n\n    private java.sql.Connection getInnermostConnection(java.sql.Connection conn) {\n        java.sql.Connection retVal = null;\n        if (conn instanceof DebugConnection)\n            retVal = ((DebugConnection) conn).getConnection();\n        if (conn instanceof DelegatingConnection)\n            retVal = ((DelegatingConnection) conn).getInnermostDelegate();\n        return retVal == null ? conn : retVal;\n    }\n\n    @Override public void registerDatabaseInterest(Connection conn, String dbname) throws SQLException, ServiceException {\n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null && attachedDBs.containsKey(dbname))\n            return;\n\n        // if we're using more databases than we're allowed to, detach the least recently used\n        if (attachedDBs != null && attachedDBs.size() >= MAX_ATTACHED_DATABASES) {\n            for (Iterator<String> it = attachedDBs.keySet().iterator(); attachedDBs.size() >= MAX_ATTACHED_DATABASES && it.hasNext(); ) {\n                String name = it.next();\n                \n                if (!name.equals(\"zimbra\") && detachDatabase(conn, name))\n                    it.remove();\n            }\n        }\n        attachDatabase(conn, dbname);\n    }\n\n    void attachDatabase(Connection conn, String dbname) throws SQLException, ServiceException {\n        PreparedStatement stmt = null;\n        \n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"ATTACH DATABASE \\\"\" + getDatabaseFilename(dbname) + \"\\\" AS \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n        } catch (SQLException e) {\n            if (!\"database is already attached\".equals(e.getMessage()))\n                return;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n        \n        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n        if (attachedDBs != null) {\n            attachedDBs.put(dbname, null);\n        } else {\n            attachedDBs = new LinkedHashMap<String, String>(MAX_ATTACHED_DATABASES * 3 / 2, (float) 0.75, true);\n            attachedDBs.put(dbname, null);\n            sAttachedDatabases.put(getInnermostConnection(conn.getConnection()), attachedDBs);\n        }\n    }\n\n    private boolean detachDatabase(Connection conn, String dbname) {\n        PreparedStatement stmt = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            (stmt = conn.prepareStatement(\"DETACH DATABASE \" + dbname)).execute();\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return true;\n        } catch (SQLException e) {\n            ZimbraLog.dbconn.warn(\"database overflow autoclose failed for DB \" + dbname, e);\n            return false;\n        } finally {\n            DbPool.quietCloseStatement(stmt);\n        }\n    }\n\n//    @Override void preClose(Connection conn) {\n//        LinkedHashMap<String, String> attachedDBs = getAttachedDatabases(conn);\n//        if (attachedDBs == null)\n//            return;\n//\n//        // simplest solution it to just detach all the active databases every time we close the connection\n//        for (Iterator<String> it = attachedDBs.keySet().iterator(); it.hasNext(); ) {\n//            if (detachDatabase(conn, it.next()))\n//                it.remove();\n//        }\n//    }\n\n    @Override public boolean databaseExists(Connection conn, String dbname) throws ServiceException {\n        if (!new File(getDatabaseFilename(dbname)).exists())\n            return false;\n\n        // since it's so easy to end up with an empty SQLite database, make\n        // sure that at least one table exists \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            boolean autocommit = conn.getConnection().getAutoCommit();\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(true);\n\n            registerDatabaseInterest(conn, dbname);\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" +\n                (dbname.equals(\"zimbra\") ? \"\" : dbname + \".\") +\n                \"sqlite_master WHERE type='table'\");\n            rs = stmt.executeQuery();\n            boolean complete = rs.next() ? (rs.getInt(1) >= 1) : false;\n\n            if (!autocommit)\n                conn.getConnection().setAutoCommit(autocommit);\n            return complete;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"sqlite error\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    @Override void deleteDatabaseFile(String dbname) {\n        assert(dbname != null && !dbname.trim().equals(\"\"));\n        ZimbraLog.dbconn.info(\"deleting database file for DB '\" + dbname + \"'\");\n        new File(getDatabaseFilename(dbname)).delete();\n    }\n\n\n    public String getDatabaseFilename(String dbname) {\n        return LC.zimbra_home.value() + File.separator + \"sqlite\" + File.separator + dbname + \".db\";\n    }\n\n    final class SQLiteConfig extends DbPool.PoolConfig {\n        SQLiteConfig() {\n            mDriverClassName = \"org.sqlite.JDBC\";\n            mPoolSize = DEFAULT_CONNECTION_POOL_SIZE;\n            mRootUrl = null;\n            mConnectionUrl = \"jdbc:sqlite:\" + getDatabaseFilename(\"zimbra\"); \n            mLoggerUrl = null;\n            mSupportsStatsCallback = false;\n            mDatabaseProperties = getSQLiteProperties();\n\n            // override pool size if specified in prefs\n            mPoolSize = readConfigInt(\"sqlite_pool_size\", \"connection pool size\", DEFAULT_CONNECTION_POOL_SIZE);\n        }\n\n        private Properties getSQLiteProperties() {\n            Properties props = new Properties();\n            props.setProperty(\"shared_cache\", \"true\");\n            return props;\n        }\n    }\n\n    static int readConfigInt(final String keyname, final String description, final int defaultvalue) {\n        int value = defaultvalue;\n        try {\n            String configvalue = LC.get(keyname);\n            if (configvalue != null && !configvalue.trim().equals(\"\"))\n                value = Math.max(1, Integer.parseInt(configvalue));\n        } catch (NumberFormatException nfe) {\n            ZimbraLog.dbconn.warn(\"exception parsing '\" + keyname  + \"' config; defaulting limit to \" + defaultvalue, nfe);\n        }\n        ZimbraLog.dbconn.info(\"setting \" + description + \" to \" + value);\n        return value;\n    }\n\n\n    @Override public void flushToDisk() {\n        // not really implemented\n    }\n\n    @Override public String toString() {\n        return \"SQLite\";\n    }\n\n    public static void main(String args[]) {\n        // command line argument parsing\n        Options options = new Options();\n        CommandLine cl = Versions.parseCmdlineArgs(args, options);\n\n        String outputDir = cl.getOptionValue(\"o\");\n        File outFile = new File(outputDir, \"versions-init.sql\");\n        outFile.delete();\n\n        try {\n            String redoVer = com.zimbra.cs.redolog.Version.latest().toString();\n            String outStr = \"-- AUTO-GENERATED .SQL FILE - Generated by the SQLite versions tool\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('db.version', '\" + Versions.DB_VERSION + \"', 'db schema version');\\n\" + \n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('index.version', '\" + Versions.INDEX_VERSION + \"', 'index version');\\n\" +\n                \"INSERT INTO config(name, value, description) VALUES\\n\" +\n                \"\\t('redolog.version', '\" + redoVer + \"', 'redolog version');\\n\";\n\n            Writer output = new BufferedWriter(new FileWriter(outFile));\n            output.write(outStr);\n            output.close();\n        } catch (IOException e){\n            System.out.println(\"ERROR - caught exception at\\n\");\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "1a8c66faecb2a2159f7747b5f9691f9759ce896f",
    "commit_msg": "(split)bug: none use proper LC var for sqlite_cache_size\n\nCopied from Perforce\n Change: 215504",
    "original_file": "SQLite.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 16,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.milter;\n\nimport org.apache.mina.common.ByteBuffer;\nimport org.apache.mina.common.IoSession;\nimport org.apache.mina.filter.codec.CumulativeProtocolDecoder;\nimport org.apache.mina.filter.codec.ProtocolDecoderOutput;\n\nimport com.zimbra.cs.mina.MinaStats;\n\npublic class MinaMilterDecoder extends CumulativeProtocolDecoder {\n    private final MinaStats stats;\n    \n    MinaMilterDecoder(MinaStats stats) {\n        this.stats = stats;\n    }\n    \n    @Override public boolean doDecode(IoSession session, ByteBuffer in, ProtocolDecoderOutput out) {\n        if (!in.prefixedDataAvailable(4))\n            return false;\n        \n        int len = in.getInt();\n        byte cmd = in.get();\n        byte[] data = null;\n        if (len > 1) {\n            data = new byte[len - 1];\n            in.get(data);\n        }\n        MilterPacket packet = new MilterPacket(len, cmd, data);\n        out.write(packet);\n        \n        if (stats != null) {\n            stats.receivedBytes.addAndGet(len + 4);\n        }\n        return true;\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-mailbox",
    "commit": "dd4c72510f309a16282b22d66a497d3e9fa9fc16",
    "commit_msg": "Integrating from HELIX..\n\nChange 338524 by vmahajan@vmahajan_macbook on 2011/11/10 08:47:54\n\n        bug: 67021 - XSS vulnerability for MIME - *{width:ex\\pression( \n        eval(alert(\"XSS4\")));}\n\n        - Defanger now removes all functions (like url(), expression()) from \n        style value. Specific regular expressions are not very useful \n        because, e.g. expression function name could be encoded as \n        \"\\0065\\0078pression\", or \"&#x5c;0065&#x5c;0078pression\", or \n        expre\\ss\\ion, etc, and each of these are allowed by IE.\n        - Enabled defanger unit tests in HELIX branch.\n        - Added a new test.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=67021\n\nCopied from Perforce\n Change: 338532",
    "original_file": "NioMilterDecoder.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 17,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2009, 2010, 2011 Zimbra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.cs.upgrade;\n\nimport com.google.common.base.Strings;\nimport com.zimbra.cs.db.Db;\nimport com.zimbra.cs.db.DbMailItem;\nimport com.zimbra.cs.db.DbMailbox;\nimport com.zimbra.cs.db.DbPool;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.mailbox.*;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.cs.service.util.SyncToken;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\nimport java.util.HashMap;\n\n/**\n * Utility class to upgrade mailbox.\n *\n * @author Andy Clark\n */\npublic final class MailboxUpgrade {\n\n    private static final Map<Long,Byte> UPGRADE_TO_1_7_COLORS = new HashMap<Long,Byte>();\n    private static final Map<Long,Byte> UPGRADE_TO_1_8_COLORS = UPGRADE_TO_1_7_COLORS;\n\n    static {\n        Map<Long,Byte> map = UPGRADE_TO_1_7_COLORS;\n        // common colors\n        map.put(0x1000000L,(byte)0); // none\n        // original RGB colors\n        map.put(0x10000ffL,(byte)1); // blue\n        map.put(0x1008284L,(byte)2); // cyan\n        map.put(0x1848284L,(byte)8); // gray\n        map.put(0x1008200L,(byte)3); // green\n        map.put(0x1ff8000L,(byte)9); // orange\n        map.put(0x1840084L,(byte)4); // purple\n        map.put(0x1ff0084L,(byte)7); // pink\n        map.put(0x1ff0000L,(byte)5); // red\n        map.put(0x1848200L,(byte)6); // yellow\n        // newer RGB colors\n        map.put(0x19EB6F5L,(byte)1); // blue\n        map.put(0x1A4E6E6L,(byte)2); // cyan\n        map.put(0x1D3D3D3L,(byte)8); // gray\n        map.put(0x197C8B1L,(byte)3); // green\n        map.put(0x1FDBC55L,(byte)9); // orange\n        map.put(0x1FE9BD3L,(byte)7); // pink\n        map.put(0x1BA86E5L,(byte)4); // purple\n        map.put(0x1FC9696L,(byte)5); // red\n        map.put(0x1FFF6B3L,(byte)6); // yellow\n        // newest RGB colors\n        map.put(0x10252d4L,(byte)1); // blue\n        map.put(0x1008284L,(byte)2); // cyan\n        map.put(0x1848284L,(byte)8); // gray\n        map.put(0x12ca10bL,(byte)3); // green\n        map.put(0x1f57802L,(byte)9); // orange\n        map.put(0x1b027aeL,(byte)7); // pink\n        map.put(0x1492ba1L,(byte)4); // purple\n        map.put(0x1e51717L,(byte)5); // red\n        map.put(0x1848200L,(byte)6); // yellow\n    }\n\n    /** This class can not be instantiated. */\n    private MailboxUpgrade() {}\n\n    /**\n     * bug 41893: revert folder colors back to mapped value.\n     */\n    public static void upgradeTo1_7(Mailbox mbox) throws ServiceException {\n        OperationContext octxt = new OperationContext(mbox);\n        for (Folder folder : mbox.getFolderList(octxt, SortBy.NONE)) {\n            MailItem.Color color = folder.getRgbColor();\n            if (!color.hasMapping()) {\n                Byte value = UPGRADE_TO_1_7_COLORS.get(color.getValue());\n                if (value != null) {\n                    MailItem.Color newcolor = new MailItem.Color(value);\n                    mbox.setColor(octxt, new int[] { folder.getId() }, folder.getType(), newcolor);\n                }\n            }\n        }\n    }\n\n    /**\n     * bug 41850: revert tag colors back to mapped value.\n     */\n    public static void upgradeTo1_8(Mailbox mbox) throws ServiceException {\n        OperationContext octxt = new OperationContext(mbox);\n        for (Tag tag : mbox.getTagList(octxt)) {\n            MailItem.Color color = tag.getRgbColor();\n            if (!color.hasMapping()) {\n                Byte value = UPGRADE_TO_1_8_COLORS.get(color.getValue());\n                if (value != null) {\n                    MailItem.Color newcolor = new MailItem.Color(value);\n                    mbox.setColor(octxt, new int[] { tag.getId() }, tag.getType(), newcolor);\n                }\n            }\n        }\n    }\n\n    public static void upgradeTo2_0(Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n        migrateHighestIndexed(mbox);\n    }\n\n    private static void migrateHighestIndexed(Mailbox mbox) throws ServiceException {\n        DbConnection conn = DbPool.getConnection(mbox);\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            // fetch highest_indexed\n            String highestIndexed = null;\n            stmt = conn.prepareStatement(\"SELECT highest_indexed FROM \" +\n                    DbMailbox.qualifyZimbraTableName(mbox, \"mailbox\") + \" WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            rs = stmt.executeQuery();\n            if (rs.next()) {\n                highestIndexed = rs.getString(1);\n            }\n            rs.close();\n            stmt.close();\n\n            if (Strings.isNullOrEmpty(highestIndexed)) {\n                return;\n            }\n\n            SyncToken token;\n            try {\n                token = new SyncToken(highestIndexed);\n            } catch (ServiceException e) {\n                return;\n            }\n\n            // update index_id where mod_content/mod_metadata > highest_indexed\n            stmt = conn.prepareStatement(\"UPDATE \" + DbMailItem.getMailItemTableName(mbox) +\n                    \" SET index_id = 0 WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND +\n                    \"mod_content > ? AND mod_metadata > ? AND index_id IS NOT NULL\");\n            int pos = DbMailItem.setMailboxId(stmt, mbox, 1);\n            stmt.setInt(pos++, token.getChangeId());\n            stmt.setInt(pos++, token.getChangeId());\n            stmt.executeUpdate();\n            stmt.close();\n\n            // clear highest_indexed\n            stmt = conn.prepareStatement(\"UPDATE \" + DbMailbox.qualifyZimbraTableName(mbox, \"mailbox\") +\n                    \" SET highest_indexed = NULL WHERE id = ?\");\n            stmt.setInt(1, mbox.getId());\n            stmt.executeUpdate();\n            stmt.close();\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw ServiceException.FAILURE(\"Failed to migrate highest_indexed\", e);\n        } finally {\n            conn.closeQuietly();\n        }\n    }\n\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "MailboxUpgrade.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 18,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.LogFactory;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbSearchConstraints.NumericRange;\nimport com.zimbra.cs.db.DbSearchConstraints.StringRange;\nimport com.zimbra.cs.db.DbSearchConstraintsNode.NodeType;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.index.SortBy.SortCriterion;\nimport com.zimbra.cs.index.SortBy.SortDirection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Tag;\n\npublic class DbSearch {\n\n    private static Log sLog = LogFactory.getLog(DbSearch.class);\n\n    public static final class SearchResult {\n        public int    id;\n        public String indexId;\n        public byte   type;\n        public Object sortkey;\n        public Object extraData;\n\n        public enum ExtraData { NONE, MAIL_ITEM, IMAP_MSG, MODSEQ, PARENT, MODCONTENT };\n\n        public static class SizeEstimate {\n            public SizeEstimate() {}\n            public SizeEstimate(int initialval) { mSizeEstimate = initialval; }\n            public int mSizeEstimate;\n        }\n\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort) throws SQLException {\n            return createResult(rs, sort, ExtraData.NONE);\n        }\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort, ExtraData extra) throws SQLException {\n            SearchResult result = new SearchResult();\n            result.id      = rs.getInt(COLUMN_ID);\n            result.indexId = rs.getString(COLUMN_INDEXID);\n            result.type    = rs.getByte(COLUMN_TYPE);\n            switch (sort.getCriterion()) {\n                case SUBJECT:\n                case SENDER:\n                case NAME:\n                case NAME_NATURAL_ORDER:\n                    result.sortkey = rs.getString(COLUMN_SORTKEY);\n                    break;\n                case SIZE:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY));\n                    break;\n                case NONE:\n                    // note that there's no sort column in the result set for SORT_NONE\n                    break;\n                default:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY) * 1000L);\n                    break;\n            }\n\n            int offset = sort.getCriterion() == SortCriterion.NONE ? COLUMN_SORTKEY - 1 : COLUMN_SORTKEY;\n            if (extra == ExtraData.MAIL_ITEM) {\n                // note that there's no sort column in the result set for SORT_NONE\n                result.extraData = DbMailItem.constructItem(rs, offset);\n            } else if (extra == ExtraData.IMAP_MSG) {\n                int flags = rs.getBoolean(offset + 2) ? Flag.BITMASK_UNREAD | rs.getInt(offset + 3) : rs.getInt(offset + 3);\n                result.extraData = new ImapMessage(result.id, result.type, rs.getInt(offset + 1), flags, rs.getLong(offset + 4));\n            } else if (extra == ExtraData.MODSEQ || extra == ExtraData.PARENT || extra==ExtraData.MODCONTENT) {\n                int value = rs.getInt(offset + 1);\n                result.extraData = rs.wasNull() ? -1 : value;\n            }\n            return result;\n        }\n\n        @Override public String toString() {\n            return sortkey + \" => (\" + id + \",\" + type + \")\";\n        }\n\n        @Override public int hashCode() {\n            return id;\n        }\n\n        @Override public boolean equals(Object obj) {\n            SearchResult other = (SearchResult) obj;\n            return other.id == id;\n        }\n        \n        private static class SearchResultComparator implements Comparator<SearchResult> {\n            private SortBy mSort;\n            SearchResultComparator(SortBy sort)  { mSort = sort; }\n\n            public int compare(SearchResult o1, SearchResult o2) {\n                switch (mSort.getCriterion()) {\n                    case SIZE:\n                    case DATE:\n                        long date1 = (Long) o1.sortkey;\n                        long date2 = (Long) o2.sortkey;\n                        if (date1 != date2) {\n                            long diff;\n                            if (mSort.getDirection() == SortDirection.DESCENDING) {\n                                diff = date2 - date1;\n                            } else {\n                                diff = date1 - date2;\n                            }\n                            return (diff > 0) ? 1 : -1;\n                        }\n                        // fall through to ID-based comparison below!\n                        break;\n                    case NONE:\n                        break;\n                    default:\n                        throw new UnsupportedOperationException(\"SearchResultComparator not implemented \" +\n                                                                \" for anything except for DATE and SIZE right now. \" +\n                                                                \" Feel free to fix it!\"); \n                }\n                if (mSort.getDirection() == SortDirection.DESCENDING) {\n                    return o2.id - o1.id;\n                } else {\n                    return o1.id - o2.id;\n                }\n            }\n        }\n        \n        public static Comparator<SearchResult> getComparator(SortBy sort) {\n            return new SearchResultComparator(sort);\n        }\n    }\n\n    // alias the sort column b/c of ambiguity problems (the sort column is included twice in the \n    // result set, and MySQL chokes on the ORDER BY when we do a UNION query (doesn't know\n    // which 2 of the 4 sort columns are the \"right\" ones to use)\n    public static final String SORT_COLUMN_ALIAS = \"sortcol\";\n    \n    /**\n     * @param fieldName\n     * @return TRUE if this field is case-sensitive for search/sort -- ie do we need to\n     *         do an UPPER(fieldName) on it in places?\n     */\n    private static boolean isCaseSensitiveField(String fieldName) {\n        // we need to handle things like \"mi.sender\" for the sender column, etc\n        // so look for the last . in the fieldname, return the string after that.\n        String colNameAfterPeriod; \n        int periodOffset = fieldName.lastIndexOf('.');\n        if (periodOffset <= 0 && periodOffset < (fieldName.length()+1))\n            colNameAfterPeriod = fieldName;\n        else\n            colNameAfterPeriod = fieldName.substring(periodOffset+1);\n        \n        return (colNameAfterPeriod.equals(\"sender\") || \n                        colNameAfterPeriod.equals(\"subject\") ||\n                        colNameAfterPeriod.equals(\"name\")); \n    }\n\n    private static String sortField(SortBy sort, boolean useAlias, boolean includeCollation) {\n        String str;\n        boolean stringVal = false;\n        switch (sort.getCriterion()) {\n            case SENDER:   str = \"mi.sender\";   stringVal = true;  break;\n            case SUBJECT:  str = \"mi.subject\";  stringVal = true;  break;\n            case NAME_NATURAL_ORDER:\n            case NAME:     str = \"mi.name\";     stringVal = true;  break;\n            case ID:       str = \"mi.id\";    break;\n            case SIZE:     str = \"mi.size\";  break;\n            case DATE:\n            default:       str = \"mi.date\";  break; \n            case NONE:     return null;\n        }\n        \n        if (useAlias) {\n            str = SORT_COLUMN_ALIAS; // still need the stringVal setting above!\n        } else {\n            if (stringVal && Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) \n                str = \"UPPER(\" + str + \")\";\n        }\n\n        // tim: back this out for now, but leave code stub here until I deal with it\n        // see bugs 22665, 36579\n        //if (Db.supports(Db.Capability.REQUEST_UTF8_UNICODE_COLLATION) && stringVal && includeCollation) \n        //    str += \" COLLATE utf8_unicode_ci\";\n\n        return str;\n    }\n    \n    /**\n     * generate a column-reference for the sort-by column.  This column reference\n     * goes at the beginning of the SELECT statement (the ORDER BY part is generated\n     * by sortQuery() below)\n     */\n    static String sortKey(SortBy sort) {\n        String field = sortField(sort, false, false);\n        // note that there's no sort column in the result set for SORT_NONE\n        if (field == null)\n            return \"\";\n        return \", \" + field + \" AS \" + SORT_COLUMN_ALIAS;\n    }\n\n    static String sortQuery(SortBy sort) {\n        return sortQuery(sort, false);\n    }\n\n    /**\n     * Generate the ORDER BY part that goes at the end of the select\n     */\n    static String sortQuery(SortBy sort, boolean useAlias) {\n        // note that there's no need for an ORDER BY clause for SORT_NONE\n        if (sort.getCriterion() == SortCriterion.NONE)\n            return \"\";\n\n        StringBuilder statement = new StringBuilder(\" ORDER BY \");\n        statement.append(sortField(sort, useAlias, true));\n        if (sort.getDirection() == SortDirection.DESCENDING)\n            statement.append(\" DESC\");\n        return statement.toString();\n    }\n\n\n    public static int countResults(Connection conn, DbSearchConstraintsNode node, Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // Assemble the search query\n        StringBuilder statement = new StringBuilder(\"SELECT count(*) \");\n        statement.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \" mi\"));\n        statement.append(\" WHERE \").append(DbMailItem.IN_THIS_MAILBOX_AND);\n        int num = DebugConfig.disableMailboxGroups ? 0 : 1;\n        \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            num += encodeConstraint(mbox, node, null, false, statement, conn);\n\n            stmt = conn.prepareStatement(statement.toString());\n            int pos = 1;\n            pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n            pos = setSearchVars(stmt, node, pos, null, false);\n\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: \" + statement);\n\n            assert(pos == num + 1); \n            rs = stmt.executeQuery();\n            rs.next();\n            return rs.getInt(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // Indexes on mail_item table\n    private static final String MI_I_MBOX_FOLDER_DATE = \"i_folder_id_date\";\n//    private static final String MI_I_MBOX_ID_PKEY     = \"PRIMARY\";\n    private static final String MI_I_MBOX_PARENT      = \"i_parent_id\";\n    private static final String MI_I_MBOX_INDEX       = \"i_index_id\";\n//    private static final String MI_I_MBOX_DATE        = \"i_date\";\n//    private static final String MI_I_MBOX_TAGS_DATE   = \"i_tags_date\";\n//    private static final String MI_I_MBOX_FLAGS_DATE  = \"i_flags_date\";\n//    private static final String MI_I_MBOX_TYPE        = \"i_type\";\n//    private static final String MI_I_MBOX_UNREAD      = \"i_unread\";\n//    private static final String MI_I_MBOX_MODMETADATA = \"i_mod_metadata\";\n//    private static final String MI_I_MBOX_FOLDER_NAME = \"i_name_folder_id\";\n\n    private static final String NO_HINT = \"\";\n\n    private static String getForceIndexClause(DbSearchConstraintsNode node, SortBy sort, boolean hasLimit) {\n        if (LC.search_disable_database_hints.booleanValue())\n            return NO_HINT;\n\n        if (!Db.supports(Db.Capability.FORCE_INDEX_EVEN_IF_NO_SORT) && sort.getCriterion() == SortCriterion.NONE)\n            return NO_HINT;\n        \n        String index = null;\n\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        DbSearchConstraints constraints = node.getSearchConstraints();\n        if (ntype == DbSearchConstraintsNode.NodeType.LEAF) {\n            if (!constraints.itemIds.isEmpty()) {\n                return \"\";\n            } else if (constraints.convId > 0) {\n                index = MI_I_MBOX_PARENT;\n            } else if (!constraints.indexIds.isEmpty()) {\n                index = MI_I_MBOX_INDEX;\n            } else if (sort.getCriterion() == SortCriterion.DATE && hasLimit) {\n                // Whenever we learn a new case of mysql choosing wrong index, add a case here.\n                if (constraints.isSimpleSingleFolderMessageQuery()) {\n                    // Optimization for folder query\n                    //\n                    // If looking at a single folder and sorting by date with a limit,\n                    // force the use of i_folder_id_date index.  Typical example of\n                    // such a query is the default \"in:Inbox\" search.\n                    index = MI_I_MBOX_FOLDER_DATE;\n                }\n            }\n        }\n\n        return Db.forceIndex(index);\n    }\n\n    // put these into constants so that people can easily tell what is dependent on the positons\n    private static final int COLUMN_ID      = 1;\n    private static final int COLUMN_INDEXID = 2;\n    private static final int COLUMN_TYPE    = 3;\n    private static final int COLUMN_SORTKEY = 4;\n\n    private static final String encodeSelect(Mailbox mbox, SortBy sort, SearchResult.ExtraData extra,\n                                             boolean includeCalTable, DbSearchConstraintsNode node,\n                                             boolean validLIMIT) {\n        /*\n         * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi [, appointment AS ap]\n         *    [FORCE INDEX (...)]\n         *    WHERE mi.mailboxid=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND\n         * \n         *  If you change the first for parameters, you must change the COLUMN_* values above!\n         */\n        StringBuilder select = new StringBuilder(\"SELECT mi.id, mi.index_id, mi.type\").append(sortKey(sort));\n        if (extra == SearchResult.ExtraData.MAIL_ITEM)\n            select.append(\", \" + DbMailItem.DB_FIELDS);\n        else if (extra == SearchResult.ExtraData.IMAP_MSG)\n            select.append(\", mi.imap_id, mi.unread, mi.flags, mi.tags\");\n        else if (extra == SearchResult.ExtraData.MODSEQ)\n            select.append(\", mi.mod_metadata\");\n        else if (extra == SearchResult.ExtraData.PARENT)\n            select.append(\", mi.parent_id\");\n        else if (extra == SearchResult.ExtraData.MODCONTENT)\n            select.append(\", mi.mod_content\");\n\n        select.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \"mi\"));\n        if (includeCalTable) \n            select.append(\", \").append(DbMailItem.getCalendarItemTableName(mbox, \"ap\"));\n        \n        /*\n         * FORCE INDEX (...)\n         */\n        if (!includeCalTable) // can't force index when selecting from two tables?\n            select.append(getForceIndexClause(node, sort, validLIMIT));\n        \n        /*\n         *  WHERE mi.mailboxId=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND \"\n         */\n        select.append(\" WHERE \");\n        select.append(DbMailItem.getInThisMailboxAnd(mbox.getId(), \"mi\", includeCalTable ? \"ap\" : null));\n        if (includeCalTable)\n            select.append(\" mi.id = ap.item_id AND \");\n        \n        return select.toString();\n    }\n    \n    /**\n     * @param mbox\n     * @param node\n     * @param calTypes\n     * @param inCalTable\n     * @param statement\n     * @param conn\n     * @return Number of constraints encoded \n     * @throws ServiceException\n     */\n    private static final int encodeConstraint(Mailbox mbox, DbSearchConstraintsNode node,\n        byte[] calTypes, boolean inCalTable, StringBuilder statement, Connection conn) \n    throws ServiceException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        int num = 0;\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            boolean first = true;\n            boolean and = ntype == DbSearchConstraintsNode.NodeType.AND;\n            statement.append('(');\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (!first)\n                    statement.append(and ? \" AND \" : \" OR \");\n                num += encodeConstraint(mbox, subnode, calTypes, inCalTable, statement, conn);\n                first = false;\n            }\n            statement.append(\") \");\n            return num;\n        }\n        \n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        c.checkDates();\n        \n        // if there are no possible matches, short-circuit here...\n        if (c.automaticEmptySet()) {\n            encodeBooleanValue(statement, false); \n            return num;\n        }\n        \n        statement.append('(');\n\n        // special-case this one, since there can't be a leading AND here...\n        if (ListUtil.isEmpty(c.types)) {\n            statement.append(\"type NOT IN \" + DbMailItem.NON_SEARCHABLE_TYPES);\n        } else {\n            statement.append(DbUtil.whereIn(\"type\", true, c.types.size()));\n            num += c.types.size();\n        }\n        \n        num += encode(statement, \"mi.type\", false, c.excludeTypes);\n        num += encode(statement, \"mi.type\", inCalTable, calTypes);\n\n        // Determine the set of matching tags\n        TagConstraints tc = TagConstraints.getTagContraints(mbox, c, conn);\n        if (tc.noMatches)\n            encodeBooleanValue(statement, false);\n\n        // if hasTags is NULL then nothing\n        // if hasTags is TRUE then !=0\n        // if hasTags is FALSE then = 0\n        if (c.hasTags != null) {\n            if (c.hasTags.booleanValue())\n                statement.append(\" AND mi.tags != 0\");\n            else\n                statement.append(\" AND mi.tags = 0\");\n        }\n        \n        num += encode(statement, \"mi.tags\", true, tc.searchTagsets);\n        num += encode(statement, \"mi.flags\", true, tc.searchFlagsets);\n        num += encode(statement, \"unread\", true, tc.unread);\n        num += encode(statement, \"mi.folder_id\", true, c.folders);\n        num += encode(statement, \"mi.folder_id\", false, c.excludeFolders);\n        if (c.convId > 0)\n            num += encode(statement, \"mi.parent_id\", true);\n        else\n            num += encode(statement, \"mi.parent_id\", false, c.prohibitedConvIds);\n        num += encode(statement, \"mi.id\", true, c.itemIds);\n        num += encode(statement, \"mi.id\", false, c.prohibitedItemIds);\n        num += encode(statement, \"mi.index_id\", true, c.indexIds);\n        num += encodeRangeWithMinimum(statement, \"mi.date\", c.dates, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_metadata\", c.modified, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_content\", c.modifiedContent, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.size\", c.sizes, 0);\n        num += encodeRange(statement, \"mi.subject\", c.subjectRanges);\n        num += encodeRange(statement, \"mi.sender\", c.senderRanges);\n        \n        Boolean isSoloPart = node.getSearchConstraints().getIsSoloPart();\n        if (isSoloPart != null) {\n            if (isSoloPart.booleanValue()) {\n                statement.append(\" AND mi.parent_id is NULL \");\n            } else {\n                statement.append(\" AND mi.parent_id is NOT NULL \");\n            }\n        }\n        \n        if (inCalTable) {\n            num += encodeRangeWithMinimum(statement, \"ap.start_time\", c.calStartDates, 1);\n            num += encodeRangeWithMinimum(statement, \"ap.end_time\", c.calEndDates, 1);\n        }\n\n        statement.append(')');\n        \n        return num;\n    }\n    \n    /**\n     * @return TRUE if some part of this query has a non-appointment select (ie 'type not in (11,15)' non-null \n     */\n    private static final boolean hasMailItemOnlyConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasMailItemOnlyConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasNonAppointmentTypes();\n    }\n    \n    /**\n     * @return TRUE if this constraint needs to do a join with the Appointment table in order to be evaluated\n     */\n    private static final boolean hasAppointmentTableConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasAppointmentTableConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasAppointmentTableConstraints();\n    }\n    \n    \n    static final byte[] APPOINTMENT_TABLE_TYPES = new byte[] { MailItem.TYPE_APPOINTMENT, MailItem.TYPE_TASK };\n\n    public static List<SearchResult> search(List<SearchResult> result, Connection conn, DbSearchConstraints c,\n                                            Mailbox mbox, SortBy sort, SearchResult.ExtraData extra)\n    throws ServiceException {\n        return search(result, conn, c, mbox, sort, -1, -1, extra);\n    }\n    \n    private static <T> List<T> mergeSortedLists(List<T> toRet, List<List<T>> lists, Comparator<? super T> comparator) {\n        // TODO find or code a proper merge-sort here\n        int totalNumValues = 0;\n        for (List<T> l : lists) {\n            totalNumValues += l.size();\n        }\n        \n        for (List<T> l : lists) {\n            toRet.addAll(l);\n        }\n        \n        Collections.sort(toRet, comparator);\n        \n        return toRet;\n    }\n    \n    public static List<SearchResult> search(List<SearchResult> result, Connection conn,\n                                            DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                            int offset, int limit, SearchResult.ExtraData extra)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // this monstrosity for bug 31343\n        if (!Db.supports(Db.Capability.AVOID_OR_IN_WHERE_CLAUSE) ||\n                        (sort.getCriterion() != SortCriterion.DATE && sort.getCriterion() != SortCriterion.SIZE) || \n                        NodeType.OR != node.getNodeType()) {\n            // do it the old way\n            return searchInternal(result, conn, node, mbox, sort, offset, limit, extra);\n        } else {\n            // run each toplevel ORed part as a separate SQL query, then merge\n            // the results in memory\n            List<List<SearchResult>> resultLists = new ArrayList<List<SearchResult>>();\n            \n            for (DbSearchConstraintsNode subNode : node.getSubNodes()) {\n                List<SearchResult> subNodeResults = new ArrayList<SearchResult>();\n                search(subNodeResults, conn, subNode, mbox, sort, offset, limit, extra);\n                resultLists.add(subNodeResults);\n            }\n\n            Comparator<SearchResult> comp = SearchResult.getComparator(sort);\n            result = mergeSortedLists(result, resultLists, comp);\n            return result;\n        }\n    }\n        \n    public static List<SearchResult> searchInternal(List<SearchResult> result, Connection conn,\n                                                    DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                                    int offset, int limit, SearchResult.ExtraData extra)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean hasValidLIMIT = offset >= 0 && limit >= 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder statement = new StringBuilder();\n        int numParams = 0;\n        boolean hasMailItemOnlyConstraints = true;\n        boolean hasAppointmentTableConstraints = hasAppointmentTableConstraints(node);\n        if (hasAppointmentTableConstraints)\n            hasMailItemOnlyConstraints = hasMailItemOnlyConstraints(node);\n        boolean requiresUnion = hasMailItemOnlyConstraints && hasAppointmentTableConstraints;\n        \n        try {\n            if (hasMailItemOnlyConstraints) {\n                if (requiresUnion) {\n                    statement.append(\"(\");\n                }\n                \n                /*\n                 * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi \n                 *    [FORCE INDEX (...)]\n                 *    WHERE mi.mailboxid=? AND\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, false, node, hasValidLIMIT));\n                \n                /*\n                 *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n                 *    ( \n                 *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n                 *       [ AND tags != 0]\n                 *       [ AND tags IN ( ... ) ]\n                 *       [ AND flags IN (...) ] \n                 *       ..etc\n                 *    )   \n                 */\n                numParams += encodeConstraint(mbox, node, \n                    (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), \n                    false, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                }\n            }\n            \n            if (requiresUnion) {\n                /*\n                 * UNION\n                 */\n                statement.append(\" ) UNION ALL (\");\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                /*\n                 * SELECT...again...(this time with \"appointment as ap\")...WHERE...\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, true, node, hasValidLIMIT));\n                numParams += encodeConstraint(mbox, node, APPOINTMENT_TABLE_TYPES, true, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                    \n                    if (requiresUnion) {\n                        statement.append(\")\");\n                    }\n                }\n            }\n            \n            //\n            // TODO FIXME: include COLLATION for sender/subject sort\n            //\n            \n            /*\n             * ORDER BY (sortField) \n             */\n            statement.append(sortQuery(sort, true));\n            \n            /*\n             * LIMIT ?, ? \n             */\n            if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n            }\n\n            /**********************************************************/\n            /* Above here: build statement, below here bind params */\n            /**********************************************************/\n\n            /*\n             * Create the statement and bind all our parameters!\n             */\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: (\"+numParams+\" parameters): \"+statement.toString());\n            \n            stmt = conn.prepareStatement(statement.toString());\n            int param = 1;\n            \n            \n            if (hasMailItemOnlyConstraints) {\n                param = setSearchVars(stmt, node, param, (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), false);\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                param = setSearchVars(stmt, node, param, APPOINTMENT_TABLE_TYPES, true);\n            }\n            \n            /*\n             * Limit query if DB doesn't support LIMIT clause\n             */\n            if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE))\n                stmt.setMaxRows(offset + limit + 1);\n\n            /*\n             * EXECUTE!\n             */\n            assert(param == numParams+1);\n            rs = stmt.executeQuery();\n            \n            /*\n             * Return results\n             */\n            while (rs.next()) {\n                if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                    if (offset-- > 0)\n                        continue;\n                    if (limit-- <= 0)\n                        break;\n                }\n                result.add(SearchResult.createResult(rs, sort, extra));\n            }\n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, byte[] c) throws SQLException {\n        if (c != null && c.length > 0) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, Collection<Byte> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setIntegers(PreparedStatement stmt, int param, Collection<Integer> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (int i: c)\n                stmt.setInt(param++, i);\n        }\n        return param;\n    }\n    \n    private static final int setStrings(PreparedStatement stmt, int param, Collection<String> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (String s: c)\n                stmt.setString(param++, s);\n        }\n        return param;\n    }\n\n    private static final int setDateRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.lowest / 1000, Integer.MAX_VALUE)); \n                if (date.highest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.highest / 1000, Integer.MAX_VALUE));\n            }\n        }\n        return param;\n    }\n\n    private static final int setTimestampRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.lowest));\n                if (date.highest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.highest));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setLong(param++, r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setLong(param++, r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setIntRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setInt(param++, (int)r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setInt(param++, (int)r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setStringRange(PreparedStatement stmt, int param, Collection<StringRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (StringRange r: c) { \n                if (r.lowest != null) \n                    stmt.setString(param++, r.lowest.replace(\"\\\\\\\"\", \"\\\"\"));\n                if (r.highest != null)\n                    stmt.setString(param++, r.highest.replace(\"\\\\\\\"\", \"\\\"\"));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongs(PreparedStatement stmt, int param, Collection<Long> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (long l: c)\n                stmt.setLong(param++, l);\n        }\n        return param;\n    }\n\n    private static final int setFolders(PreparedStatement stmt, int param, Collection<Folder> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (Folder f : c) \n                stmt.setInt(param++, f.getId());\n        }\n        return param;\n    }\n\n    private static final int setBooleanAsInt(PreparedStatement stmt, int param, Boolean b) throws SQLException {\n        if (b != null) {\n            stmt.setInt(param++, b.booleanValue() ? 1 : 0);\n        }\n        return param;\n    }\n    \n    private static final void encodeBooleanValue(StringBuilder statement, boolean truthiness) {\n        if (truthiness) {\n            if (Db.supports(Db.Capability.BOOLEAN_DATATYPE)) {\n                statement.append(\" AND TRUE\");\n            } else {\n                statement.append(\" AND 1=1\");\n            }\n        } else {\n            if (Db.supports(Db.Capability.BOOLEAN_DATATYPE)) {\n                statement.append(\" AND FALSE\");\n            } else {\n                statement.append(\" AND 0=1\");\n            }\n        }\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @return number of parameters bound (always 0 in this case)\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness) {\n        statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n        return 1;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param o\n     *            if NULL, this function is a NoOp, otherwise puts ? to bind one value\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Object o) {\n        if (o != null) {\n            statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Collection<?> c) {\n        if (!ListUtil.isEmpty(c)) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.size()));\n            return c.size();\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, byte[] c) {\n        if (c != null && c.length > 0) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.length));\n            return c.length;\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @param lowestValue\n     * @return number of parameters bound\n     */\n    private static final int encodeRangeWithMinimum(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.NumericRange> ranges, long lowestValue) {\n        if (ListUtil.isEmpty(ranges))\n            return 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column) ) {\n            column = \"UPPER(\"+column+\")\";\n        }\n\n        int params = 0;\n        for (DbSearchConstraints.NumericRange r : ranges) {\n            boolean lowValid = r.lowest >= lowestValue;\n            boolean highValid = r.highest >= lowestValue;\n            if (!(lowValid || highValid))\n                continue;\n\n            statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n            if (lowValid) {\n                if (r.lowestEqual)\n                    statement.append(\" \" + column + \" >= ?\");\n                else\n                    statement.append(\" \" + column + \" > ?\");\n                params++;\n            }\n            if (highValid) {\n                if (lowValid)\n                    statement.append(\" AND\");\n                if (r.highestEqual)\n                    statement.append(\" \" + column + \" <= ?\");\n                else\n                    statement.append(\" \" + column + \" < ?\");\n                params++;\n            }\n            statement.append(')');\n        }\n        return params;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @return number of parameters bound\n     */\n    private static final int encodeRange(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.StringRange> ranges) {\n        int retVal = 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column)) {\n            column = \"UPPER(\"+column+\")\";\n        }\n        \n        if (!ListUtil.isEmpty(ranges)) {\n            for (DbSearchConstraints.StringRange r : ranges) {\n                statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n                if (r.lowest != null) {\n                    retVal++;\n                    if (r.lowestEqual)\n                        statement.append(\" \" + column + \" >= ?\");\n                    else\n                        statement.append(\" \" + column + \" > ?\");\n                }\n                if (r.highest != null) {\n                    if (r.lowest != null)\n                        statement.append(\" AND\");\n                    retVal++;\n                    if (r.highestEqual)\n                        statement.append(\" \" + column + \" <= ?\");\n                    else\n                        statement.append(\" \" + column + \" < ?\");\n                }\n                statement.append(')');\n            }\n        }\n        return retVal;\n    }\n\n\n    static class TagConstraints {\n        Set<Long> searchTagsets;\n        Set<Long> searchFlagsets;\n        Boolean unread;\n        boolean noMatches;\n\n        static TagConstraints getTagContraints(Mailbox mbox, DbSearchConstraints c, Connection conn) throws ServiceException {\n            TagConstraints tc = c.tagConstraints = new TagConstraints();\n            if (ListUtil.isEmpty(c.tags) && ListUtil.isEmpty(c.excludeTags))\n                return tc;\n\n            int setFlagMask = 0;\n            long setTagMask = 0;\n\n            if (!ListUtil.isEmpty(c.tags)) {\n                for (Tag curTag : c.tags) {\n                    if (curTag.getId() == Flag.ID_FLAG_UNREAD) {\n                        tc.unread = Boolean.TRUE; \n                    } else if (curTag instanceof Flag) {\n                        setFlagMask |= curTag.getBitmask();\n                    } else {\n                        setTagMask |= curTag.getBitmask();\n                    }\n                }\n            }\n\n            int flagMask = setFlagMask;\n            long tagMask = setTagMask;\n\n            if (!ListUtil.isEmpty(c.excludeTags)) {\n                for (Tag t : c.excludeTags) {\n                    if (t.getId() == Flag.ID_FLAG_UNREAD) {\n                        tc.unread = Boolean.FALSE;\n                    } else if (t instanceof Flag) {\n                        flagMask |= t.getBitmask();\n                    } else {\n                        tagMask |= t.getBitmask();\n                    }\n                }\n            }\n\n            TagsetCache tcFlags = DbMailItem.getFlagsetCache(conn, mbox);\n            TagsetCache tcTags  = DbMailItem.getTagsetCache(conn, mbox);\n            if (setTagMask != 0 || tagMask != 0) {\n                // note that tcTags.getMatchingTagsets() returns null when *all* tagsets match\n                tc.searchTagsets = tcTags.getMatchingTagsets(tagMask, setTagMask);\n                // if no items match the specified tags...\n                if (tc.searchTagsets != null && tc.searchTagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchTagsets = null; // otherwise we encode \"tags IN()\" which MySQL doesn't like\n                }\n            }\n\n            if (setFlagMask != 0 || flagMask != 0) {\n                // note that tcFlags.getMatchingTagsets() returns null when *all* flagsets match\n                tc.searchFlagsets = tcFlags.getMatchingTagsets(flagMask, setFlagMask);\n                // if no items match the specified flags...\n                if (tc.searchFlagsets != null && tc.searchFlagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchFlagsets = null;  // otherwise we encode \"flags IN()\" which MySQL doesn't like\n                }\n            }\n\n            return tc;\n        }\n    }\n    \n    private static int setSearchVars(PreparedStatement stmt, \n        DbSearchConstraintsNode node, int param, \n        byte[] calTypes, boolean inCalTable) throws SQLException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        \n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes())\n                param = setSearchVars(stmt, subnode, param, calTypes, inCalTable);\n            return param;\n        }\n\n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        \n        // if there are no possible matches, short-circuit here...\n        if (c.automaticEmptySet())\n            return param;\n\n        param = setBytes(stmt, param, c.types);\n        param = setBytes(stmt, param, c.excludeTypes);\n        param = setBytes(stmt, param, calTypes);\n        \n        param = setLongs(stmt, param, c.tagConstraints.searchTagsets);\n        param = setLongs(stmt, param, c.tagConstraints.searchFlagsets);\n        param = setBooleanAsInt(stmt, param, c.tagConstraints.unread);\n        param = setFolders(stmt, param, c.folders);\n        param = setFolders(stmt, param, c.excludeFolders);\n        if (c.convId > 0)\n            stmt.setInt(param++, c.convId);\n        else\n            param = setIntegers(stmt, param, c.prohibitedConvIds);\n        param = setIntegers(stmt, param, c.itemIds);\n        param = setIntegers(stmt, param, c.prohibitedItemIds);\n        param = setStrings(stmt, param, c.indexIds);\n        param = setDateRange(stmt, param, c.dates);\n        param = setLongRangeWithMinimum(stmt, param, c.modified, 1);\n        param = setLongRangeWithMinimum(stmt, param, c.modifiedContent, 1);\n        param = setIntRangeWithMinimum(stmt, param, c.sizes, 0);\n        param = setStringRange(stmt, param, c.subjectRanges);\n        param = setStringRange(stmt, param, c.senderRanges);\n        \n        if (inCalTable) {\n            param = setTimestampRange(stmt, param, c.calStartDates);\n            param = setTimestampRange(stmt, param, c.calEndDates);\n        }\n        \n        return param;\n    }\n\n\n    public static void main(String[] args) throws ServiceException {\n        Mailbox mbox = MailboxManager.getInstance().getMailboxById(1);\n\n        DbSearchConstraints hasTags = new DbSearchConstraints();\n        hasTags.hasTags = true;\n\n        DbSearchConstraints inTrash = new DbSearchConstraints();\n        Set<Folder> folders = new HashSet<Folder>();  folders.add(mbox.getFolderById(null, Mailbox.ID_FOLDER_TRASH));\n        inTrash.folders = folders;\n\n        DbSearchConstraints isUnread = new DbSearchConstraints();\n        Set<Tag> tags = new HashSet<Tag>();  tags.add(mbox.getFlagById(Flag.ID_FLAG_UNREAD));\n        isUnread.tags = tags;\n\n        DbSearchConstraintsInnerNode orClause = DbSearchConstraintsInnerNode.OR();\n        orClause.addSubNode(hasTags);\n        DbSearchConstraintsInnerNode andClause = DbSearchConstraintsInnerNode.AND();\n        andClause.addSubNode(inTrash);\n        andClause.addSubNode(isUnread);\n        orClause.addSubNode(andClause);\n\n        // \"is:unread\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), isUnread, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n        // \"has:tags or (in:trash is:unread)\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), orClause, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "905451d0a8d436517393673f6cc461f254f32468",
    "commit_msg": "(split)bug: 41970 stronger short-circuit code to prevent sqlite table scan\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=41970\n\nCopied from Perforce\n Change: 216179",
    "original_file": "DbSearch.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 19,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2011, 2012, 2013, 2014, 2016 Synacor, Inc.\n *\n * This program is free software: you can redistribute it and/or modify it under\n * the terms of the GNU General Public License as published by the Free Software Foundation,\n * version 2 of the License.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU General Public License for more details.\n * You should have received a copy of the GNU General Public License along with this program.\n * If not, see <https://www.gnu.org/licenses/>.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.imap;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n\nimport org.apache.commons.io.output.ByteArrayOutputStream;\n\nimport com.google.common.io.Closeables;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.common.util.memcached.MemcachedKey;\nimport com.zimbra.common.util.memcached.MemcachedMap;\nimport com.zimbra.common.util.memcached.MemcachedSerializer;\nimport com.zimbra.cs.memcached.MemcachedConnector;\nimport com.zimbra.cs.memcached.MemcachedKeyPrefix;\n\n/**\n * IMAP cache using memcached.\n *\n * @author ysasaki\n */\nfinal class MemcachedImapCache implements ImapSessionManager.Cache<String, ImapFolder> {\n\n    private final MemcachedMap<ImapMemcachedKey, ImapFolder> map = new MemcachedMap<ImapMemcachedKey, ImapFolder>(\n            MemcachedConnector.getClient(), new ImapMemcachedSerializer());\n\n    @Override\n    public void put(String key, ImapFolder value) {\n        try {\n            synchronized (value) {\n                map.put(new ImapMemcachedKey(key), value);\n            }\n        } catch (ServiceException e) {\n            ZimbraLog.imap.warn(\"Failed to store into cache\", e);\n        }\n    }\n\n    @Override\n    public ImapFolder get(String key) {\n        try {\n            return map.get(new ImapMemcachedKey(key));\n        } catch (ServiceException e) {\n            ZimbraLog.imap.warn(\"Failed to load from cache\", e);\n            return null;\n        }\n    }\n\n    @Override\n    public void remove(String key) {\n        try {\n            map.remove(new ImapMemcachedKey(key));\n        } catch (ServiceException e) {\n            ZimbraLog.imap.warn(\"Failed to remove from cache\", e);\n        }\n    }\n\n    @Override\n    public void updateAccessTime(String key) {\n    }\n\n    private static final class ImapMemcachedKey implements MemcachedKey {\n        private final String key;\n\n        ImapMemcachedKey(String key) {\n            this.key = key;\n        }\n\n        @Override\n        public String getKeyPrefix() {\n            return MemcachedKeyPrefix.IMAP;\n        }\n\n        @Override\n        public String getKeyValue() {\n            return key;\n        }\n    }\n\n    private static final class ImapMemcachedSerializer implements MemcachedSerializer<ImapFolder> {\n        ImapMemcachedSerializer()  { }\n\n        @Override\n        public Object serialize(ImapFolder folder) throws ServiceException {\n            ByteArrayOutputStream bout = new ByteArrayOutputStream();\n            try (ObjectOutputStream oout = new ObjectOutputStream(bout)) {\n                oout.writeObject(folder);\n            } catch (Exception e) {\n                throw ServiceException.FAILURE(\"Failed to serialize ImapFolder\", e);\n            }\n            return bout.toByteArray();\n        }\n\n        @Override\n        public ImapFolder deserialize(Object obj) throws ServiceException {\n            ObjectInputStream in = null;\n            try {\n                in = new ObjectInputStream(new ByteArrayInputStream((byte[]) obj));\n                return (ImapFolder) in.readObject();\n            } catch (Exception e) {\n                throw ServiceException.FAILURE(\"Failed to deserialize ImapFolder\", e);\n            } finally {\n                Closeables.closeQuietly(in);\n            }\n        }\n\n    }\n\n}\n",
    "vulnerability_type": "Insecure Deserialization",
    "repo": "zm-mailbox",
    "commit": "27a11bd3386f10cc4bc7a507aa4aa7e07c16c652",
    "commit_msg": "ZCS-6695 Fixing ObjectInputStream to deserialize only specified class",
    "original_file": "MemcachedImapCache.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 20,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * \n * Zimbra Collaboration Suite Server\n * Copyright (C) 2004, 2005, 2006, 2007 Zimbra, Inc.\n * \n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * \n * ***** END LICENSE BLOCK *****\n */\n\n/*\n * Created on Jun 13, 2004\n */\npackage com.zimbra.cs.mailbox;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.ref.SoftReference;\nimport java.util.*;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeMessage;\n\nimport org.apache.commons.collections.map.LRUMap;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ArrayUtil;\nimport com.zimbra.common.util.ByteUtil;\nimport com.zimbra.common.util.Constants;\nimport com.zimbra.common.util.Pair;\nimport com.zimbra.common.util.SetUtil;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.common.soap.SoapProtocol;\nimport com.zimbra.cs.account.AccessManager;\nimport com.zimbra.cs.account.Account;\nimport com.zimbra.cs.account.AccountServiceException;\nimport com.zimbra.cs.account.AuthToken;\nimport com.zimbra.cs.account.CalendarResource;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.account.Provisioning.AccountBy;\nimport com.zimbra.cs.account.accesscontrol.Right;\nimport com.zimbra.cs.db.DbMailItem;\nimport com.zimbra.cs.db.DbMailbox;\nimport com.zimbra.cs.db.DbPool;\nimport com.zimbra.cs.db.DbSearch;\nimport com.zimbra.cs.db.DbSearchConstraints;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbSearch.SearchResult;\nimport com.zimbra.cs.fb.FreeBusy;\nimport com.zimbra.cs.fb.FreeBusyProvider;\nimport com.zimbra.cs.im.IMNotification;\nimport com.zimbra.cs.im.IMPersona;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.LuceneFields;\nimport com.zimbra.cs.index.MailboxIndex;\nimport com.zimbra.cs.index.SearchParams;\nimport com.zimbra.cs.index.ZimbraQuery;\nimport com.zimbra.cs.index.ZimbraQueryResults;\nimport com.zimbra.cs.index.MailboxIndex.BrowseTerm;\nimport com.zimbra.cs.index.MailboxIndex.SortBy;\nimport com.zimbra.cs.index.queryparser.ParseException;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.BrowseResult.DomainItem;\nimport com.zimbra.cs.mailbox.CalendarItem.AlarmData;\nimport com.zimbra.cs.mailbox.CalendarItem.ReplyInfo;\nimport com.zimbra.cs.mailbox.MailItem.PendingDelete;\nimport com.zimbra.cs.mailbox.MailItem.TargetConstraint;\nimport com.zimbra.cs.mailbox.MailItem.TypedIdList;\nimport com.zimbra.cs.mailbox.MailItem.UnderlyingData;\nimport com.zimbra.cs.mailbox.MailServiceException.NoSuchItemException;\nimport com.zimbra.cs.mailbox.MailboxManager.MailboxLock;\nimport com.zimbra.cs.mailbox.Note.Rectangle;\nimport com.zimbra.cs.mailbox.calendar.CalendarMailSender;\nimport com.zimbra.cs.mailbox.calendar.ICalTimeZone;\nimport com.zimbra.cs.mailbox.calendar.Invite;\nimport com.zimbra.cs.mailbox.calendar.RecurId;\nimport com.zimbra.cs.mailbox.calendar.TimeZoneFixup;\nimport com.zimbra.cs.mailbox.calendar.TimeZoneMap;\nimport com.zimbra.cs.mailbox.calendar.ZCalendar;\nimport com.zimbra.cs.mailbox.calendar.ZOrganizer;\nimport com.zimbra.cs.mailbox.calendar.ZCalendar.ICalTok;\nimport com.zimbra.cs.mailbox.calendar.ZCalendar.ZComponent;\nimport com.zimbra.cs.mailbox.calendar.ZCalendar.ZProperty;\nimport com.zimbra.cs.mailbox.calendar.ZCalendar.ZVCalendar;\nimport com.zimbra.cs.mailbox.calendar.cache.CalendarCache;\nimport com.zimbra.cs.mailbox.calendar.cache.CalendarData;\nimport com.zimbra.cs.mailbox.calendar.tzfixup.TimeZoneFixupRules;\nimport com.zimbra.cs.mime.ParsedContact;\nimport com.zimbra.cs.mime.ParsedDocument;\nimport com.zimbra.cs.mime.ParsedMessage;\nimport com.zimbra.cs.pop3.Pop3Message;\nimport com.zimbra.cs.redolog.op.*;\nimport com.zimbra.cs.service.FeedManager;\nimport com.zimbra.cs.session.AllAccountsRedoCommitCallback;\nimport com.zimbra.cs.session.PendingModifications;\nimport com.zimbra.cs.session.Session;\nimport com.zimbra.cs.session.SessionCache;\nimport com.zimbra.cs.session.SoapSession;\nimport com.zimbra.cs.session.PendingModifications.Change;\nimport com.zimbra.cs.service.AuthProvider;\nimport com.zimbra.cs.stats.ZimbraPerf;\nimport com.zimbra.cs.store.Blob;\nimport com.zimbra.cs.store.StoreManager;\nimport com.zimbra.cs.store.Volume;\nimport com.zimbra.cs.util.AccountUtil;\nimport com.zimbra.cs.util.Zimbra;\nimport com.zimbra.cs.zclient.ZMailbox;\nimport com.zimbra.cs.zclient.ZMailbox.Options;\n\n/**\n * @author schemers\n */\npublic class Mailbox {\n\n    /* these probably should be ints... */\n    public static final String BROWSE_BY_DOMAINS     = \"domains\";\n    public static final String BROWSE_BY_OBJECTS     = \"objects\";\n    public static final String BROWSE_BY_ATTACHMENTS = \"attachments\";\n\n    public static final int ID_AUTO_INCREMENT   = -1;\n    public static final int ID_FOLDER_USER_ROOT = 1;\n    public static final int ID_FOLDER_INBOX     = 2;\n    public static final int ID_FOLDER_TRASH     = 3;\n    public static final int ID_FOLDER_SPAM      = 4;\n    public static final int ID_FOLDER_SENT      = 5;\n    public static final int ID_FOLDER_DRAFTS    = 6;\n    public static final int ID_FOLDER_CONTACTS  = 7;\n    public static final int ID_FOLDER_TAGS      = 8;\n    public static final int ID_FOLDER_CONVERSATIONS = 9;\n    public static final int ID_FOLDER_CALENDAR  = 10;\n    public static final int ID_FOLDER_ROOT      = 11;\n    public static final int ID_FOLDER_NOTEBOOK  = 12;\n    public static final int ID_FOLDER_AUTO_CONTACTS = 13;\n    public static final int ID_FOLDER_IM_LOGS   = 14;\n    public static final int ID_FOLDER_TASKS     = 15;\n    public static final int ID_FOLDER_BRIEFCASE = 16;\n\n    public static final int HIGHEST_SYSTEM_ID = 16;\n    public static final int FIRST_USER_ID     = 256;\n\n    private static final String MD_CONFIG_VERSION = \"ver\";\n\n\n    public static final class MailboxData {\n        public int     id;\n        public int     schemaGroupId;\n        public String  accountId;\n        public long    size;\n        public int     contacts;\n        public short   indexVolumeId;\n        public int     lastItemId;\n        public int     lastChangeId;\n        public long    lastChangeDate;\n        public int     lastWriteDate;\n        public int     recentMessages;\n        public int     trackSync;\n        public boolean trackImap;\n        public int     idxDeferredCount;\n        public Set<String> configKeys;\n    }\n\n    private static final class MailboxChange {\n        private static final int NO_CHANGE = -1;\n\n        long       timestamp = System.currentTimeMillis();\n        int        depth     = 0;\n        boolean    active;\n        Connection conn      = null;\n        RedoableOp recorder  = null;\n        Map<MailItem, IndexItemEntry> indexItems = new HashMap<MailItem, IndexItemEntry>();\n        List<Integer> indexItemsToDelete = new ArrayList<Integer>();\n        Map<Integer, MailItem> itemCache = null;\n        OperationContext octxt = null;\n        TargetConstraint tcon  = null;\n\n        Integer sync     = null;\n        Boolean imap     = null;\n        long    size     = NO_CHANGE;\n        int     itemId   = NO_CHANGE;\n        int     changeId = NO_CHANGE;\n        int     contacts = NO_CHANGE;\n        int     accessed = NO_CHANGE;\n        int     recent   = NO_CHANGE;\n        int     idxDeferred = NO_CHANGE;\n        Pair<String, Metadata> config = null;\n\n        PendingModifications mDirty = new PendingModifications();\n        List<Object> mOtherDirtyStuff = new LinkedList<Object>();\n        PendingDelete deletes = null;\n\n        void setTimestamp(long millis) {\n            if (depth == 1)\n                timestamp = millis;\n        }\n\n        void startChange(String caller, OperationContext ctxt, RedoableOp op) {\n            active = true;\n            if (depth++ == 0) {\n                octxt = ctxt;\n                recorder = op;\n                if (ZimbraLog.mailbox.isDebugEnabled())\n                    ZimbraLog.mailbox.debug(\"beginning operation: \" + caller);\n            } else {\n                if (ZimbraLog.mailbox.isDebugEnabled())\n                    ZimbraLog.mailbox.debug(\"  increasing stack depth to \" + depth + \" (\" + caller + ')');\n            }\n        }\n        boolean endChange() {\n            if (ZimbraLog.mailbox.isDebugEnabled()) {\n                if (depth <= 1) {\n                    if (ZimbraLog.mailbox.isDebugEnabled())                    \n                        ZimbraLog.mailbox.debug(\"ending operation\" + (recorder == null ? \"\" : \": \" + StringUtil.getSimpleClassName(recorder)));\n                } else {\n                    if (ZimbraLog.mailbox.isDebugEnabled())\n                        ZimbraLog.mailbox.debug(\"  decreasing stack depth to \" + (depth - 1));\n                }\n            }\n            return (--depth == 0);\n        }\n        boolean isActive()  { return active; }\n\n        Connection getConnection() throws ServiceException {\n            if (conn == null) {\n                conn = DbPool.getConnection();\n                if (ZimbraLog.mailbox.isDebugEnabled())\n                    ZimbraLog.mailbox.debug(\"  fetching new DB connection\");\n            }\n            return conn;\n        }\n\n        RedoableOp getRedoPlayer()   { return (octxt == null ? null : octxt.getPlayer()); }\n        RedoableOp getRedoRecorder() { return recorder; }\n        \n        private static final class IndexItemEntry {\n            IndexItemEntry(boolean deleteFirst, List<org.apache.lucene.document.Document> docList) { \n                mDeleteFirst = deleteFirst;\n                mData = docList;\n            }\n            boolean mDeleteFirst;\n            List<org.apache.lucene.document.Document> mData;\n        }\n        \n        void addIndexedItem(MailItem item, boolean deleteFirst, List<org.apache.lucene.document.Document> docList)  { \n            indexItems.put(item, new IndexItemEntry(deleteFirst, docList)); \n        }\n        void addIndexDelete(Integer id) {\n            indexItemsToDelete.add(id);\n        }\n\n        void addPendingDelete(PendingDelete info) {\n            if (deletes == null)\n                deletes = info;\n            else\n                deletes.add(info);\n        }\n\n        boolean isMailboxRowDirty(MailboxData data) {\n            if (recent != NO_CHANGE || size != NO_CHANGE || contacts != NO_CHANGE || idxDeferred != NO_CHANGE)\n                return true;\n            if (itemId != NO_CHANGE && itemId / DbMailbox.ITEM_CHECKPOINT_INCREMENT > data.lastItemId / DbMailbox.ITEM_CHECKPOINT_INCREMENT)\n                return true;\n            if (changeId != NO_CHANGE && changeId / DbMailbox.CHANGE_CHECKPOINT_INCREMENT > data.lastChangeId / DbMailbox.CHANGE_CHECKPOINT_INCREMENT)\n                return true;\n            return false;\n        }\n        void reset() {\n            if (conn != null)\n                DbPool.quietClose(conn);\n            active = false;\n            conn = null;  octxt = null;  tcon = null;\n            depth = 0;\n            size = changeId = itemId = contacts = accessed = recent = idxDeferred = NO_CHANGE;\n            sync = null;  config = null;  deletes = null;\n            itemCache = null;  indexItems.clear(); indexItemsToDelete.clear();\n            mDirty.clear();  mOtherDirtyStuff.clear();\n            if (ZimbraLog.mailbox.isDebugEnabled())\n                ZimbraLog.mailbox.debug(\"clearing change\");\n        }\n    }\n\n    public static class OperationContext {\n        public static final boolean CHECK_CREATED = false, CHECK_MODIFIED = true;\n\n        private Account    authuser;\n        private boolean    isAdmin;\n        private Session    session;\n        private RedoableOp player;\n        private String     requestIP;\n        private String     userAgent;\n        private AuthToken  authToken;\n        \n        boolean changetype = CHECK_CREATED;\n        int     change = -1;\n\n        public OperationContext(RedoableOp redoPlayer) {\n            player = redoPlayer;\n        }\n        public OperationContext(Account acct) {\n            this(acct, false);\n        }\n        public OperationContext(Mailbox mbox) throws ServiceException {\n            this(mbox.getAccount());\n        }\n        public OperationContext(Account acct, boolean admin) {\n            authuser = acct;  isAdmin = admin;\n        }\n        public OperationContext(String accountId) throws ServiceException {\n            authuser = Provisioning.getInstance().get(AccountBy.id, accountId);\n            if (authuser == null)\n                throw AccountServiceException.NO_SUCH_ACCOUNT(accountId);\n        }\n        public OperationContext(AuthToken auth) throws ServiceException {\n            authToken = auth;\n            String accountId = auth.getAccountId();\n            isAdmin = auth.isAdmin() || auth.isDomainAdmin();\n            authuser = Provisioning.getInstance().get(AccountBy.id, accountId, authToken);\n            if (authuser == null && !auth.isZimbraUser()) {\n                if (auth.getDigest() != null)\n                    authuser = new ACL.GuestAccount(auth);\n                else\n                    authuser = ACL.ANONYMOUS_ACCT;\n            }\n            if (authuser == null)\n                throw AccountServiceException.NO_SUCH_ACCOUNT(accountId);\n        }\n        public OperationContext(OperationContext octxt) {\n            player     = octxt.player;      session = octxt.session;\n            authuser   = octxt.authuser;    isAdmin = octxt.isAdmin;\n            changetype = octxt.changetype;  change  = octxt.change;\n            authToken  = octxt.authToken;\n        }\n\n        public OperationContext setChangeConstraint(boolean checkModified, int changeId) {\n            changetype = checkModified;  change = changeId;  return this;\n        }\n        public OperationContext unsetChangeConstraint() {\n            changetype = CHECK_CREATED;  change = -1;  return this;\n        }\n\n        public OperationContext setSession(Session s) {\n            session = s;  return this;\n        }\n        Session getSession() {\n            return session;\n        }\n\n        public RedoableOp getPlayer() {\n            return player;\n        }\n        long getTimestamp() {\n            return (player == null ? System.currentTimeMillis() : player.getTimestamp());\n        }\n        int getChangeId() {\n            return (player == null ? -1 : player.getChangeId());\n        }\n        public boolean needRedo() {\n            return player == null || !player.getUnloggedReplay();\n        }\n\n        public Account getAuthenticatedUser() {\n            return authuser;\n        }\n        \n        public AuthToken getAuthToken() throws ServiceException {\n            return getAuthToken(true);\n        }\n        \n        public AuthToken getAuthToken(boolean constructIfNotPresent) throws ServiceException {\n            if (authToken != null)\n                return authToken;\n            else if (constructIfNotPresent) {\n                if (getAuthenticatedUser() != null)\n                    return AuthProvider.getAuthToken(getAuthenticatedUser(), isUsingAdminPrivileges());\n            }\n            return null;\n        }\n        \n        public boolean isUsingAdminPrivileges() {\n            return isAdmin;\n        }\n        public boolean isDelegatedRequest(Mailbox mbox) {\n            return authuser != null && !authuser.getId().equalsIgnoreCase(mbox.getAccountId());\n        }\n        \n        public OperationContext setRequestIP(String addr) {\n            requestIP = addr;  return this;\n        }\n        \n        public String getRequestIP() {\n            return requestIP;\n        }\n        \n        public OperationContext setUserAgent(String ua) {\n            userAgent = ua;  return this;\n        }\n        \n        public String getUserAgent() {\n            return userAgent;\n        }\n    }\n\n    // TODO: figure out correct caching strategy\n    private static final int MAX_ITEM_CACHE_WITH_LISTENERS    = LC.zimbra_mailbox_active_cache.intValue();\n    private static final int MAX_ITEM_CACHE_WITHOUT_LISTENERS = LC.zimbra_mailbox_inactive_cache.intValue();\n    private static final int MAX_MSGID_CACHE = 10;\n\n    private int           mId;\n    private MailboxData   mData;\n    private MailboxChange mCurrentChange = new MailboxChange();\n\n    private Map<Integer, Folder> mFolderCache;\n    private Map<Object, Tag>     mTagCache;\n    private SoftReference<Map<Integer, MailItem>> mItemCache = new SoftReference<Map<Integer, MailItem>>(null);\n    private LRUMap       mConvHashes     = new LRUMap(MAX_MSGID_CACHE);\n    private LRUMap       mSentMessageIDs = new LRUMap(MAX_MSGID_CACHE);\n    private Set<Session> mListeners      = new HashSet<Session>();\n\n    private MailboxLock  mMaintenance = null;\n    private MailboxIndex mMailboxIndex = null;\n    private IMPersona mPersona = null;\n    private MailboxVersion mVersion = null;\n    \n    /** flag: messages sent by me */\n    public Flag mSentFlag;\n    /** flag: messages/contacts with attachments */\n    public Flag mAttachFlag;\n    /** flag: messages that have been replied to */\n    public Flag mReplyFlag;\n    /** flag: messages that have been forwarded */\n    public Flag mForwardFlag;\n    /** flag: messages that have been copied or that are copies */\n    public Flag mCopiedFlag;\n    /** flag: messages/contacts/etc. with the little red flag */\n    public Flag mFlaggedFlag;\n    /** flag: draft messages */\n    public Flag mDraftFlag;\n    /** flag: messages/folders/etc. in IMAP's \"deleted-not-expunged\" limbo state */\n    public Flag mDeletedFlag;\n    /** flag: messages that have read-receipt MDN sent */\n    public Flag mNotifiedFlag;\n    /** flag: unread messages */\n    public Flag mUnreadFlag;\n    /** flag: when a message is a valid Invite */\n    public Flag mInviteFlag;\n    /** flag: urgent messages */\n    public Flag mUrgentFlag;\n    /** flag: low-priority messages */\n    public Flag mBulkFlag;\n    /** flag: indexing deferred */\n    public Flag mIndexingDeferredFlag;\n    /** flag: items with accessible past revisions */\n    public Flag mVersionedFlag;\n    /** flag: IMAP-subscribed folders */\n    public Flag mSubscribedFlag;\n    /** flag: exclude folder from free-busy calculations */\n    public Flag mExcludeFBFlag;\n    /** flag: folders \"checked\" for display in the web UI */\n    public Flag mCheckedFlag;\n    /** flag: whether a folder does not inherit permissions from its parent */\n    public Flag mNoInheritFlag;\n    /** flag: whether a folder is a sync folder paired with source folder on server */\n    public Flag mSyncFolderFlag;\n    /** flag: whether a folder is to sync with its counterpart on server */\n    public Flag mSyncFlag;\n\n    /** the full set of message flags, in order */\n    final Flag[] mFlags = new Flag[31];\n\n    /** used by checkInitialization() to make sure the init steps happen only once */\n    private boolean mInitializationComplete = false;\n\n    /**\n     * Constructor\n     * \n     * @param data\n     * @throws ServiceException\n     */\n    protected Mailbox(MailboxData data) throws ServiceException {\n        mId   = data.id;\n        mData = data;\n        mData.lastChangeDate = System.currentTimeMillis();\n        initFlags();\n        // version init done in checkInitialization()\n        // index init done in checkInitialization()\n    }\n    \n    /**\n     * Called by the MailboxManager before returning the mailbox, this\n     * function makes sure the Mailbox is fully initialized (index initialized,\n     * version check, etc etc).  \n     * \n     * Any mailbox-initialization steps that require I/O should be done in this \n     * API and not in the Mailbox constructor since the Mailbox constructor can\n     * conceivably be run twice in a race (even though the MailboxMgr makes sure \n     * only one instance of a particular mailbox \"wins\")\n     * \n     * @return TRUE if we did some work (this was the mailbox's first init) or\n     *         FALSE if mailbox was already initialized\n     * @throws ServiceException\n     */\n    synchronized boolean finishInitialization() throws ServiceException {\n    \tif (!mInitializationComplete) {\n    \t\t// init the index\n            if (!DebugConfig.disableIndexing)\n                mMailboxIndex = new MailboxIndex(this, null);\n            \n            if (mVersion == null) { \n                // if we've just initialized() the mailbox, then the version will\n                // be set in the config, but it won't be comitted yet -- and unfortunately \n                // getConfig() won't return us the proper value in this case....so just\n                // use the local mVersion value if it is already set (that's the case\n                // if we are initializing a new mailbox) and otherwise we'll read the \n                // mailbox version from config\n                Metadata md = getConfig(null, MD_CONFIG_VERSION);\n                mVersion = MailboxVersion.fromMetadata(md);\n            }\n            \n            // check for mailbox upgrade\n    \t\tif (!getVersion().atLeast(1, 2)) {\n    \t\t\t// Version (1.0,1.1)->1.2 Re-Index all contacts \n    \t\t\tSet<Byte> types = new HashSet<Byte>();\n    \t\t\ttypes.add(MailItem.TYPE_CONTACT);\n    \t\t\treIndex(null, types, null, COMPLETED_REINDEX_CONTACTS_V1_2, false); \n    \t\t}\n    \t\t\n            // same prescription for both the 1.2 -> 1.3 and 1.3 -> 1.4 migrations\n            if (!getVersion().atLeast(1, 4)) {\n                recalculateFolderAndTagCounts();\n                updateVersion(new MailboxVersion((short) 1, (short) 4));\n    \t\t}\n    \t\t\n    \t\t// done!\n    \t\tmInitializationComplete = true;\n    \t\treturn true;\n    \t}\n    \treturn false;\n    }\n    \n\n    /** Returns the server-local numeric ID for this mailbox.  To get a\n     *  system-wide, persistent unique identifier for the mailbox, use\n     *  {@link #getAccountId()}. */\n    public int getId() {\n        return mId;\n    }\n\n    /** Returns which MBOXGROUP<N> database this mailbox is homed in. */\n    public int getSchemaGroupId() {\n        return mData.schemaGroupId;\n    }\n\n    /** Returns the ID of this mailbox's Account.\n     * \n     * @see #getAccount() */\n    public String getAccountId() {\n        return mData.accountId;\n    }\n\n    /** Returns the {@link Account} object for this mailbox's owner.  At\n     *  present, each account can have at most one <tt>Mailbox</tt>.\n     *  \n     * @throws AccountServiceException if no account exists */\n    public synchronized Account getAccount() throws ServiceException {\n        Account acct = Provisioning.getInstance().get(AccountBy.id, getAccountId());\n        if (acct != null)\n            return acct;\n        ZimbraLog.mailbox.warn(\"no account found in directory for mailbox \" + mId +\n                    \" (was expecting \" + getAccountId() + ')');\n        throw AccountServiceException.NO_SUCH_ACCOUNT(mData.accountId);\n    }\n\n    public synchronized IMPersona getPersona() throws ServiceException {\n        if (mPersona == null)\n            mPersona = IMPersona.loadPersona(this);\n        return mPersona;\n    }\n\n    /** Returns the Mailbox's Lucene index. */\n    public MailboxIndex getMailboxIndex() {\n        return mMailboxIndex;\n    }\n\n    /** Retuns the ID of the volume this <tt>Mailbox</tt>'s index lives on. */\n    public short getIndexVolume() {\n        return mData.indexVolumeId;\n    }\n\n    MailboxLock getMailboxLock() {\n        return mMaintenance;\n    }\n\n    /** Returns a {@link MailSender} object that can be used to send mail,\n     *  save a copy to the Sent folder, etc. */\n    public MailSender getMailSender() {\n        return new MailSender();\n    }\n\n\n    /** Returns the list of all <code>Mailbox</code> listeners of a given type.\n     *  Returns all listeners when the passed-in type is <tt>null</tt>. */\n    public synchronized List<Session> getListeners(Session.Type stype) {\n        if (mListeners.isEmpty())\n            return Collections.emptyList();\n        else if (stype == null)\n            return new ArrayList<Session>(mListeners);\n\n        List<Session> sessions = new ArrayList<Session>(mListeners.size());\n        for (Session s : mListeners)\n            if (s.getType() == stype)\n                sessions.add(s);\n        return sessions;\n    }\n\n    boolean hasListeners(Session.Type stype) {\n        if (mListeners.isEmpty())\n            return false;\n        else if (stype == null)\n            return true;\n\n        for (Session s : mListeners)\n            if (s.getType() == stype)\n                return true;\n        return false;\n    }\n\n    /** Adds a {@link Session} to the set of listeners notified on Mailbox\n     *  changes.\n     * \n     * @param session  The Session registering for notifications.\n     * @throws ServiceException  If the mailbox is in maintenance mode. */\n    public synchronized void addListener(Session session) throws ServiceException {\n        if (session == null)\n            return;\n        if (mMaintenance != null)\n            throw MailServiceException.MAINTENANCE(mId);\n        mListeners.add(session);\n\n        if (ZimbraLog.mailbox.isDebugEnabled())\n            ZimbraLog.mailbox.debug(\"adding listener: \" + session);\n    }\n\n    /** Removes a {@link Session} from the set of listeners notified on\n     *  Mailbox changes.\n     * \n     * @param session  The listener to deregister for notifications. */\n    public synchronized void removeListener(Session session) {\n        mListeners.remove(session);\n\n        if (ZimbraLog.mailbox.isDebugEnabled())\n            ZimbraLog.mailbox.debug(\"clearing listener: \" + session);\n    }\n\n    /** Cleans up and disconnects all {@link Session}s listening for\n     *  notifications on this Mailbox.\n     * \n     * @see SessionCache#clearSession(Session) */\n    private void purgeListeners() {\n        if (ZimbraLog.mailbox.isDebugEnabled())\n            ZimbraLog.mailbox.debug(\"purging listeners\");\n        \n        if (mPersona != null) \n            mPersona.purgeListeners(); // do this BEFORE purgeListeners\n        \n        Set<Session> purged = new HashSet<Session>(mListeners);\n        for (Session session : purged)\n            SessionCache.clearSession(session);\n        // this may be redundant, as Session.doCleanup should dequeue\n        //   the listener, but empty the list here just to be sure\n        mListeners.clear();\n    }\n\n    /** Posts an IM-related notification to all the Mailbox's sessions. */\n    public synchronized void postIMNotification(IMNotification imn) {\n        for (Session session : mListeners)\n            session.notifyIM(imn);\n    }\n\n    /** Returns whether the server is keeping track of message deletes\n     *  (etc.) for sync clients.  By default, sync tracking is off.\n     * \n     * @see #beginTrackingSync */\n    boolean isTrackingSync() {\n        return (mCurrentChange.sync == null ? mData.trackSync : mCurrentChange.sync) > 0;\n    }\n\n    /** Returns whether the server is keeping track of message moves\n     *  for imap clients.  By default, imap tracking is off.\n     * \n     * @see #beginTrackingImap */\n    public boolean isTrackingImap() {\n        return (mCurrentChange.imap == null ? mData.trackImap : mCurrentChange.imap);\n    }\n\n    /** Returns the operation timestamp as a UNIX int with 1-second\n     *  resolution.  This time is set at the start of the Mailbox\n     *  transaction and should match the <tt>long</tt> returned\n     *  by {@link #getOperationTimestampMillis}. */\n    public int getOperationTimestamp() {\n        return (int) (mCurrentChange.timestamp / 1000);\n    }\n\n    /** Returns the operation timestamp as a Java long with full\n     *  millisecond resolution.  This time is set at the start of\n     *  the Mailbox transaction and should match the <tt>int</tt>\n     *  returned by {@link #getOperationTimestamp}. */\n    public long getOperationTimestampMillis() {\n        return mCurrentChange.timestamp;\n    }\n\n    /** Returns the timestamp of the last committed mailbox change.\n     *  Note that this time is not persisted across server restart. */\n    public long getLastChangeDate() {\n        return mData.lastChangeDate;\n    }\n\n\n    /** Returns the current count of messages with the\n     *  {@link Flag#BITMASK_INDEXING_DEFERRED} flag set. */\n    public int getIndexDeferredCount() {\n        return (mCurrentChange.idxDeferred == MailboxChange.NO_CHANGE ? mData.idxDeferredCount : mCurrentChange.idxDeferred);\n    }\n\n\n    /** Returns the change sequence number for the most recent\n     *  transaction.  This will be either the change number for the\n     *  current transaction or, if no database changes have yet been\n     *  made in this transaction, the sequence number for the last\n     *  committed change.\n     * \n     * @see #getOperationChangeID */\n    public int getLastChangeID() {\n        return (mCurrentChange.changeId == MailboxChange.NO_CHANGE ? mData.lastChangeId : Math.max(mData.lastChangeId, mCurrentChange.changeId));\n    }\n\n    private void setOperationChangeID(int changeFromRedo) throws ServiceException {\n        if (mCurrentChange.changeId != MailboxChange.NO_CHANGE) {\n            if (mCurrentChange.changeId == changeFromRedo)\n                return;\n            throw ServiceException.FAILURE(\"cannot specify change ID after change is in progress\", null);\n        }\n\n        int lastId = getLastChangeID();\n        int nextId = (changeFromRedo == ID_AUTO_INCREMENT ? lastId + 1 : changeFromRedo);\n\n        // need to keep the current change ID regardless of whether it's a highwater mark\n        mCurrentChange.changeId = nextId;\n    }\n\n    /** Returns the change sequence number for the current transaction.\n     *  If a change number has not yet been assigned to the transaction,\n     *  assigns one.<p>\n     * \n     *  Every write to the database is assigned a monotonically-increasing\n     *  (though not necessarily gap-free) change number.  All writes in\n     *  a single transaction receive the same change number.  This change\n     *  number is persisted as <tt>MAIL_ITEM.MOD_METADATA</tt> in all\n     *  non-delete cases, as <tt>MAIL_ITEM.MOD_CONTENT</tt> for any \n     *  items that were created or had their \"content\" modified, and as\n     *  <tt>TOMBSTONE.SEQUENCE</tt> for hard deletes. */\n    public int getOperationChangeID() throws ServiceException {\n        if (mCurrentChange.changeId == MailboxChange.NO_CHANGE)\n            setOperationChangeID(ID_AUTO_INCREMENT);\n        return mCurrentChange.changeId;\n    }\n\n    /** @return whether the object has changed more recently than the client knows about */\n    boolean checkItemChangeID(MailItem item) throws ServiceException {\n        if (item == null)\n            return true;\n        return checkItemChangeID(item.getModifiedSequence(), item.getSavedSequence());\n    }\n    public boolean checkItemChangeID(int modMetadata, int modContent) throws ServiceException {\n        if (mCurrentChange.octxt == null || mCurrentChange.octxt.change < 0)\n            return true;\n        OperationContext octxt = mCurrentChange.octxt;\n        if (octxt.changetype == OperationContext.CHECK_CREATED && modContent > octxt.change)\n            return false;\n        else if (octxt.changetype == OperationContext.CHECK_MODIFIED && modMetadata > octxt.change)\n            throw MailServiceException.MODIFY_CONFLICT();\n        return true;\n    }\n\n    /** Returns the last id assigned to an item successfully created in the\n     *  mailbox.  On startup, this value will be rounded up to the nearest\n     *  100, so there may be gaps in the set of IDs actually assigned.\n     * \n     * @see MailItem#getId()\n     * @see DbMailbox#ITEM_CHECKPOINT_INCREMENT */\n    public int getLastItemId() {\n        return (mCurrentChange.itemId == MailboxChange.NO_CHANGE ? mData.lastItemId : mCurrentChange.itemId);\n    }\n\n    // Don't make this method package-visible.  Keep it private.\n    //   idFromRedo: specific ID value to use during redo execution, or ID_AUTO_INCREMENT\n    private int getNextItemId(int idFromRedo) {\n        int lastId = getLastItemId();\n        int nextId = (idFromRedo == ID_AUTO_INCREMENT ? lastId + 1 : idFromRedo);\n\n        if (nextId > lastId)\n            mCurrentChange.itemId = nextId;\n        return nextId;\n    }\n\n\n    TargetConstraint getOperationTargetConstraint() {\n        return mCurrentChange.tcon;\n    }\n\n    void setOperationTargetConstraint(TargetConstraint tcon) {\n        mCurrentChange.tcon = tcon;\n    }\n\n    public OperationContext getOperationContext() {\n        return (mCurrentChange.active ? mCurrentChange.octxt : null);\n    }\n\n    RedoableOp getRedoRecorder() {\n        return mCurrentChange.recorder;\n    }\n\n    PendingModifications getPendingModifications() {\n        return mCurrentChange.mDirty;\n    }\n\n\n    /** Returns the {@link Account} for the authenticated user for the\n     *  transaction.  Returns <tt>null</tt> if none was supplied in the\n     *  transaction's {@link Mailbox.OperationContext} or if the authenticated\n     *  user is the same as the <tt>Mailbox</tt>'s owner. */\n    Account getAuthenticatedAccount() {\n        Account authuser = null;\n        if (mCurrentChange.active && mCurrentChange.octxt != null)\n            authuser = mCurrentChange.octxt.getAuthenticatedUser();\n        // XXX if the current authenticated user is the owner, it will return null.\n        // later on in Folder.checkRights(), the same assumption is used to validate\n        // the access.\n        if (authuser != null && authuser.getId().equals(getAccountId()))\n            authuser = null;\n        return authuser;\n    }\n\n    /** Returns whether the authenticated user for the transaction is using\n     *  any admin privileges they might have.  Admin users not using privileges\n     *  are exactly like any other user and cannot access any folder they have\n     *  not explicitly been granted access to.\n     * \n     * @see #getAuthenticatedAccount() */\n    boolean isUsingAdminPrivileges() {\n        return mCurrentChange.active && mCurrentChange.octxt != null && mCurrentChange.octxt.isUsingAdminPrivileges();\n    }\n\n    /** Returns whether the authenticated user has full access to this\n     *  <tt>Mailbox</tt>.   The following users have full access:<ul>\n     *    <li>the mailbox's owner\n     *    <li>all global admin accounts (if using admin privileges)\n     *    <li>appropriate domain admins (if using admin privileges)</ul>\n     * \n     * @see #getAuthenticatedAccount()\n     * @see #isUsingAdminPrivileges() */\n    boolean hasFullAccess() throws ServiceException {\n        Account authuser = getAuthenticatedAccount();\n        // XXX: in Mailbox, authuser is set to null if authuser == owner.\n        if (authuser == null || getAccountId().equals(authuser.getId()))\n            return true;\n        if (mCurrentChange.active && mCurrentChange.octxt != null)\n            return AccessManager.getInstance().canAccessAccount(authuser, getAccount(), isUsingAdminPrivileges());\n        return false;\n    }\n\n\n    /** Returns the total (uncompressed) size of the mailbox's contents. */\n    public long getSize() {\n        return (mCurrentChange.size == MailboxChange.NO_CHANGE ? mData.size : mCurrentChange.size);\n    }\n\n    /** change the current size of the mailbox */\n    void updateSize(long delta) throws ServiceException {\n        updateSize(delta, true);\n    }\n\n    void updateSize(long delta, boolean checkQuota) throws ServiceException {\n        if (delta == 0)\n            return;\n        // if we go negative, that's OK!  just pretend we're at 0.\n        mCurrentChange.mDirty.recordModified(this, Change.MODIFIED_SIZE);\n        mCurrentChange.size = Math.max(0, (mCurrentChange.size == MailboxChange.NO_CHANGE ? mData.size : mCurrentChange.size) + delta);\n\n        if (delta < 0 || !checkQuota)\n            return;\n        long quota = getAccount().getLongAttr(Provisioning.A_zimbraMailQuota, 0);\n        if (quota != 0 && mCurrentChange.size > quota)\n            throw MailServiceException.QUOTA_EXCEEDED(quota);\n    }\n\n    /** Returns the last time that the mailbox had a write op caused by a SOAP\n     *  session.  This value is written both right after the session's first\n     *  write op as well as right after the session expires.\n     * \n     * @see #recordLastSoapAccessTime(long) */\n    public synchronized long getLastSoapAccessTime() {\n        long lastAccess = (mCurrentChange.accessed == MailboxChange.NO_CHANGE ? mData.lastWriteDate : mCurrentChange.accessed) * 1000L;\n        for (Session s : mListeners) {\n            if (s instanceof SoapSession)\n                lastAccess = Math.max(lastAccess, ((SoapSession) s).getLastWriteAccessTime());\n        }\n        return lastAccess;\n    }\n\n    /** Records the last time that the mailbox had a write op caused by a SOAP\n     *  session.  This value is written both right after the session's first\n     *  write op as well as right after the session expires.\n     * \n     * @see #getLastSoapAccessTime() */\n    public synchronized void recordLastSoapAccessTime(long time) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"recordLastSoapAccessTime\", null);\n            if (time > mData.lastWriteDate) {\n                mCurrentChange.accessed = (int) (time / 1000);\n                DbMailbox.recordLastSoapAccess(this);\n            }\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns the number of \"recent\" messages in the mailbox.  A message is\n     *  considered \"recent\" if (a) it's not a draft or a sent message, and\n     *  (b) it was added since the last write operation associated with any\n     *  SOAP session. */\n    public int getRecentMessageCount() {\n        return (mCurrentChange.recent == MailboxChange.NO_CHANGE ? mData.recentMessages : mCurrentChange.recent);\n    }\n\n    /** Returns the number of contacts currently in the mailbox.\n     * \n     * @see #updateContactCount(int) */\n    public int getContactCount() {\n        return (mCurrentChange.contacts == MailboxChange.NO_CHANGE ? mData.contacts : mCurrentChange.contacts);\n    }\n\n    /** Updates the count of contacts currently in the mailbox.  The\n     *  administrator can place a limit on a user's contact count by setting\n     *  the <tt>zimbraContactMaxNumEntries</tt> COS attribute.  Contacts\n     *  in the Trash still count against this quota.\n     * \n     * @param delta  The change in contact count, negative to decrease.\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><tt>mail.TOO_MANY_CONTACTS</tt> - if the user's contact\n     *        quota would be exceeded</ul> */\n    void updateContactCount(int delta) throws ServiceException {\n        if (delta == 0)\n            return;\n        // if we go negative, that's OK!  just pretend we're at 0.\n        mCurrentChange.contacts = Math.max(0, (mCurrentChange.contacts == MailboxChange.NO_CHANGE ? mData.contacts : mCurrentChange.contacts) + delta);\n\n        if (delta < 0)\n            return;\n        int quota = getAccount().getIntAttr(Provisioning.A_zimbraContactMaxNumEntries, 0);\n        if (quota != 0 && mCurrentChange.contacts > quota)\n            throw MailServiceException.TOO_MANY_CONTACTS(quota);\n    }\n\n\n    /** Adds the item to the current change's list of items created during\n     *  the transaction.\n     * @param item  The created item. */\n    void markItemCreated(MailItem item) {\n        if ((item.getFlagBitmask() & Flag.BITMASK_UNCACHED) == 0)\n        mCurrentChange.mDirty.recordCreated(item);\n    }\n\n    /** Adds the item to the current change's list of items deleted during\n     *  the transaction.\n     * @param item  The deleted item. */\n    void markItemDeleted(MailItem item) {\n        if ((item.getFlagBitmask() & Flag.BITMASK_UNCACHED) == 0)\n        mCurrentChange.mDirty.recordDeleted(item);\n    }\n\n    /** Adds the item id to the current change's list of items deleted during\n     *  the transaction.\n     * @param itemId  The deleted item's id. */\n    void markItemDeleted(byte type, int itemId) {\n        mCurrentChange.mDirty.recordDeleted(mData.accountId, itemId, type);\n    }\n\n    /** Adds the item ids to the current change's list of items deleted during\n     *  the transaction.\n     * @param typesMask Mask of all MailItem types listed in itemIds.  see {@link MailItem#typeToBitmask}a\n     * @param itemIds  The list of deleted items' ids. */\n    void markItemDeleted(int typesMask, List<Integer> itemIds) {\n        mCurrentChange.mDirty.recordDeleted(mData.accountId, itemIds, typesMask);\n    }\n\n    /** Adds the item to the current change's list of items modified during\n     *  the transaction.\n     * @param item    The modified item.\n     * @param reason  The bitmask describing the modified item properties.\n     * @see com.zimbra.cs.session.PendingModifications.Change */\n    void markItemModified(MailItem item, int reason) {\n        if ((item.getFlagBitmask() & Flag.BITMASK_UNCACHED) == 0)\n        mCurrentChange.mDirty.recordModified(item, reason);\n    }\n\n    /** Adds the object to the current change's list of non-{@link MailItem}\n     *  objects affected during the transaction.  Among these \"dirty\" items\n     *  can be:<ul>\n     *    <li>The {@link Blob} or {@link MailboxBlob} for a newly-created file.\n     *    <li>The {@link PendingDelete} holding blobs and index\n     *        entries to be cleaned up after a {@link MailItem#deletes}.\n     *    <li>The SHA1 hash of a conversation's subject stored in\n     *        {@link #mConvHashes}.</ul>\n     * \n     * @param obj  The relevant object.\n     * @see #commitCache(Mailbox.MailboxChange)\n     * @see #rollbackCache(Mailbox.MailboxChange) */\n    void markOtherItemDirty(Object obj) {\n        if (obj instanceof PendingDelete)\n            mCurrentChange.addPendingDelete((PendingDelete) obj);\n        else\n            mCurrentChange.mOtherDirtyStuff.add(obj);\n    }\n\n    /** Adds the MailItem to the current change's list of things that need\n     *  to be added to the Lucene index once the current transaction has\n     *  committed.\n     * \n     * @param item  The MailItem to be indexed.\n     * @param deleteFirst True if we need to delete this item from the index before indexing it again\n     * @param data  The list of documents to be added.  If this is NULL then indexing will be deferred for this item.\n     * @see #commitCache(Mailbox.MailboxChange) */\n    void queueForIndexing(MailItem item, boolean deleteFirst, List<org.apache.lucene.document.Document> data) throws ServiceException {\n        assert(Thread.holdsLock(this));\n\n        if (item.getIndexId() <= 0) {\n            assert(!item.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED));\n            return;\n        }\n\n        // if no data is provided then we ALWAYS batch\n        if (data != null && getBatchedIndexingCount() <= 0) {\n            if (item.getIndexId() > 0)\n                mCurrentChange.addIndexedItem(item, deleteFirst, data);\n        } else {\n            if (deleteFirst)\n                mCurrentChange.addIndexDelete(item.getId());\n            \n            if (!item.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED)) {\n                // flag not already set -- must set the bitmask\n                item.alterSystemFlag(mIndexingDeferredFlag, true);\n                incrementIndexDeferredCount(1);\n            }            \n        }\n    }\n\n\n    void incrementIndexDeferredCount(int i) {\n        assert(Thread.holdsLock(this));\n        int oldCount = mCurrentChange.idxDeferred == MailboxChange.NO_CHANGE ? mData.idxDeferredCount : mCurrentChange.idxDeferred;\n        mCurrentChange.idxDeferred = Math.max(0, oldCount + i);\n    }\n\n    /** Returns the maximum number of items to be batched in a single indexing\n     *  pass.  (If a search comes in that requires use of the index, all\n     *  pending unindexed items are immediately indexed regardless of batch\n     *  size.)  If this number is <tt>0</tt>, all items are indexed immediately\n     *  when they are added. */\n    int getBatchedIndexingCount() {\n        if (mMailboxIndex != null)\n            return mMailboxIndex.getBatchedIndexingCount();\n        else\n            return 0;\n    }\n    \n\n\n    public synchronized Connection getOperationConnection() throws ServiceException {\n        if (!mCurrentChange.isActive())\n            throw ServiceException.FAILURE(\"cannot fetch Connection outside transaction\", new Exception());\n        return mCurrentChange.getConnection();\n    }\n    private synchronized void setOperationConnection(Connection conn) throws ServiceException {\n        if (!mCurrentChange.isActive())\n            throw ServiceException.FAILURE(\"cannot set Connection outside transaction\", new Exception());\n        else if (conn == null)\n            return;\n        else if (mCurrentChange.conn != null)\n            throw ServiceException.FAILURE(\"cannot set Connection for in-progress transaction\", new Exception());\n        mCurrentChange.conn = conn;\n    }\n\n    /** Puts the Mailbox into maintenance mode.  As a side effect, disconnects\n     *  any {@link Session}s listening on this Mailbox and flushes all changes\n     *  to the search index of this Mailbox.\n     * \n     * @return A new MailboxLock token for use in a subsequent call to\n     *         {@link MailboxManager#endMaintenance(Mailbox.MailboxLock, boolean, boolean)}.\n     * @throws ServiceException MailServiceException.MAINTENANCE if the\n     *         <tt>Mailbox</tt> is already in maintenance mode. */\n    synchronized MailboxLock beginMaintenance() throws ServiceException {\n        if (mMaintenance != null)\n            throw MailServiceException.MAINTENANCE(mId);\n        ZimbraLog.mailbox.info(\"Locking mailbox %d for maintenance.\", getId());\n\n        purgeListeners();\n        if (mMailboxIndex != null)\n            mMailboxIndex.flush();\n\n        mMaintenance = new MailboxLock(mData.accountId, mId, this);\n        return mMaintenance;\n    }\n\n    synchronized void endMaintenance(boolean success) throws ServiceException {\n        if (mMaintenance == null)\n            throw ServiceException.FAILURE(\"mainbox not in maintenance mode\", null);\n        \n        if (success) {\n            ZimbraLog.mailbox.info(\"Ending maintenance on mailbox %d.\", getId());\n            mMaintenance = null;\n        } else {\n            ZimbraLog.mailbox.info(\"Ending maintenance and marking mailbox %d as unavailable.\", getId());\n            mMaintenance.markUnavailable();\n        }\n    }\n\n    void beginTransaction(String caller, OperationContext octxt) throws ServiceException {\n        beginTransaction(caller, System.currentTimeMillis(), octxt, null, null);\n    }\n    private void beginTransaction(String caller, OperationContext octxt, RedoableOp recorder) throws ServiceException {\n        long timestamp = octxt == null ? System.currentTimeMillis() : octxt.getTimestamp();\n        beginTransaction(caller, timestamp, octxt, recorder, null);\n    }\n    void beginTransaction(String caller, OperationContext octxt, RedoableOp recorder, Connection conn) throws ServiceException {\n        long timestamp = octxt == null ? System.currentTimeMillis() : octxt.getTimestamp();\n        beginTransaction(caller, timestamp, octxt, recorder, conn);\n    }\n    private void beginTransaction(String caller, long time, OperationContext octxt, RedoableOp recorder, Connection conn) throws ServiceException {\n        assert(Thread.holdsLock(this));\n        mCurrentChange.startChange(caller, octxt, recorder);\n\n        // if a Connection object was provided, use it\n        if (conn != null)\n            setOperationConnection(conn);\n\n        boolean needRedo = octxt == null || octxt.needRedo();\n        // have a single, consistent timestamp for anything affected by this operation\n        mCurrentChange.setTimestamp(time);\n        if (recorder != null && needRedo)\n            recorder.start(time);\n\n        // if the caller has specified a constraint on the range of affected items, store it\n        if (recorder != null && needRedo && octxt != null && octxt.change > 0)\n            recorder.setChangeConstraint(octxt.changetype, octxt.change);\n\n        // if we're redoing an op, preserve the old change ID\n        if (octxt != null && octxt.getChangeId() > 0)\n            setOperationChangeID(octxt.getChangeId());\n        if (recorder != null && needRedo)\n            recorder.setChangeId(getOperationChangeID());\n\n        // keep a hard reference to the item cache to avoid having it GCed during the op \n        Map<Integer, MailItem> cache = mItemCache.get();\n        if (cache == null) {\n            cache = new LinkedHashMap<Integer, MailItem>(MAX_ITEM_CACHE_WITH_LISTENERS, (float) 0.75, true);\n            mItemCache = new SoftReference<Map<Integer, MailItem>>(cache);\n            ZimbraLog.cache.debug(\"created a new MailItem cache for mailbox \" + getId());\n        }\n        mCurrentChange.itemCache = cache;\n\n        // don't permit mailbox access during maintenance\n        if (mMaintenance != null && !mMaintenance.canAccess())\n            throw MailServiceException.MAINTENANCE(mId);\n\n        // we can only start a redoable operation as the transaction's base change\n        if (recorder != null && needRedo && mCurrentChange.depth > 1)\n            throw ServiceException.FAILURE(\"cannot start a logged transaction from within another transaction\", null);\n\n        // we'll need folders and tags loaded in order to handle ACLs\n        loadFoldersAndTags();\n    }\n\n\n    /** Returns the set of configuration info for the given section.\n     *  We segment the mailbox-level configuration data into \"sections\" to\n     *  allow server applications to store their config separate from all\n     *  other apps.  (So the IMAP server could store and retrieve the\n     *  <tt>\"imap\"</tt> config section, etc.)\n     * \n     * @param octxt    The context for this request (e.g. auth user id).\n     * @param section  The config section to fetch.\n     * @perms full access to the mailbox (see {@link #hasFullAccess()})\n     * @return The {@link Metadata} representing the appropriate section's\n     *         configuration information, or <tt>null</tt> if none is\n     *         found or if the caller does not have sufficient privileges\n     *         to read the mailbox's config. */\n    public synchronized Metadata getConfig(OperationContext octxt, String section) throws ServiceException {\n        if (section == null || section.equals(\"\"))\n            return null;\n\n        // note: defaulting to true, not false...\n        boolean success = true;\n        try {\n            beginTransaction(\"getConfig\", octxt, null);\n\n            // make sure they have sufficient rights to view the config\n            if (!hasFullAccess())\n                return null;\n            if (mData.configKeys == null || !mData.configKeys.contains(section))\n                return null;\n\n            String config = DbMailbox.getConfig(this, section);\n            if (config == null)\n                return null;\n            try {\n                return new Metadata(config);\n            } catch (ServiceException e) {\n                success = false;\n                ZimbraLog.mailbox.warn(\"could not decode config metadata for section:\" + section);\n                return null;\n            }\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Sets the configuration info for the given section.  We segment the\n     *  mailbox-level configuration data into \"sections\" to allow server\n     *  applications to store their config separate from all other apps.\n     * \n     * @param octxt    The context for this request (e.g. auth user id).\n     * @param section  The config section to store.\n     * @param config   The new config data for the section.\n     * @perms full access to the mailbox (see {@link #hasFullAccess()})\n     * @throws ServiceException  The following error codes are possible:<ul>\n     *    <li><tt>service.FAILURE</tt> - if there's a database failure\n     *    <li><tt>service.PERM_DENIED</tt> - if you don't have\n     *        sufficient permissions</ul>\n     * @see #getConfig(OperationContext, String) */\n    public synchronized void setConfig(OperationContext octxt, String section, Metadata config) throws ServiceException {\n        if (section == null)\n            throw new IllegalArgumentException();\n\n        SetConfig redoPlayer = new SetConfig(mId, section, config);\n        boolean success = false;\n        try {\n            beginTransaction(\"setConfig\", octxt, redoPlayer);\n\n            // make sure they have sufficient rights to view the config\n            if (!hasFullAccess())\n                throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions\");\n\n            mCurrentChange.mDirty.recordModified(this, Change.MODIFIED_CONFIG);\n            mCurrentChange.config = new Pair<String,Metadata>(section, config);\n            DbMailbox.updateConfig(this, section, config);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    private Map<Integer, MailItem> getItemCache() throws ServiceException {\n        if (!mCurrentChange.isActive())\n            throw ServiceException.FAILURE(\"cannot access item cache outside a transaction\", null);\n        return mCurrentChange.itemCache;\n    }\n\n    private void clearItemCache() {\n        if (mCurrentChange.isActive())\n            mCurrentChange.itemCache.clear();\n        else\n            mItemCache.clear();\n    }\n\n    void cache(MailItem item) throws ServiceException {\n        if (item == null || (item.getFlagBitmask() & Flag.BITMASK_UNCACHED) != 0)\n            return;\n\n        if (item instanceof Tag) {\n            if (item instanceof Flag)\n                mFlags[((Flag) item).getIndex()] = (Flag) item;\n            if (mTagCache != null) {\n                Tag tag = (Tag) item;\n                mTagCache.put(tag.getId(), tag);\n                mTagCache.put(tag.getName().toLowerCase(), tag);\n            }\n        } else if (item instanceof Folder) {\n            if (mFolderCache != null)\n                mFolderCache.put(item.getId(), (Folder) item);\n        } else {\n            getItemCache().put(item.getId(), item);\n        }\n\n        if (ZimbraLog.cache.isDebugEnabled())\n            ZimbraLog.cache.debug(\"cached \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" in mailbox \" + getId());\n    }\n\n    protected void uncache(MailItem item) throws ServiceException {\n        if (item == null)\n            return;\n\n        if (item instanceof Tag) {\n            if (mTagCache == null)\n                return;\n            mTagCache.remove(item.getId());\n            mTagCache.remove(((Tag) item).getName().toLowerCase());\n        } else if (item instanceof Folder) {\n            if (mFolderCache == null)\n                return;\n            mFolderCache.remove(item.getId());\n        } else {\n            getItemCache().remove(item.getId());\n            MessageCache.purge(item);\n        }\n\n        if (ZimbraLog.cache.isDebugEnabled())\n            ZimbraLog.cache.debug(\"uncached \" + MailItem.getNameForType(item) + \" \" + item.getId() + \" in mailbox \" + getId());\n\n        item.uncacheChildren();\n    }\n\n    /** Removes an item from the <tt>Mailbox</tt>'s item cache.  If the\n     *  item has any children, they are also uncached.  <i>Note: This function\n     *  cannot be used to uncache {@link Tag}s and {@link Folder}s.  You must\n     *  call {@link #uncache(MailItem)} to remove those items from their\n     *  respective caches.</i>\n     * \n     * @param itemId  The id of the item to uncache */\n    void uncacheItem(Integer itemId) throws ServiceException {\n        MailItem item = getItemCache().remove(itemId);\n        if (ZimbraLog.cache.isDebugEnabled())\n            ZimbraLog.cache.debug(\"uncached item \" + itemId + \" in mailbox \" + getId());\n        if (item != null) {\n            MessageCache.purge(item);\n            item.uncacheChildren();\n        } else {\n            MessageCache.purge(this, itemId);\n        }\n    }\n\n    /** Removes all items of a specified type from the <tt>Mailbox</tt>'s\n     *  caches.  There may be some collateral damage: purging non-tag,\n     *  non-folder types will drop the entire item cache.\n     * \n     * @param type  The type of item to completely uncache.  {@link MailItem#TYPE_UNKNOWN}\n     * uncaches all items. */\n    public synchronized void purge(byte type) {\n        switch (type) {\n            case MailItem.TYPE_FOLDER:\n            case MailItem.TYPE_MOUNTPOINT:\n            case MailItem.TYPE_SEARCHFOLDER:  mFolderCache = null;  break;\n            case MailItem.TYPE_FLAG:\n            case MailItem.TYPE_TAG:           mTagCache = null;     break;\n            default:                          clearItemCache();     break;\n            case MailItem.TYPE_UNKNOWN:       mFolderCache = null;  mTagCache = null;  clearItemCache();  break;\n        }\n\n        if (ZimbraLog.cache.isDebugEnabled())\n            ZimbraLog.cache.debug(\"purged \" + MailItem.getNameForType(type) + \" cache in mailbox \" + getId());\n    }\n\n\n    /** Creates the default set of immutable system folders in a new mailbox.\n     *  These system folders have fixed ids (e.g. {@link #ID_FOLDER_INBOX})\n     *  and are hardcoded in the server:<pre>\n     *     MAILBOX_ROOT\n     *       +--Tags\n     *       +--Conversations\n     *       +--&lt;other hidden system folders>\n     *       +--USER_ROOT\n     *            +--INBOX\n     *            +--Trash\n     *            +--Sent\n     *            +--&lt;other immutable folders>\n     *            +--&lt;user-created folders></pre>\n     *  This method does <u>not</u> have hooks for inserting arbitrary folders,\n     *  tags, or messages into a new mailbox.\n     * \n     * @see Folder#create(int, Mailbox, Folder, String, byte, byte, int, byte, String) */\n    protected synchronized void initialize() throws ServiceException {\n        // the new mailbox's caches are created and the default set of tags are\n        // loaded by the earlier call to loadFoldersAndTags in beginTransaction\n\n        byte hidden = Folder.FOLDER_IS_IMMUTABLE | Folder.FOLDER_DONT_TRACK_COUNTS;\n        Folder root = Folder.create(ID_FOLDER_ROOT, this, null, \"ROOT\",     hidden, MailItem.TYPE_UNKNOWN,      0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_TAGS,          this, root, \"Tags\",          hidden, MailItem.TYPE_TAG,          0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_CONVERSATIONS, this, root, \"Conversations\", hidden, MailItem.TYPE_CONVERSATION, 0, MailItem.DEFAULT_COLOR, null);\n\n        byte system = Folder.FOLDER_IS_IMMUTABLE;\n        Folder userRoot = Folder.create(ID_FOLDER_USER_ROOT, this, root, \"USER_ROOT\", system, MailItem.TYPE_UNKNOWN, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_INBOX,    this, userRoot, \"Inbox\",    system, MailItem.TYPE_MESSAGE, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_TRASH,    this, userRoot, \"Trash\",    system, MailItem.TYPE_UNKNOWN, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_SPAM,     this, userRoot, \"Junk\",     system, MailItem.TYPE_MESSAGE, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_SENT,     this, userRoot, \"Sent\",     system, MailItem.TYPE_MESSAGE, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_DRAFTS,   this, userRoot, \"Drafts\",   system, MailItem.TYPE_MESSAGE, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_CONTACTS, this, userRoot, \"Contacts\", system, MailItem.TYPE_CONTACT, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_NOTEBOOK, this, userRoot, \"Notebook\", system, MailItem.TYPE_WIKI,    0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_CALENDAR, this, userRoot, \"Calendar\", system, MailItem.TYPE_APPOINTMENT, Flag.BITMASK_CHECKED, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_TASKS,    this, userRoot, \"Tasks\",    system, MailItem.TYPE_TASK,        Flag.BITMASK_CHECKED, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_AUTO_CONTACTS, this, userRoot, \"Emailed Contacts\", system, MailItem.TYPE_CONTACT, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_IM_LOGS,  this, userRoot, \"Chats\",    system, MailItem.TYPE_MESSAGE, 0, MailItem.DEFAULT_COLOR, null);\n        Folder.create(ID_FOLDER_BRIEFCASE, this, userRoot, \"Briefcase\", system, MailItem.TYPE_DOCUMENT, 0, MailItem.DEFAULT_COLOR, null);\n        \n\n        mCurrentChange.itemId = getInitialItemId();\n        DbMailbox.updateMailboxStats(this);\n        \n        // set the version to CURRENT\n        Metadata md = new Metadata();\n        mVersion = new MailboxVersion(MailboxVersion.CURRENT());\n        mVersion.writeToMetadata(md);\n        DbMailbox.updateConfig(this, MD_CONFIG_VERSION, md);\n    }\n\n    int getInitialItemId() { return FIRST_USER_ID; }\n\n    private void initFlags() throws ServiceException {\n        // flags will be added to mFlags array via call to cache() in MailItem constructor\n        mSentFlag      = Flag.instantiate(this, \"\\\\Sent\",       Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_FROM_ME);\n        mAttachFlag    = Flag.instantiate(this, \"\\\\Attached\",   Flag.FLAG_GENERIC,         Flag.ID_FLAG_ATTACHED);\n        mReplyFlag     = Flag.instantiate(this, \"\\\\Answered\",   Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_REPLIED);\n        mForwardFlag   = Flag.instantiate(this, \"\\\\Forwarded\",  Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_FORWARDED);\n        mCopiedFlag    = Flag.instantiate(this, \"\\\\Copied\",     Flag.FLAG_GENERIC,         Flag.ID_FLAG_COPIED);\n        mFlaggedFlag   = Flag.instantiate(this, \"\\\\Flagged\",    Flag.FLAG_GENERIC,         Flag.ID_FLAG_FLAGGED);\n        mDraftFlag     = Flag.instantiate(this, \"\\\\Draft\",      Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_DRAFT);\n        mDeletedFlag   = Flag.instantiate(this, \"\\\\Deleted\",    Flag.FLAG_GENERIC,         Flag.ID_FLAG_DELETED);\n        mNotifiedFlag  = Flag.instantiate(this, \"\\\\Notified\",   Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_NOTIFIED);\n        mUnreadFlag    = Flag.instantiate(this, \"\\\\Unread\",     Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_UNREAD);\n        mInviteFlag     = Flag.instantiate(this, \"\\\\Invite\",     Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_INVITE);\n        mUrgentFlag     = Flag.instantiate(this, \"\\\\Urgent\",     Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_HIGH_PRIORITY);\n        mIndexingDeferredFlag = Flag.instantiate(this, \"\\\\IdxDeferred\",     Flag.FLAG_GENERIC, Flag.ID_FLAG_INDEXING_DEFERRED);\n        mBulkFlag       = Flag.instantiate(this, \"\\\\Bulk\",       Flag.FLAG_IS_MESSAGE_ONLY, Flag.ID_FLAG_LOW_PRIORITY);\n        mVersionedFlag  = Flag.instantiate(this, \"\\\\Versioned\",  Flag.FLAG_GENERIC,         Flag.ID_FLAG_VERSIONED);\n\n        mSubscribedFlag = Flag.instantiate(this, \"\\\\Subscribed\", Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_SUBSCRIBED);\n        mExcludeFBFlag = Flag.instantiate(this, \"\\\\ExcludeFB\",  Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_EXCLUDE_FREEBUSY);\n        mCheckedFlag   = Flag.instantiate(this, \"\\\\Checked\",    Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_CHECKED);\n        mNoInheritFlag  = Flag.instantiate(this, \"\\\\NoInherit\",  Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_NO_INHERIT);\n        mSyncFolderFlag = Flag.instantiate(this, \"\\\\SyncFolder\", Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_SYNCFOLDER);\n        mSyncFlag\t\t= Flag.instantiate(this, \"\\\\Sync\",       Flag.FLAG_IS_FOLDER_ONLY,  Flag.ID_FLAG_SYNC);\n    }\n\n    private void loadFoldersAndTags() throws ServiceException {\n        // if the persisted mailbox sizes aren't available, we *must* recalculate\n        boolean initial = mData.contacts < 0 || mData.size < 0;\n\n        if (mFolderCache != null && mTagCache != null && !initial)\n            return;\n        ZimbraLog.cache.info(\"Initializing folder and tag caches for mailbox \" + getId());\n\n        try {\n            Map<MailItem.UnderlyingData, Long> folderData = new HashMap<MailItem.UnderlyingData, Long>();\n            Map<MailItem.UnderlyingData, Long> tagData    = new HashMap<MailItem.UnderlyingData, Long>();\n            MailboxData stats = DbMailItem.getFoldersAndTags(this, folderData, tagData, initial);\n\n            boolean persist = stats != null;\n            if (stats != null) {\n                if (mData.size != stats.size) {\n                    mCurrentChange.mDirty.recordModified(this, Change.MODIFIED_SIZE);\n                    ZimbraLog.mailbox.debug(\"setting mailbox size to \" + stats.size + \" (was \" + mData.size + \") for mailbox \" + mId);\n                    mData.size = stats.size;\n                }\n                if (mData.contacts != stats.contacts) {\n                    ZimbraLog.mailbox.debug(\"setting contact count to \" + stats.contacts + \" (was \" + mData.contacts + \") for mailbox \" + mId);\n                    mData.contacts = stats.contacts;\n                }\n                DbMailbox.updateMailboxStats(this);\n            }\n\n                mFolderCache = new HashMap<Integer, Folder>();\n                // create the folder objects and, as a side-effect, populate the new cache\n            for (Map.Entry<MailItem.UnderlyingData, Long> entry : folderData.entrySet()) {\n                Folder folder = (Folder) MailItem.constructItem(this, entry.getKey());\n                if (entry.getValue() > 0)\n                    folder.setSize(folder.getItemCount(), entry.getValue());\n            }\n                // establish the folder hierarchy\n                for (Folder folder : mFolderCache.values()) {\n                    Folder parent = mFolderCache.get(folder.getParentId());\n                    // FIXME: side effect of this is that parent is marked as dirty...\n                    if (parent != null)\n                        parent.addChild(folder);\n                    if (persist)\n                        folder.saveFolderCounts(initial);\n                }\n\n                mTagCache = new HashMap<Object, Tag>();\n                // create the tag objects and, as a side-effect, populate the new cache\n            for (MailItem.UnderlyingData ud : tagData.keySet()) {\n                    Tag tag = new Tag(this, ud);\n                    if (persist)\n                        tag.saveTagCounts();\n                }\n                // flags don't change and thus can be reused in the new cache\n                for (int i = 0; i < mFlags.length; i++) {\n                    if (mFlags[i] == null)\n                        continue;\n                    ZimbraLog.mailbox.debug(i + \": \" + mFlags[i]);\n                    cache(mFlags[i]);\n                }\n        } catch (ServiceException e) {\n            mTagCache = null;\n            mFolderCache = null;\n            throw e;\n        }\n    }\n\n    synchronized void recalculateFolderAndTagCounts() throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"recalculateFolderAndTagCounts\", null);\n\n            // force the recalculation of all folder/tag/mailbox counts and sizes\n            mTagCache = null;\n            mFolderCache = null;\n            mData.contacts = -1;\n            loadFoldersAndTags();\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void deleteMailbox() throws ServiceException {\n        deleteMailbox(null);\n    }\n\n    public synchronized void deleteMailbox(OperationContext octxt) throws ServiceException {\n        // first, throw the mailbox into maintenance mode\n        //   (so anyone else with a cached reference to the Mailbox can't use it)\n        MailboxLock lock = null;\n        try {\n            lock = MailboxManager.getInstance().beginMaintenance(mData.accountId, mId);\n        } catch (MailServiceException e) {\n            // Ignore wrong mailbox exception.  It may be thrown if we're\n            // redoing a DeleteMailbox that was interrupted when server\n            // crashed in the middle of the operation.  Database says the\n            // mailbox has been deleted, but there may be other files that\n            // still need to be cleaned up.\n            if (!MailServiceException.WRONG_MAILBOX.equals(e.getCode()))\n                throw e;\n        }\n\n        boolean needRedo = octxt == null || octxt.needRedo();\n        DeleteMailbox redoRecorder = new DeleteMailbox(mId);\n        boolean success = false;\n        try {\n            beginTransaction(\"deleteMailbox\", octxt, redoRecorder);\n            if (needRedo)\n                redoRecorder.log();\n\n            try {\n                // remove all the relevant entries from the database\n                Connection conn = getOperationConnection();\n                DbMailbox.clearMailboxContent(this);\n                DbMailbox.deleteMailbox(conn, this);\n                    \n                success = true;\n            } finally {\n                // commit the DB transaction before touching the store!  (also ends the operation)\n                endTransaction(success);\n            }\n\n            if (success) {\n                // remove all traces of the mailbox from the Mailbox cache\n                //   (so anyone asking for the Mailbox gets NO_SUCH_MBOX or creates a fresh new empty one with a different id)\n                MailboxManager.getInstance().markMailboxDeleted(this);\n\n                // attempt to nuke the store and index\n                // FIXME: we're assuming a lot about the store and index here; should use their functions\n                try {\n                    if (mMailboxIndex != null)\n                        mMailboxIndex.deleteIndex();\n                } catch (IOException iox) {\n                    ZimbraLog.mailbox.warn(\"Unable to delete index data.\", iox);\n                }\n                try {\n                    StoreManager.getInstance().deleteStore(this);\n                } catch (IOException iox) {\n                    ZimbraLog.mailbox.warn(\"Unable to delete message data.\", iox);\n                }\n\n                // twiddle the mailbox lock [must be the last command of this function!]\n                //   (so even *we* can't access this Mailbox going forward)\n                if (lock != null)\n                    lock.markUnavailable();\n            }\n        } finally {\n            if (needRedo) {\n                if (success)\n                    redoRecorder.commit();\n                else\n                    redoRecorder.abort();\n            }\n        }\n    }\n\n    public synchronized void renameMailbox(String newName) throws ServiceException {\n        renameMailbox(null, newName);\n    }\n\n    public synchronized void renameMailbox(OperationContext octxt, String newName) throws ServiceException {\n        if (newName == null || newName.length() < 1)\n            throw ServiceException.INVALID_REQUEST(\"Cannot rename mailbox to empty name\", null);\n\n        RenameMailbox redoRecorder = new RenameMailbox(mId, newName);\n        beginTransaction(\"renameMailbox\", octxt, redoRecorder);\n        boolean success = false;\n        try {\n            Connection conn = getOperationConnection();\n            DbMailbox.renameMailbox(conn, this, newName);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized MailboxVersion getVersion() { return mVersion; }\n    \n    synchronized void updateVersion(MailboxVersion vers) throws ServiceException {\n        mVersion = new MailboxVersion(vers);\n        Metadata md = getConfig(null, Mailbox.MD_CONFIG_VERSION);\n        \n        if (md == null)\n            md = new Metadata();\n        \n        mVersion.writeToMetadata(md);\n        setConfig(null, Mailbox.MD_CONFIG_VERSION, md);\n    }\n    \n    /**\n     * Status of current batched indexing operation \n     */\n    public static class BatchedIndexStatus {\n        public int mNumProcessed = 0;\n        public int mNumToProcess = 0;\n        public int mNumFailed = 0;\n        public boolean mCancel = false;\n\n        public String toString() {\n            String status = \"Completed \" + mNumProcessed + \" out of \" + mNumToProcess + \" (\" + mNumFailed + \" failures)\";\n            return (mCancel ? \"--CANCELLING--  \" : \"\") + status;\n        }\n\n        public Object clone() {\n            BatchedIndexStatus toRet = new BatchedIndexStatus();\n            toRet.mNumProcessed = mNumProcessed;\n            toRet.mNumToProcess = mNumToProcess;\n            toRet.mNumFailed = mNumFailed;\n            return toRet;\n        }\n    }\n    \n    /** Status of current reindexing operation for this mailbox, or NULL \n     *  if a re-index is not in progress. */\n    private BatchedIndexStatus mReIndexStatus = null;\n\n    public synchronized boolean isReIndexInProgress() {\n        return mReIndexStatus != null;\n    }\n\n    public synchronized BatchedIndexStatus getReIndexStatus() {\n        return mReIndexStatus;\n    }\n    \n    private static final int COMPLETED_REINDEX_CONTACTS_V1_2 = 100;\n    \n    /**\n     * Some long-running transactions (e.g. ReIndexing) might not complete while convienently in the stack\n     * of a particular caller: e.g. if the server goes down while a re-indexing is in progress, it is restarted\n     * when the server comes back up, and then completes sometime later.\n     * \n     * This function is a general purpose completion routine for handler code.\n     * \n     * This function should *NOT* throw ServiceException, since by definition there is nothing on the callstack\n     * that can properly handle the exception.  Error handling should happen in this function.\n     * \n     * @param completionId\n     */\n    synchronized void completion(int completionId) {\n        switch(completionId) {\n            case COMPLETED_REINDEX_CONTACTS_V1_2:\n                // check current version, just in case someone updated the version while\n                // we were gone\n                if (!getVersion().atLeast(1,2)) {\n                    try {\n                        updateVersion(new MailboxVersion((short)1,(short)2));\n                    } catch (ServiceException e) {\n                        ZimbraLog.mailbox.warn(\"Could not update version in Mailbox v1.2 schema upgrade.\", e);\n                    }\n                }\n                break;\n        }\n    }\n\n    /**\n     * Re-Index all items in this mailbox.  This can be a *very* expensive operation (upwards of an hour to run\n     * on a large mailbox on slow hardware).  We are careful to unlock the mailbox periodically so that the\n     * mailbox can still be accessed while the reindex is running, albeit at a slower rate.\n     * \n     * @param typesOrNull  If NULL then all items are re-indexed, otherwise only the specified types are reindexed.\n     * @param itemIdsOrNull List of ItemIDs to reindex.  If this is specified, typesOrNull MUST be null\n     * @param completionId Since this is a long-running operation (and it might conceivably be interrupted and then\n     *                              run after a server restart) the caller can pass a completionId to this function.  When the\n     *                              re-indexing has completed, the Mailbox's Completion() function is called with the passed-in\n     *                              Integer.  A value of '0' means \"don't run a completion function\".\n     * @throws ServiceException\n     */\n    public void reIndex(OperationContext octxt, Set<Byte> typesOrNull, Set<Integer> itemIdsOrNull, int completionId, boolean skipDelete) throws ServiceException {\n        ReindexMailbox redoRecorder = new ReindexMailbox(mId, typesOrNull, itemIdsOrNull, completionId, skipDelete);\n\n        long start = 0;\n        if (ZimbraLog.mailbox.isInfoEnabled()) \n            start = System.currentTimeMillis();\n        \n        if (typesOrNull != null && itemIdsOrNull != null)\n            throw ServiceException.INVALID_REQUEST(\"Must only specify one of Types, ItemIds to Mailbox.reIndex\", null);\n            \n        boolean needRedo = octxt == null || octxt.needRedo();\n\n        Collection<SearchResult> msgs = null;\n        boolean redoInitted = false;\n        boolean indexDeleted = false;\n        boolean completedOperation = false;\n\n        try {\n            //\n            // First step, with the mailbox locked: \n            //     -- get a list of all messages in the mailbox\n            //     -- delete the index\n            //\n            synchronized(this) {\n                if (isReIndexInProgress())\n                    throw ServiceException.ALREADY_IN_PROGRESS(Integer.toString(mId), mReIndexStatus.toString());\n                \n                boolean success = false;\n                try {\n                    // Don't pass redoRecorder to beginTransaction.  We have already\n                    // manually called log() on redoRecorder because this is a long-\n                    // running transaction, and we don't want endTransaction to log it\n                    // again, resulting in two entries for the same operation in redolog.\n                    beginTransaction(\"reIndex\", octxt, null);\n                    if (needRedo) {\n                        redoRecorder.start(getOperationTimestampMillis());\n                        redoRecorder.log();\n                        redoInitted = true;\n                    }\n                    \n                    DbSearchConstraints c = new DbSearchConstraints();\n                    c.mailbox = this;\n                    c.sort = DbSearch.SORT_NONE;\n                    if (itemIdsOrNull != null)\n                        c.itemIds = itemIdsOrNull; \n                    else if (typesOrNull != null)\n                        c.types = typesOrNull;\n                    \n                    msgs = new ArrayList<SearchResult>();\n                    DbSearch.search(msgs, getOperationConnection(), c, SearchResult.ExtraData.NONE);\n                    \n                    if (!skipDelete) {\n                        if (itemIdsOrNull != null || typesOrNull != null) {\n                            // NOT reindexing everything: delete manually\n                            List<Integer> toDelete = new ArrayList<Integer>(msgs.size());\n                            for (SearchResult s : msgs)\n                                toDelete.add(s.indexId);\n                            \n                            if (mMailboxIndex != null)\n                                mMailboxIndex.deleteDocuments(toDelete);\n                            indexDeleted = true;\n                        } else {\n                            // reindexing everything, just delete the index\n                            if (mMailboxIndex != null)\n                                mMailboxIndex.deleteIndex();\n                            indexDeleted = true;\n                        }\n                    }\n                    \n                    success = true;\n                } catch (IOException e) {\n                    throw ServiceException.FAILURE(\"Error deleting index before re-indexing\", e);\n                } finally {\n                    endTransaction(success);\n                }\n                mReIndexStatus = new BatchedIndexStatus();\n                mReIndexStatus.mNumToProcess = msgs.size();\n            }\n\n            indexItemList(msgs, false, mReIndexStatus);\n\n            if (ZimbraLog.mailbox.isInfoEnabled()) {\n                long end = System.currentTimeMillis();\n                long avg = 0;\n                long mps = 0;\n                if (mReIndexStatus.mNumProcessed>0) {\n                    avg = (end - start) / mReIndexStatus.mNumProcessed;\n                    mps = avg > 0 ? 1000 / avg : 0;                    \n                }\n                if (mMailboxIndex != null)\n                    mMailboxIndex.flush();\n                ZimbraLog.mailbox.info(\"Re-Indexing: Mailbox \" + getId() + \" COMPLETED.  Re-indexed \"+mReIndexStatus.mNumProcessed\n                    +\" items in \" + (end-start) + \"ms.  (avg \"+avg+\"ms/item= \"+mps+\" items/sec)\"\n                    +\" (\"+mReIndexStatus.mNumFailed+\" failed)\");\n            }\n            \n            if (completionId > 0)\n                completion(completionId);\n            \n            completedOperation = true;\n            \n        } finally {\n            mReIndexStatus = null;\n\n            try {\n                if (mMailboxIndex != null)\n                    mMailboxIndex.flush();\n            } finally {\n                if (redoInitted) {\n                    if (completedOperation || indexDeleted) {\n                        // there's no meaningful way to roll this transaction back once data is deleted.\n                        // Sooo, always commit it I guess....right?\n                        //\n                        // The failure mode is if some or all the messages don't re-index.  Right now we expect\n                        // some failures, catch them, and ignore....maybe we need to return some error code to the \n                        // caller if the number of failures is nonzero...or maybe even a list of failed messages?\n                        //\n                        // TODO think about this some more...\n                        redoRecorder.commit();\n                    } else {\n                        redoRecorder.abort();\n                    }\n                }\n            }\n        }\n    }\n\n    /** Recalculates the size, metadata, etc. for an existing MailItem and\n     *  persists that information to the database.  Maintains any existing\n     *  mutable metadata.  Updates mailbox and folder sizes appropriately.\n     * \n     * @param id    The item ID of the MailItem to reanalyze.\n     * @param type  The item's type (e.g. {@link MailItem#TYPE_MESSAGE}).\n     * @param data  The (optional) extra item data for indexing (e.g.\n     *              a Message's {@link ParsedMessage}. */\n    synchronized void reanalyze(int id, byte type, Object data) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"reanalyze\", null);\n            MailItem item = getItemById(null, id, type);\n            item.reanalyze(data);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    /** Returns the access rights that the user has been granted on this\n     *  item.  The owner of the {@link Mailbox} has all rights on all items\n     *  in the Mailbox, as do all admin accounts.  All other users must be\n     *  explicitly granted access.  <i>(Tag sharing and negative rights not\n     *  yet implemented.)</i>  This operation will succeed even if the\n     *  authenticated user from the {@link Mailbox.OperationContext} does\n     *  not have {@link ACL#RIGHT_READ} on the requested item.<p>\n     * \n     *  If you want to know if an account has {@link ACL#RIGHT_WRITE} on an\n     *  item, call<pre>\n     *    (mbox.getEffectivePermissions(new OperationContext(acct), itemId) &\n     *         ACL.RIGHT_WRITE) != 0</pre>\n     * \n     * @param octxt    The context (authenticated user, redo player, other\n     *                 constraints) under which this operation is executed.\n     * @param itemId   The item whose permissions we need to query.\n     * @param type     The item's type, or {@link MailItem#TYPE_UNKNOWN}.\n     * @return An OR'ed-together set of rights, e.g. {@link ACL#RIGHT_READ}\n     *         and {@link ACL#RIGHT_INSERT}.\n     * @throws ServiceException   The following error codes are possible:<ul>\n     *    <li><tt>mail.NO_SUCH_ITEM</tt> - the specified item does not\n     *        exist\n     *    <li><tt>service.FAILURE</tt> - if there's a database failure,\n     *        LDAP error, or other internal error</ul>\n     * @see ACL\n     * @see MailItem#checkRights(short, Account, boolean) */\n    public synchronized short getEffectivePermissions(OperationContext octxt, int itemId, byte type) throws ServiceException {\n        // fetch the item outside the transaction so we get it even if the\n        //   authenticated user doesn't have read permissions on it\n        MailItem item = getItemById(null, itemId, type);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"getEffectivePermissions\", octxt);\n            // use ~0 to query *all* rights; may need to change this when we do negative rights\n            short rights = item.checkRights((short) ~0, getAuthenticatedAccount(), isUsingAdminPrivileges());\n            success = true;\n            return rights;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns whether this type of {@link MailItem} is definitely preloaded\n     *  in one of the <tt>Mailbox</tt>'s caches.\n     * \n     * @param type  The type of <tt>MailItem</tt>.\n     * @return <tt>true</tt> if the item is a {@link Folder} or {@link Tag}\n     *         or one of their subclasses.\n     * @see #mTagCache\n     * @see #mFolderCache */\n    public static boolean isCachedType(byte type) {\n        return type == MailItem.TYPE_FOLDER || type == MailItem.TYPE_SEARCHFOLDER ||\n               type == MailItem.TYPE_TAG    || type == MailItem.TYPE_FLAG ||\n               type == MailItem.TYPE_MOUNTPOINT;\n    }\n\n    private <T extends MailItem> T checkAccess(T item) throws ServiceException {\n        if (item == null || item.canAccess(ACL.RIGHT_READ))\n            return item;\n        throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions\");\n    }\n\n    /**\n     * Returns the <tt>MailItem</tt> with the specified id. \n     * @throws NoSuchItemException if the item does not exist\n     */\n    public synchronized MailItem getItemById(OperationContext octxt, int id, byte type) throws ServiceException {\n        boolean success = false;\n        try {\n            // tag/folder caches are populated in beginTransaction...\n            beginTransaction(\"getItemById\", octxt);\n            MailItem item = checkAccess(getItemById(id, type));\n            success = true;\n            return item;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    MailItem getItemById(int id, byte type) throws ServiceException {\n        // try the cache first\n        MailItem item = getCachedItem(new Integer(id), type);\n        if (item != null)\n            return item;\n\n        // the tag and folder caches contain ALL tags and folders, so cache miss == doesn't exist\n        if (isCachedType(type))\n            throw MailItem.noSuchItem(id, type);\n\n        if (id <= -FIRST_USER_ID) {\n            // special-case virtual conversations\n            if (type != MailItem.TYPE_CONVERSATION && type != MailItem.TYPE_UNKNOWN)\n                throw MailItem.noSuchItem(id, type);\n            Message msg = getCachedMessage(new Integer(-id));\n            if (msg == null)\n                msg = getMessageById(-id);\n            if (msg.getConversationId() != id)\n                return msg.getParent();\n            else\n                item = new VirtualConversation(this, msg);\n        } else {\n            // cache miss, so fetch from the database\n            item = MailItem.getById(this, id, type);\n        }\n        return item;\n    }\n\n    /**\n     * Returns <tt>MailItem</tt>s with the specified ids. \n     * @throws NoSuchItemException any item does not exist\n     */\n    public synchronized MailItem[] getItemById(OperationContext octxt, Collection<Integer> ids, byte type) throws ServiceException {\n        return getItemById(octxt, ArrayUtil.toIntArray(ids), type);\n    }\n\n    /**\n     * Returns <tt>MailItem</tt>s with the specified ids. \n     * @throws NoSuchItemException any item does not exist\n     */\n    public synchronized MailItem[] getItemById(OperationContext octxt, int[] ids, byte type) throws ServiceException {\n        boolean success = false;\n        try {\n            // tag/folder caches are populated in beginTransaction...\n            beginTransaction(\"getItemById[]\", octxt);\n            MailItem[] items = getItemById(ids, type);\n            // make sure all those items are visible...\n            for (int i = 0; i < items.length; i++)\n                checkAccess(items[i]);\n            success = true;\n            return items;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    MailItem[] getItemById(Collection<Integer> ids, byte type) throws ServiceException {\n        return getItemById(ArrayUtil.toIntArray(ids), type);\n    }\n\n    MailItem[] getItemById(int[] ids, byte type) throws ServiceException {\n        if (!mCurrentChange.active)\n            throw ServiceException.FAILURE(\"must be in transaction\", null);\n        if (ids == null)\n            return null;\n\n        MailItem items[] = new MailItem[ids.length];\n        Set<Integer> uncached = new HashSet<Integer>();\n\n        // try the cache first\n        Integer miss = null;\n        boolean relaxType = false;\n        for (int i = 0; i < ids.length; i++) {\n            // special-case -1 as a signal to return null...\n            if (ids[i] == ID_AUTO_INCREMENT) {\n                items[i] = null;\n            } else {\n                Integer key = ids[i];\n                MailItem item = getCachedItem(key, type);\n                // special-case virtual conversations\n                if (item == null && ids[i] <= -FIRST_USER_ID) {\n                    if (!MailItem.isAcceptableType(type, MailItem.TYPE_CONVERSATION))\n                        throw MailItem.noSuchItem(ids[i], type);\n                    Message msg = getCachedMessage(key = -ids[i]);\n                    if (msg != null) {\n                        if (msg.getConversationId() == ids[i])\n                            item = new VirtualConversation(this, msg);\n                    } else {\n                        relaxType = true;\n                    }\n                }\n                items[i] = item;\n                if (item == null)\n                    uncached.add(miss = key);\n            }\n        }\n        if (uncached.isEmpty())\n            return items;\n\n        // the tag and folder caches contain ALL tags and folders, so cache miss == doesn't exist\n        if (isCachedType(type))\n            throw MailItem.noSuchItem(miss.intValue(), type);\n\n        // cache miss, so fetch from the database\n        MailItem.getById(this, uncached, relaxType ? MailItem.TYPE_UNKNOWN : type);\n\n        uncached.clear();\n        for (int i = 0; i < ids.length; i++)\n            if (ids[i] != ID_AUTO_INCREMENT && items[i] == null) {\n                if (ids[i] <= -FIRST_USER_ID) {\n                    // special-case virtual conversations\n                    MailItem item = getCachedItem(-ids[i]);\n                    if (!(item instanceof Message))\n                        throw MailItem.noSuchItem(ids[i], type);\n                    else if (item.getParentId() == ids[i])\n                        items[i] = new VirtualConversation(this, (Message) item);\n                    else {\n                        items[i] = getCachedItem(item.getParentId());\n                        if (items[i] == null)\n                            uncached.add(item.getParentId());\n                    }\n                } else\n                    if ((items[i] = getCachedItem(ids[i])) == null)\n                        throw MailItem.noSuchItem(ids[i], type);\n            }\n\n        // special case asking for VirtualConversation but having it be a real Conversation\n        if (!uncached.isEmpty()) {\n            MailItem.getById(this, uncached, MailItem.TYPE_CONVERSATION);\n            for (int i = 0; i < ids.length; i++)\n                if (ids[i] <= -FIRST_USER_ID && items[i] == null) {\n                    MailItem item = getCachedItem(-ids[i]);\n                    if (!(item instanceof Message) || item.getParentId() == ids[i])\n                        throw ServiceException.FAILURE(\"item should be cached but is not: \" + -ids[i], null);\n                    items[i] = getCachedItem(item.getParentId());\n                    if (items[i] == null)\n                        throw MailItem.noSuchItem(ids[i], type);\n                }\n        }\n\n        return items;\n    }\n\n    /** retrieve an item from the Mailbox's caches; return null if no item found */\n    MailItem getCachedItem(Integer key) throws ServiceException {\n        MailItem item = null;\n        if (mTagCache != null)\n            item = mTagCache.get(key);\n        if (item == null && mFolderCache != null)\n            item = mFolderCache.get(key);\n        if (item == null)\n            item = getItemCache().get(key);\n\n        logCacheActivity(key, item == null ? MailItem.TYPE_UNKNOWN : item.getType(), item);\n        return item;\n    }\n\n    MailItem getCachedItem(Integer key, byte type) throws ServiceException {\n        MailItem item = null;\n        switch (type) {\n            case MailItem.TYPE_UNKNOWN:\n                return getCachedItem(key);\n            case MailItem.TYPE_FLAG:\n            case MailItem.TYPE_TAG:\n                if (mTagCache != null)\n                    item = mTagCache.get(key);\n                break;\n            case MailItem.TYPE_MOUNTPOINT:\n            case MailItem.TYPE_SEARCHFOLDER:\n            case MailItem.TYPE_FOLDER:\n                if (mFolderCache != null)\n                    item = mFolderCache.get(key);\n                break;\n            default:\n                item = getItemCache().get(key);\n            break;\n        }\n\n        if (item != null && !MailItem.isAcceptableType(type, item.mData.type))\n            item = null;\n\n        logCacheActivity(key, type, item);\n        return item;\n    }\n\n    public synchronized MailItem getItemFromUnderlyingData(MailItem.UnderlyingData data) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getItemFromUd\", null);\n//            data.flags |= Flag.BITMASK_UNCACHED;\n            MailItem item = getItem(data);\n            success = true;\n            return item;\n        } finally {\n            endTransaction(success);\n//            data.flags &= ~Flag.BITMASK_UNCACHED;\n        }\n    }\n\n    /** translate from the DB representation of an item to its Mailbox abstraction */\n    MailItem getItem(MailItem.UnderlyingData data) throws ServiceException {\n        if (data == null)\n            return null;\n        MailItem item = getCachedItem(data.id, data.type);\n        // XXX: should we sanity-check the cached version to make sure all the data matches?\n        if (item != null)\n            return item;\n        return MailItem.constructItem(this, data);\n    }\n\n    /** Returns a current or past revision of an item.  Item version numbers\n     *  are 1-based and incremented each time the \"content\" of the item changes\n     *  (e.g. editing a draft, modifying a contact's fields).  If the requested\n     *  revision does not exist, either because the version number is out of\n     *  range or because the requested revision has not been retained, returns\n     *  <tt>null</tt>. */\n    public synchronized MailItem getItemRevision(OperationContext octxt, int id, byte type, int version) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getItemRevision\", octxt);\n            MailItem revision = checkAccess(getItemById(id, type)).getRevision(version);\n\n            success = true;\n            return revision;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns a {@link List} containing all available revisions of an item,\n     *  both current and past.  These revisions are returned in increasing\n     *  order of their 1-based \"version\", with the current revision always\n     *  present and listed last. */\n    public synchronized List<MailItem> getAllRevisions(OperationContext octxt, int id, byte type) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getAllRevisions\", octxt);\n            MailItem item = checkAccess(getItemById(id, type));\n            List<MailItem> revisions = new ArrayList<MailItem>(item.loadRevisions());\n            revisions.add(item);\n\n            success = true;\n            return revisions;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * Fetches a <tt>MailItem</tt> by its IMAP id.\n     * @throws MailServiceException if there is no <tt>MailItem</tt> with the given id.\n     * @see MailServiceException#NO_SUCH_ITEM\n     */\n    public synchronized MailItem getItemByImapId(OperationContext octxt, int imapId, int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            // tag/folder caches are populated in beginTransaction...\n            beginTransaction(\"getItemByImapId\", octxt);\n\n            MailItem item = checkAccess(getCachedItem(imapId));\n            // in general, the item will not have been moved and its id will be the same as its IMAP id.\n            if (item == null) {\n                try {\n                    item = checkAccess(MailItem.getById(this, imapId));\n                    if (item.getImapUid() != imapId)\n                        item = null;\n                } catch (NoSuchItemException nsie) { }\n            }\n            // if it's not found, we have to search on the non-indexed IMAP_ID column...\n            if (item == null)\n                item = checkAccess(MailItem.getByImapId(this, imapId, folderId));\n\n            if (isCachedType(item.getType()) || item.getImapUid() != imapId || item.getFolderId() != folderId)\n                throw MailServiceException.NO_SUCH_ITEM(imapId);\n            success = true;\n            return item;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Fetches an item by path relative to {@link #ID_FOLDER_USER_ROOT}.\n     * @see #getItemByPath(OperationContext, String, int) */\n    public synchronized MailItem getItemByPath(OperationContext octxt, String path) throws ServiceException {\n        return getItemByPath(octxt, path, ID_FOLDER_USER_ROOT);\n    }\n\n    /** Fetches an item by path.  If the path begins with <tt>/</tt>, it's\n     *  considered an absolute path relative to {@link #ID_FOLDER_USER_ROOT}.\n     *  If it doesn't, it's computed relative to the passed-in folder ID.<p>\n     *  \n     *  This can return anything with a name; at present, that is limited to\n     *  {@link Folder}s, {@link Tag}s, and {@link Document}s. */\n    public synchronized MailItem getItemByPath(OperationContext octxt, String name, int folderId) throws ServiceException {\n        if (name == null || name.equals(\"\"))\n            return getFolderById(octxt, folderId);\n\n        if (name.equals(\"/\"))\n        \treturn getFolderById(octxt, ID_FOLDER_USER_ROOT);\n        \n        if (name.startsWith(\"/\")) {\n            folderId = ID_FOLDER_USER_ROOT;\n            name = name.substring(1);\n        }\n        if (name.endsWith(\"/\"))\n            name = name.substring(0, name.length() - 1);\n\n        Folder parent = getFolderById(null, folderId);\n        boolean success = false;\n        try {\n            // tag/folder caches are populated in beginTransaction...\n            beginTransaction(\"getItemByName\", octxt);\n\n            int slash = name.lastIndexOf('/');\n            if (slash != -1) {\n                for (String segment : name.substring(0, slash).split(\"/\"))\n                    if ((parent = parent.findSubfolder(segment)) == null)\n                        throw MailServiceException.NO_SUCH_FOLDER(name);\n                name = name.substring(slash + 1);\n            }\n\n            MailItem item = null;\n            if (folderId == ID_FOLDER_TAGS) {\n                item = getTagByName(name);\n            } else {\n                // check for the specified item -- folder first, then document\n                item = parent.findSubfolder(name);\n                if (item == null) {\n                    checkAccess(parent);\n                    item = getItem(DbMailItem.getByName(this, parent.getId(), name, MailItem.TYPE_DOCUMENT));\n                }\n            }\n            // make sure the item is visible to the requester\n            if (checkAccess(item) == null)\n                throw MailServiceException.NO_SUCH_ITEM(name);\n            success = true;\n            return item;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns all the MailItems of a given type, optionally in a specified folder */\n    public synchronized List<MailItem> getItemList(OperationContext octxt, byte type) throws ServiceException {\n        return getItemList(octxt, type, -1);\n    }\n\n    public synchronized List<MailItem> getItemList(OperationContext octxt, byte type, int folderId) throws ServiceException {\n        return getItemList(octxt, type, folderId, DbSearch.SORT_NONE);\n    }\n\n    public synchronized List<MailItem> getItemList(OperationContext octxt, byte type, int folderId, byte sort) throws ServiceException {\n        if (type == MailItem.TYPE_UNKNOWN)\n            return Collections.emptyList();\n        List<MailItem> result = new ArrayList<MailItem>();\n\n        boolean success = false;\n        try {\n            // tag/folder caches are populated in beginTransaction...\n            beginTransaction(\"getItemList\", octxt);\n\n            Folder folder = folderId == -1 ? null : getFolderById(folderId);\n\n            if (folder == null) {\n                if (!hasFullAccess())\n                    throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions\");\n            } else {\n                if (!folder.canAccess(ACL.RIGHT_READ, getAuthenticatedAccount(), isUsingAdminPrivileges()))\n                    throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions\");\n            }\n\n            if (type == MailItem.TYPE_TAG) {\n                if (folderId != -1 && folderId != ID_FOLDER_TAGS)\n                    return Collections.emptyList();\n                for (Map.Entry<Object, Tag> entry : mTagCache.entrySet())\n                    if (entry.getKey() instanceof String)\n                        result.add(entry.getValue());\n                Comparator<MailItem> comp = MailItem.getComparator(sort);\n                if (comp != null)\n                    Collections.sort(result, comp);\n                success = true;\n            } else if (type == MailItem.TYPE_FOLDER || type == MailItem.TYPE_SEARCHFOLDER || type == MailItem.TYPE_MOUNTPOINT) {\n                for (Folder subfolder : mFolderCache.values())\n                    if (subfolder.getType() == type)\n                        if (folder == null || subfolder.getParentId() == folderId)\n                            result.add(subfolder);\n                Comparator<MailItem> comp = MailItem.getComparator(sort);\n                if (comp != null)\n                    Collections.sort(result, comp);\n                success = true;\n            } else {\n                List<MailItem.UnderlyingData> dataList = null;\n                if (folder != null)\n                    dataList = DbMailItem.getByFolder(folder, type, sort);\n                else\n                    dataList = DbMailItem.getByType(this, type, sort);\n                if (dataList == null)\n                    return Collections.emptyList();\n                for (MailItem.UnderlyingData data : dataList)\n                    if (data != null)\n                        result.add(getItem(data));\n                \t// except for sort == SORT_BY_NAME_NAT,\n                // sort was already done by the DbMailItem call...\n            \tif ((sort & DbSearch.SORT_BY_NAME_NATURAL_ORDER) > 0)\n                    Collections.sort(result, MailItem.getComparator(sort));\n                success = true;\n            }\n        } finally {\n            endTransaction(success);\n        }\n        return result;\n    }\n\n    /** returns the list of IDs of items of the given type in the given folder \n     * @param octxt TODO*/\n    public synchronized List<Integer> listItemIds(OperationContext octxt, byte type, int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"listItemIds\", octxt);\n\n            Folder folder = getFolderById(folderId);\n            List<Integer> ids = DbMailItem.listByFolder(folder, type, true);\n            success = true;\n            return ids;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized TypedIdList getItemIds(OperationContext octxt, int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"listAllItemIds\", octxt);\n\n            Folder folder = getFolderById(folderId);\n            TypedIdList ids = DbMailItem.listByFolder(folder, true);\n            success = true;\n            return ids;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized List<ImapMessage> openImapFolder(OperationContext octxt, int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"openImapFolder\", octxt);\n\n            Folder folder = getFolderById(folderId);\n            List<ImapMessage> i4list = DbMailItem.loadImapFolder(folder);\n            success = true;\n            return i4list;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<Pop3Message> openPop3Folder(OperationContext octxt, int folderId, Date popSince) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"openPop3Folder\", octxt);\n\n            Folder folder = getFolderById(folderId);\n            List<Pop3Message> p3list = DbMailItem.loadPop3Folder(folder, popSince);\n            success = true;\n            return p3list;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized int countImapRecent(OperationContext octxt, int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"openImapFolder\", octxt);\n\n            Folder folder = checkAccess(getFolderById(folderId));\n            int recent = DbMailItem.countImapRecent(folder);\n            success = true;\n            return recent;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized void beginTrackingImap() throws ServiceException {\n        if (isTrackingImap())\n            return;\n\n        TrackImap redoRecorder = new TrackImap(mId);\n        boolean success = false;\n        try {\n            beginTransaction(\"beginTrackingImap\", null, redoRecorder);\n\n            DbMailbox.startTrackingImap(this);\n            mCurrentChange.imap = Boolean.TRUE;\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void beginTrackingSync() throws ServiceException {\n        if (isTrackingSync())\n            return;\n\n        TrackSync redoRecorder = new TrackSync(mId);\n        boolean success = false;\n        try {\n            beginTransaction(\"beginTrackingSync\", null, redoRecorder);\n\n            DbMailbox.startTrackingSync(this);\n            mCurrentChange.sync = getLastChangeID();\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void recordImapSession(int folderId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"recordImapSession\", null);\n            getFolderById(folderId).checkpointRECENT();\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized List<Integer> listTombstones(int lastSync) throws ServiceException {\n        return getTombstones(lastSync).getAll();\n    }\n\n    public synchronized TypedIdList getTombstones(int lastSync) throws ServiceException {\n        if (!isTrackingSync())\n            throw ServiceException.FAILURE(\"not tracking sync\", null);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"getTombstones\", null);\n            TypedIdList tombstones = DbMailItem.readTombstones(this, lastSync);\n            success = true;\n            return tombstones;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<Folder> getModifiedFolders(final int lastSync) throws ServiceException {\n        return getModifiedFolders(lastSync, MailItem.TYPE_UNKNOWN);\n    }\n\n    public synchronized List<Folder> getModifiedFolders(final int lastSync, final byte type) throws ServiceException {\n        if (lastSync >= getLastChangeID())\n            return Collections.emptyList();\n\n        List<Folder> modified = new ArrayList<Folder>();\n        boolean success = false;\n        try {\n            beginTransaction(\"getModifiedFolders\", null);\n            for (Folder subfolder : getFolderById(ID_FOLDER_ROOT).getSubfolderHierarchy()) {\n                if (type == MailItem.TYPE_UNKNOWN || subfolder.getType() == type)\n                    if (subfolder.getModifiedSequence() > lastSync)\n                        modified.add(subfolder);\n            }\n            success = true;\n            return modified;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<Tag> getModifiedTags(OperationContext octxt, int lastSync) throws ServiceException {\n        if (lastSync >= getLastChangeID())\n            return Collections.emptyList();\n\n        List<Tag> modified = new ArrayList<Tag>();\n        boolean success = false;\n        try {\n            beginTransaction(\"getModifiedTags\", octxt);\n            if (hasFullAccess()) {\n                for (Map.Entry<Object, Tag> entry : mTagCache.entrySet())\n                    if (entry.getKey() instanceof String) {\n                        Tag tag = entry.getValue();\n                        if (tag.getModifiedSequence() > lastSync && !(tag instanceof Flag))\n                            modified.add(tag);\n                    }\n            }\n            success = true;\n            return modified;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns the IDs of all items modified since a given change number.\n     *  Will not return modified folders or tags; for these you need to call\n     *  {@link #getModifiedFolders(long, byte)} or\n     *  {@link #getModifiedTags(OperationContext, long)}.  Modified items not\n     *  visible to the caller (i.e. the caller lacks {@link ACL#RIGHT_READ})\n     *  are returned in a separate Integer List in the returned Pair.\n     *  \n     * @param octxt     The context for this request (e.g. auth user id).\n     * @param lastSync  We return items with change ID larger than this value.\n     * @return A {@link Pair} containing:<ul>\n     *         <li>a List of the IDs of all caller-visible MailItems of the\n     *             given type modified since the checkpoint, and\n     *         <li>a List of the IDs of all items modified since the checkpoint\n     *             but not currently visible to the caller</ul> */\n    public synchronized Pair<List<Integer>,TypedIdList> getModifiedItems(OperationContext octxt, int lastSync) throws ServiceException {\n        return getModifiedItems(octxt, lastSync, MailItem.TYPE_UNKNOWN, null);\n    }\n\n    /** Returns the IDs of all items of the given type modified since a given\n     *  change number.  Will not return modified folders or tags; for these\n     *  you need to call {@link #getModifiedFolders(long, byte)} or\n     *  {@link #getModifiedTags(OperationContext, long)}.  Modified items not\n     *  visible to the caller (i.e. the caller lacks {@link ACL#RIGHT_READ})\n     *  are returned in a separate Integer List in the returned Pair.  When\n     *  <tt>type</tt> is {@link MailItem#TYPE_UNKNOWN}, all modified non-\n     *  tag, non-folders are returned.\n     *  \n     * @param octxt     The context for this request (e.g. auth user id).\n     * @param lastSync  We return items with change ID larger than this value.\n     * @param type      The type of MailItems to return.\n     * @return A {@link Pair} containing:<ul>\n     *         <li>a List of the IDs of all caller-visible MailItems of the\n     *             given type modified since the checkpoint, and\n     *         <li>a List of the IDs of all items of the given type modified\n     *             since the checkpoint but not currently visible to the\n     *             caller</ul> */\n    public synchronized Pair<List<Integer>,TypedIdList> getModifiedItems(OperationContext octxt, int lastSync, byte type) throws ServiceException {\n        return getModifiedItems(octxt, lastSync, type, null);\n    }\n\n    private static final List<Integer> EMPTY_ITEMS = Collections.emptyList();\n\n    public synchronized Pair<List<Integer>,TypedIdList> getModifiedItems(OperationContext octxt, int lastSync, byte type, Set<Integer> folderIds) throws ServiceException {\n        if (lastSync >= getLastChangeID())\n            return new Pair<List<Integer>,TypedIdList>(EMPTY_ITEMS, new TypedIdList());\n\n        boolean success = false;\n        try {\n            beginTransaction(\"getModifiedItems\", octxt);\n\n            Set<Integer> visible = getVisibleFolderIds();\n            if (folderIds == null)\n                folderIds = visible;\n            else if (visible != null)\n                folderIds = SetUtil.intersect(folderIds, visible);\n\n            Pair<List<Integer>,TypedIdList> dataList = DbMailItem.getModifiedItems(this, type, lastSync, folderIds);\n            if (dataList == null)\n                return null;\n            success = true;\n            return dataList;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns a list of all <code>Folder</code>s the authenticated user has\n     *  {@link ACL#RIGHT_READ} access to.  Returns <tt>null</tt> if the\n     *  authenticated user has read access to the entire Mailbox. */\n    public synchronized Set<Folder> getVisibleFolders(OperationContext octxt) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getVisibleFolders\", octxt);\n            Set<Folder> visible = getVisibleFolders();\n            success = true;\n            return visible;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns a list of all <code>Folder</code>s that the authenticated user\n     *  from the current transaction has {@link ACL#RIGHT_READ} access to.\n     *  Returns <tt>null</tt> if the authenticated user has read access to\n     *  the entire Mailbox. */\n    Set<Folder> getVisibleFolders() throws ServiceException {\n        return getAccessibleFolders(ACL.RIGHT_READ);\n    }\n\n    /** Returns a list of all <code>Folder</code>s that the authenticated user\n     *  from the current transaction has a certain set of rights on.  Returns\n     *  <tt>null</tt> if the authenticated user has the required access on the\n     *  entire Mailbox.\n     * @param rights  The bitmask representing the required permissions. */\n    Set<Folder> getAccessibleFolders(short rights) throws ServiceException {\n        if (!mCurrentChange.isActive())\n            throw ServiceException.FAILURE(\"cannot get visible hierarchy outside transaction\", null);\n        if (hasFullAccess())\n            return null;\n\n        boolean incomplete = false;\n        Set<Folder> visible = new HashSet<Folder>();\n        for (Folder folder : mFolderCache.values())\n            if (folder.canAccess(rights))\n                visible.add(folder);\n            else\n                incomplete = true;\n        return incomplete ? visible : null;\n    }\n\n    /** Returns a list of the IDs of all <code>Folder</code>s that the\n     *  current transaction's authenticated user has {@link ACL#RIGHT_READ}\n     *  access on.  Returns <tt>null</tt> if the authenticated user has read\n     *  access on the entire Mailbox. */\n    Set<Integer> getVisibleFolderIds() throws ServiceException {\n        Set<Folder> folders = getVisibleFolders();\n        if (folders == null)\n            return null;\n        Set<Integer> visible = new HashSet<Integer>(folders.size());\n        for (Folder folder : folders)\n            visible.add(folder.getId());\n        return visible;\n    }\n\n\n    public synchronized Flag getFlagById(int id) throws ServiceException {\n        // assume that flags are numbered from -1 to -mFlags.length\n        Flag flag = null;\n        if (id < 0 && id >= -mFlags.length)\n            flag = mFlags[-id - 1];\n        if (flag == null)\n            throw MailServiceException.NO_SUCH_TAG(id);\n        checkAccess(flag);\n        return flag;\n    }\n\n    public synchronized Tag getTagById(OperationContext octxt, int id) throws ServiceException {\n        return (Tag) getItemById(octxt, id, MailItem.TYPE_TAG);\n    }\n\n    Tag getTagById(int id) throws ServiceException {\n        return (Tag) getItemById(id, MailItem.TYPE_TAG);\n    }\n\n    public synchronized List<Tag> getTagList(OperationContext octxt) throws ServiceException {\n        List<Tag> tags = new ArrayList<Tag>();\n        for (MailItem item : getItemList(octxt, MailItem.TYPE_TAG))\n            tags.add((Tag) item);\n        return tags;\n    }\n\n    public synchronized Tag getTagByName(String name) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getTagByName\", null);\n\n            if (name == null || name.equals(\"\"))\n                throw ServiceException.INVALID_REQUEST(\"tag name may not be null\", null);\n            Tag tag = mTagCache.get(name.toLowerCase());\n            if (tag == null)\n                throw MailServiceException.NO_SUCH_TAG(name);\n            checkAccess(tag);\n            success = true;\n            return tag;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    /** Returns the folder with the specified id.\n     * @throws NoSuchItemException if the folder does not exist */\n    public synchronized Folder getFolderById(OperationContext octxt, int id) throws ServiceException {\n        return (Folder) getItemById(octxt, id, MailItem.TYPE_FOLDER);\n    }\n    \n    /** Returns the folder with the specified id.\n     * @throws NoSuchItemException if the folder does not exist */\n    protected Folder getFolderById(int id) throws ServiceException {\n        return (Folder) getItemById(id, MailItem.TYPE_FOLDER);\n    }\n    \n    /** Returns the folder with the specified parent and name.\n     * @throws NoSuchItemException if the folder does not exist */\n    public synchronized Folder getFolderByName(OperationContext octxt, int parentId, String name) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getFolderByName\", octxt);\n            Folder folder = getFolderById(parentId).findSubfolder(name);\n            if (folder == null)\n                throw MailServiceException.NO_SUCH_FOLDER(name);\n            if (!folder.canAccess(ACL.RIGHT_READ))\n                throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions on folder \" + name);\n            success = true;\n            return folder;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns the folder with the specified path, delimited by slashes (<tt>/</tt>).\n     * @throws {@link NoSuchItemException} if the folder does not exist */\n    public synchronized Folder getFolderByPath(OperationContext octxt, String name) throws ServiceException {\n        if (name == null)\n            throw MailServiceException.NO_SUCH_FOLDER(name);\n        while (name.startsWith(\"/\"))\n            name = name.substring(1);                         // strip off the optional leading \"/\"\n        while (name.endsWith(\"/\"))\n            name = name.substring(0, name.length() - 1);      // strip off the optional trailing \"/\"\n\n        Folder folder = getFolderById(null, ID_FOLDER_USER_ROOT);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"getFolderByPath\", octxt);\n            if (!name.equals(\"\")) {\n                for (String segment : name.split(\"/\"))\n                    if ((folder = folder.findSubfolder(segment)) == null)\n                        break;\n            }\n\n            if (folder == null)\n                throw MailServiceException.NO_SUCH_FOLDER(\"/\" + name);\n            if (!folder.canAccess(ACL.RIGHT_READ))\n                throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions on folder /\" + name);\n            success = true;\n            return folder;\n        } finally {\n            endTransaction(success);\n        }\n    }\n    \n    /**\n     * Given a path, resolves as much of the path as possible and returns the folder and the unmatched part.\n     * \n     * E.G. if the path is \"/foo/bar/baz/gub\" and this mailbox has a Folder at \"/foo/bar\" -- this API returns\n     * a Pair containing that Folder and the unmatched part \"baz/gub\".  \n     * \n     * If the returned folder is a Mountpoint, then it can be assumed that the remaining part is a subfolder in\n     * the remote mailbox.\n     * \n     * @param octxt\n     * @param startingFolderId Folder to start from (pass Mailbox.ID_FOLDER_ROOT to start from the root)\n     * @param path \n     * @return\n     * @throws ServiceException\n     */\n    public synchronized Pair<Folder, String> getFolderByPathLongestMatch(OperationContext octxt, int startingFolderId, String path) throws ServiceException {\n        if (path == null)\n            throw MailServiceException.NO_SUCH_FOLDER(path);\n        while (path.startsWith(\"/\"))\n            path = path.substring(1);                         // strip off the optional leading \"/\"\n        while (path.endsWith(\"/\"))\n            path = path.substring(0, path.length() - 1);      // strip off the optional trailing \"/\"\n\n        if (path.length() == 0)\n            throw MailServiceException.NO_SUCH_FOLDER(\"/\" + path);\n\n        Folder folder = getFolderById(null, startingFolderId); \n        assert(folder != null);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"getFolderByPathLongestMatch\", octxt);\n\n            String unmatched = null, segments[] = path.split(\"/\");\n            for (int i = 0; i < segments.length; i++) {\n                Folder subfolder = folder.findSubfolder(segments[i]);\n                if (subfolder == null) {\n                    unmatched = StringUtil.join(\"/\", segments, i, segments.length - i);\n                    break;\n                }\n                folder = subfolder;\n            }\n            // apply the \"read access\" check to the returned folder...\n            return new Pair<Folder, String>(checkAccess(folder), unmatched);\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<Folder> getFolderList(OperationContext octxt, byte sort) throws ServiceException {\n        List<Folder> folders = new ArrayList<Folder>();\n        for (MailItem item : getItemList(octxt, MailItem.TYPE_FOLDER, -1, sort))\n            folders.add((Folder) item);\n        return folders;\n    }\n\n    List<Folder> listAllFolders() {\n        return new ArrayList<Folder>(mFolderCache.values());\n    }\n\n\n    public synchronized SearchFolder getSearchFolderById(OperationContext octxt, int searchId) throws ServiceException {\n        return (SearchFolder) getItemById(octxt, searchId, MailItem.TYPE_SEARCHFOLDER);\n    }\n\n    SearchFolder getSearchFolderById(int searchId) throws ServiceException {\n        return (SearchFolder) getItemById(searchId, MailItem.TYPE_SEARCHFOLDER);\n    }\n\n\n    public synchronized Mountpoint getMountpointById(OperationContext octxt, int mptId) throws ServiceException {\n        return (Mountpoint) getItemById(octxt, mptId, MailItem.TYPE_MOUNTPOINT);\n    }\n\n\n    public synchronized Note getNoteById(OperationContext octxt, int noteId) throws ServiceException {\n        return (Note) getItemById(octxt, noteId, MailItem.TYPE_NOTE);\n    }\n\n    Note getNoteById(int noteId) throws ServiceException {\n        return (Note) getItemById(noteId, MailItem.TYPE_NOTE);\n    }\n\n    public synchronized List getNoteList(OperationContext octxt, int folderId) throws ServiceException {\n        return getItemList(octxt, MailItem.TYPE_NOTE, folderId);\n    }\n\n\n    public synchronized Contact getContactById(OperationContext octxt, int id) throws ServiceException {\n        return (Contact) getItemById(octxt, id, MailItem.TYPE_CONTACT);\n    }\n\n    Contact getContactById(int id) throws ServiceException {\n        return (Contact) getItemById(id, MailItem.TYPE_CONTACT);\n    }\n\n    public synchronized List<Contact> getContactList(OperationContext octxt, int folderId) throws ServiceException {\n        return getContactList(octxt, folderId, DbSearch.SORT_NONE);\n    }\n\n    public synchronized List<Contact> getContactList(OperationContext octxt, int folderId, byte sort) throws ServiceException {\n        List<Contact> contacts = new ArrayList<Contact>();\n        for (MailItem item : getItemList(octxt, MailItem.TYPE_CONTACT, folderId, sort))\n            contacts.add((Contact) item);\n        return contacts;\n    }\n\n    /**\n     * Returns the <tt>Message</tt> with the specified id. \n     * @throws NoSuchItemException if the item does not exist\n     */\n    public synchronized Message getMessageById(OperationContext octxt, int id) throws ServiceException {\n        return (Message) getItemById(octxt, id, MailItem.TYPE_MESSAGE);\n    }\n\n    Message getMessageById(int id) throws ServiceException {\n        return (Message) getItemById(id, MailItem.TYPE_MESSAGE);\n    }\n    \n    Message getMessage(MailItem.UnderlyingData data) throws ServiceException { \n        return (Message) getItem(data);\n    }\n\n    Message getCachedMessage(Integer id) throws ServiceException {\n        return (Message) getCachedItem(id, MailItem.TYPE_MESSAGE);\n    }\n\n    public synchronized List<Message> getMessagesByConversation(OperationContext octxt, int convId) throws ServiceException {\n        return getMessagesByConversation(octxt, convId, Conversation.SORT_ID_ASCENDING);\n    }\n\n    public synchronized List<Message> getMessagesByConversation(OperationContext octxt, int convId, byte sort) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getMessagesByConversation\", octxt);\n            List<Message> msgs = getConversationById(convId).getMessages(sort);\n            if (!hasFullAccess()) {\n                List<Message> visible = new ArrayList<Message>(msgs.size());\n                for (Message msg : msgs)\n                    if (msg.canAccess(ACL.RIGHT_READ))\n                        visible.add(msg);\n                msgs = visible;\n            }\n            success = true;\n            return msgs;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized Conversation getConversationById(OperationContext octxt, int id) throws ServiceException {\n        return (Conversation) getItemById(octxt, id, MailItem.TYPE_CONVERSATION);\n    }\n\n    Conversation getConversationById(int id) throws ServiceException {\n        return (Conversation) getItemById(id, MailItem.TYPE_CONVERSATION);\n    }\n\n    Conversation getConversation(MailItem.UnderlyingData data) throws ServiceException {\n        return (Conversation) getItem(data);\n    }\n\n    Conversation getCachedConversation(Integer id) throws ServiceException {\n        return (Conversation) getCachedItem(id, MailItem.TYPE_CONVERSATION);\n    }\n\n    Conversation getConversationByHash(String hash) throws ServiceException {\n        Conversation conv = null;\n\n        Integer convId = (Integer) mConvHashes.get(hash);\n        if (convId != null)\n            conv = getCachedConversation(convId);\n        if (conv != null)\n            return conv;\n\n        // XXX: why not just do a \"getConversationById()\" if convId != null?\n        MailItem.UnderlyingData data = DbMailItem.getByHash(this, hash);\n        if (data == null || data.type == MailItem.TYPE_CONVERSATION)\n            return getConversation(data);\n        return (Conversation) getMessage(data).getParent();\n    }\n\n    public synchronized SenderList getConversationSenderList(int convId) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getSenderList\", null);\n            Conversation conv = getConversationById(convId);\n            SenderList sl = conv.getSenderList();\n            success = true;\n            return sl;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    \n    public WikiItem getWikiById(OperationContext octxt, int id) throws ServiceException {\n        return (WikiItem) getItemById(octxt, id, MailItem.TYPE_WIKI);\n    }\n\n\n    public Document getDocumentById(OperationContext octxt, int id) throws ServiceException {\n        return (Document) getItemById(octxt, id, MailItem.TYPE_DOCUMENT);\n    }\n\n    Document getDocumentById(int id) throws ServiceException {\n        return (Document) getItemById(id, MailItem.TYPE_DOCUMENT);\n    }\n\n    public synchronized List<Document> getDocumentList(OperationContext octxt, int folderId) throws ServiceException {\n        return getDocumentList(octxt, folderId, DbSearch.SORT_NONE);\n    }\n\n    public synchronized List<Document> getDocumentList(OperationContext octxt, int folderId, byte sort) throws ServiceException {\n        List<Document> docs = new ArrayList<Document>();\n        for (MailItem item : getItemList(octxt, MailItem.TYPE_DOCUMENT, folderId, sort))\n            docs.add((Document) item);\n        return docs;\n    }\n\n\n    private void checkCalendarType(MailItem item) throws ServiceException {\n        byte type = item.getType();\n        if (type != MailItem.TYPE_APPOINTMENT && type != MailItem.TYPE_TASK)\n            throw MailServiceException.NO_SUCH_CALITEM(item.getId());\n    }\n\n    public synchronized CalendarItem getCalendarItemById(OperationContext octxt, int id) throws ServiceException {\n        MailItem item = getItemById(octxt, id, MailItem.TYPE_UNKNOWN);\n        checkCalendarType(item);\n        return (CalendarItem) item;\n    }\n\n    CalendarItem getCalendarItemById(int id) throws ServiceException {\n        MailItem item = getItemById(id, MailItem.TYPE_UNKNOWN);\n        checkCalendarType(item);\n        return (CalendarItem) item;\n    }\n\n    CalendarItem getCalendarItem(MailItem.UnderlyingData data) throws ServiceException {\n        return (CalendarItem) getItem(data);\n    }\n\n    public synchronized List getCalendarItemList(OperationContext octxt, int folderId) throws ServiceException {\n        return getItemList(octxt, MailItem.TYPE_UNKNOWN, folderId);\n    }\n    \n\n    public synchronized Appointment getAppointmentById(OperationContext octxt, int id) throws ServiceException {\n        return (Appointment) getItemById(octxt, id, MailItem.TYPE_APPOINTMENT);\n    }\n\n    Appointment getAppointmentById(int id) throws ServiceException {\n        return (Appointment) getItemById(id, MailItem.TYPE_APPOINTMENT);\n    }\n\n    public synchronized List getAppointmentList(OperationContext octxt, int folderId) throws ServiceException {\n        return getItemList(octxt, MailItem.TYPE_APPOINTMENT, folderId);\n    }\n\n\n    public synchronized Task getTaskById(OperationContext octxt, int id) throws ServiceException {\n        return (Task) getItemById(octxt, id, MailItem.TYPE_TASK);\n    }\n\n    Task getTaskById(int id) throws ServiceException {\n        return (Task) getItemById(id, MailItem.TYPE_TASK);\n    }\n\n    public synchronized List getTaskList(OperationContext octxt, int folderId) throws ServiceException {\n        return getItemList(octxt, MailItem.TYPE_TASK, folderId);\n    }\n\n\n    public synchronized TypedIdList listCalendarItemsForRange(OperationContext octxt, byte type, long start, long end, int folderId)\n    throws ServiceException {\n        if (folderId == ID_AUTO_INCREMENT)\n            return new TypedIdList();\n\n        boolean success = false;\n        try {\n            beginTransaction(\"listCalendarItemsForRange\", octxt);\n\n            // if they specified a folder, make sure it actually exists\n            getFolderById(folderId);\n\n            // get the list of all visible calendar items in the specified folder\n            TypedIdList ids = DbMailItem.listCalendarItems(this, type, start, end, folderId, null);\n            success = true;\n            return ids;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<CalendarItem> getCalendarItems(OperationContext octxt, byte type, int folderId)\n    throws ServiceException {\n        return getCalendarItemsForRange(octxt, type, -1, -1, folderId, null);\n    }\n\n    public synchronized List<CalendarItem> getCalendarItemsForRange(OperationContext octxt, long start, long end, int folderId, int[] excludeFolders)\n    throws ServiceException {\n        return getCalendarItemsForRange(octxt, MailItem.TYPE_UNKNOWN, start, end, folderId, excludeFolders);\n    }\n    \n    /** Returns a <tt>Collection</tt> of all {@link CalendarItem}s which\n     *  overlap the specified time period.  There is no guarantee that the\n     *  returned calendar items actually contain a recurrence within the range;\n     *  all that is required is that there is some intersection between the\n     *  (<tt>start</tt>, <tt>end</tt>) range and the period from the\n     *  start time of the calendar item's first recurrence to the end time of\n     *  its last recurrence.<p>\n     * \n     *  If a <tt>folderId</tt> is specified, only calendar items\n     *  in that folder are returned.  If {@link #ID_AUTO_INCREMENT} is passed\n     *  in as the <tt>folderId</tt>, all calendar items not in\n     *  <tt>Spam</tt> or <tt>Trash</tt> are returned.\n     * @param octxt     The {@link Mailbox.OperationContext}.\n     * @param type      If MailItem.TYPE_APPOINTMENT, return only appointments.\n     *                  If MailItem.TYPE_TASK, return only tasks.\n     *                  If MailItem.TYPE_UNKNOWN, return both.\n     * @param start     The start time of the range, in milliseconds.\n     *                  <tt>-1</tt> means to leave the start time unconstrained.\n     * @param end       The end time of the range, in milliseconds.\n     *                  <tt>-1</tt> means to leave the end time unconstrained.\n     * @param folderId  The folder to search for matching calendar items, or\n     *                  {@link #ID_AUTO_INCREMENT} to search all non-Spam and\n     *                  Trash folders in the mailbox.\n     * \n     * @perms {@link ACL#RIGHT_READ} on all returned calendar items.\n     * @throws ServiceException */\n    public synchronized List<CalendarItem> getCalendarItemsForRange(OperationContext octxt, byte type,\n            long start, long end, int folderId, int[] excludeFolders)\n    throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getCalendarItemsForRange\", octxt);\n\n            // if they specified a folder, make sure it actually exists\n            if (folderId != ID_AUTO_INCREMENT)\n                getFolderById(folderId);\n\n            // get the list of all visible calendar items in the specified folder\n            List<CalendarItem> calItems = new ArrayList<CalendarItem>();\n            List<UnderlyingData> invData = DbMailItem.getCalendarItems(this, type, start, end, folderId, excludeFolders);\n            for (MailItem.UnderlyingData data : invData) {\n                try {\n                    CalendarItem calItem = getCalendarItem(data);\n                    if (folderId == calItem.getFolderId() || (folderId == ID_AUTO_INCREMENT && calItem.inMailbox())) {\n                        if (calItem.canAccess(ACL.RIGHT_READ))\n                            calItems.add(calItem);\n                    }\n                } catch (ServiceException e) {\n                    ZimbraLog.calendar.warn(\"Error while retrieving calendar item \" + data.id + \" in mailbox \" + mId + \"; skipping item\", e);\n                }\n            }\n            success = true;\n            return calItems;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized ZVCalendar getZCalendarForCalendarItems(Collection<CalendarItem> calItems,\n            boolean useOutlookCompatMode, boolean ignoreErrors, boolean allowPrivateAccess)\n    throws ServiceException {\n        ZVCalendar cal = new ZVCalendar();\n\n        // REPLY\n        cal.addProperty(new ZProperty(ICalTok.METHOD, ICalTok.PUBLISH.toString()));\n\n        // timezones\n        {\n            ICalTimeZone localTz = ICalTimeZone.getAccountTimeZone(getAccount()); \n            TimeZoneMap tzmap = new TimeZoneMap(localTz);\n\n            for (CalendarItem calItem : calItems)\n                tzmap.add(calItem.getTimeZoneMap());\n\n            // iterate the tzmap and add all the VTimeZone's \n            // (TODO: should this code live in TimeZoneMap???) \n            for (Iterator iter = tzmap.tzIterator(); iter.hasNext(); ) {\n                ICalTimeZone cur = (ICalTimeZone) iter.next();\n                cal.addComponent(cur.newToVTimeZone());\n            }\n        }\n\n        // build all the event components and add them to the Calendar\n        for (CalendarItem calItem : calItems)\n            calItem.appendRawCalendarData(cal, useOutlookCompatMode, ignoreErrors, allowPrivateAccess);\n        return cal;\n    }\n\n    public synchronized void writeICalendarForCalendarItems(\n            Writer writer, Collection<CalendarItem> calItems,\n            boolean useOutlookCompatMode, boolean ignoreErrors, boolean allowPrivateAccess, boolean forceOlsonTZID,\n            boolean trimCalItemsList)\n    throws ServiceException {\n        try {\n            writer.write(\"BEGIN:VCALENDAR\\r\\n\");\n\n            ZProperty prop;\n            prop = new ZProperty(ICalTok.PRODID, ZCalendar.sZimbraProdID);\n            prop.toICalendar(writer, forceOlsonTZID);\n            prop = new ZProperty(ICalTok.VERSION, ZCalendar.sIcalVersion);\n            prop.toICalendar(writer, forceOlsonTZID);\n            prop = new ZProperty(ICalTok.METHOD, ICalTok.PUBLISH.toString());\n            prop.toICalendar(writer, forceOlsonTZID);\n\n            // timezones\n            ICalTimeZone localTz = ICalTimeZone.getAccountTimeZone(getAccount()); \n            TimeZoneMap tzmap = new TimeZoneMap(localTz);\n            for (CalendarItem calItem : calItems)\n                tzmap.add(calItem.getTimeZoneMap());\n            // iterate the tzmap and add all the VTimeZone's \n            for (Iterator<ICalTimeZone> iter = tzmap.tzIterator(); iter.hasNext(); ) {\n                ICalTimeZone tz = iter.next();\n                tz.newToVTimeZone().toICalendar(writer, forceOlsonTZID);\n            }\n            tzmap = null;  // help keep memory consumption low\n\n            // build all the event components and add them to the Calendar\n            for (Iterator<CalendarItem> iter = calItems.iterator(); iter.hasNext(); ) {\n                CalendarItem calItem = iter.next();\n                if (trimCalItemsList)\n                    iter.remove();  // help keep memory consumption low\n                Invite[] invites = calItem.getInvites();\n                if (invites != null) {\n                    for (Invite inv : invites) {\n                        ZComponent comp = null;\n                        try {\n                            comp = inv.newToVComponent(useOutlookCompatMode, allowPrivateAccess);\n                        } catch (ServiceException e) {\n                            if (ignoreErrors) {\n                                ZimbraLog.calendar.warn(\n                                        \"Error retrieving iCalendar data for item \" +\n                                        inv.getMailItemId() + \": \" + e.getMessage(), e);\n                            } else\n                                throw e;\n                        }\n                        if (comp != null)\n                            comp.toICalendar(writer, forceOlsonTZID);\n                    }\n                }\n            }\n\n            writer.write(\"END:VCALENDAR\\r\\n\");\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"Error writing iCalendar\", e);\n        }\n    }\n\n    public synchronized void writeICalendarForRange(\n            Writer writer, OperationContext octxt, long start, long end, int folderId,\n            boolean useOutlookCompatMode, boolean ignoreErrors, boolean allowPrivateAccess, boolean forceOlsonTZID)\n    throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"writeICalendarForRange\", octxt);\n            Collection<CalendarItem> calItems = getCalendarItemsForRange(octxt, start, end, folderId, null);\n            writeICalendarForCalendarItems(\n                    writer, calItems, useOutlookCompatMode, ignoreErrors, allowPrivateAccess, forceOlsonTZID, true);\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    public synchronized CalendarData getCalendarSummaryForRange(OperationContext octxt, int folderId, byte itemType, long start, long end)\n    throws ServiceException {\n        Folder folder = getFolderById(folderId);\n        if (!folder.canAccess(ACL.RIGHT_READ))\n            throw MailServiceException.PERM_DENIED(\"you do not have sufficient permissions on folder \" + folder.getName());\n        return CalendarCache.getInstance().getCalendarSummary(octxt, this, folderId, itemType, start, end, true);\n    }\n\n    public synchronized List<CalendarData> getAllCalendarsSummaryForRange(OperationContext octxt, byte itemType, long start, long end)\n    throws ServiceException {\n        List<CalendarData> list = new ArrayList<CalendarData>();\n        for (Folder folder : listAllFolders()) {\n            if (folder.inTrash() || folder.inSpam())\n                continue;\n            // Only look at folders of right view type.  We might have to relax this to allow appointments/tasks\n            // in any folder, but that requires scanning too many folders each time, most of which don't contain\n            // any calendar items.\n            if (folder.getDefaultView() != itemType)\n                continue;\n            if (!folder.canAccess(ACL.RIGHT_READ))\n                continue;\n            CalendarData calData = CalendarCache.getInstance().getCalendarSummary(octxt, this, folder.getId(), itemType, start, end, true);\n            if (calData != null)\n                list.add(calData);\n        }\n        return list;\n    }\n\n    /**\n     * Specifies the type of result we want from the call to search()\n     */\n    public static enum SearchResultMode {\n        NORMAL,        // everything\n        IMAP,          // only IMAP data\n        MODSEQ,        // only the metadata modification sequence number\n        IDS;           // only IDs\n        \n        public static SearchResultMode get(String value) throws ServiceException {\n            if (value == null)\n                return NORMAL;\n            try {\n                return valueOf(value.toUpperCase());\n            } catch (IllegalArgumentException e) {\n                throw ServiceException.INVALID_REQUEST(\"Unknown resultMode value: \"  +value, null);\n            }\n        }\n    }\n    \n    /**\n     * You **MUST** call {@link ZimbraQueryResults#doneWithSearchResults()} when you are done with the search results, otherwise\n     * resources will be leaked.\n     * \n     * @param octxt\n     * @param queryString\n     * @param types\n     * @param sortBy\n     * @param chunkSize A hint to the search engine telling it the size of the result set you are expecting\n     * @return\n     * @throws IOException\n     * @throws ParseException\n     * @throws ServiceException\n     */\n    public ZimbraQueryResults search(OperationContext octxt, String queryString, byte[] types, SortBy sortBy, int chunkSize) \n    throws IOException, ParseException, ServiceException {\n        SearchParams params = new SearchParams();\n        params.setQueryStr(queryString);\n        params.setTimeZone(null);\n        params.setLocale(null);\n        params.setTypes(types);\n        params.setSortBy(sortBy);\n        params.setChunkSize(chunkSize);\n        params.setPrefetch(true);\n        params.setMode(SearchResultMode.NORMAL);\n        return search(SoapProtocol.Soap12, octxt, params);\n    }\n\n    private static final long sBatchIndexMaxBytesPerTransaction = LC.zimbra_index_max_transaction_bytes.longValue();\n    private static final int sBatchIndexMaxItemsPerTransaction = LC.zimbra_index_max_transaction_items.intValue();\n    \n    private Object mIndexingDeferredItemsLock = new Object(); // the lock protects the mIndexingDeferredItems boolean below\n    private boolean mIndexingDeferredItems = false; // TRUE if we're in the middle of an index-deferred op.\n    \n    // how frequently is the mailbox allowed to retry indexing deferred items?  The mailbox will ALWAYS try to index deferred items\n    // if a text search is run, this only controls other periodic retries.\n    private static final long sIndexDeferredItemsRetryIntervalMs = LC.zimbra_index_deferred_items_delay.longValue() * 1000;\n    private long mLastIndexDeferredTime = 0; // the ENDING time of the last index-deferred-items attempt\n    \n    // the timestamp of the last time we had a failure-to-index.  Not persisted anywhere.\n    // Used so the can throttle deferred-index-retries in a situation where an index\n    // is corrupt.  '0' means we think the index is good (we've successfully added to it), nonzero\n    // means that we've had failures without success.\n    private long mLastIndexingFailureTimestamp = 0;\n    private static final long sIndexItemDeferredRetryDelayAfterFailureMs = 1000 * LC.zimbra_index_deferred_items_failure_delay.longValue();\n\n    /**\n     * This API will periodically attempt to re-try deferred index items.\n     */\n    private void maybeIndexDeferredItems() {\n        int batchIndexingCount = getBatchedIndexingCount();\n        \n        if (Thread.holdsLock(this)) // don't attempt if we're holding the mailbox lock\n            return;\n        \n        boolean shouldIndexDeferred = false;\n        synchronized (this) {\n            if (!mIndexingDeferredItems) {\n                if (getIndexDeferredCount() > batchIndexingCount) {\n                    long now = System.currentTimeMillis();\n                    \n                    if (((now - sIndexItemDeferredRetryDelayAfterFailureMs) > mLastIndexingFailureTimestamp) &&\n                                ((now - sIndexDeferredItemsRetryIntervalMs) > mLastIndexDeferredTime))\n                        shouldIndexDeferred = true;\n                }\n            }\n        }\n        if (shouldIndexDeferred)\n            indexDeferredItems(); \n    }\n    \n    /**\n     * \"Catch-up\" the text index by indexing all the items that have the INDEXING_DEFERRED flag set.  This\n     * function makes a \"Best attempt\" to index all items: it is not guaranteed that the index is\n     * completely caught-up when this function returns.\n     * \n     * This outer function is responsible for synchronization -- it guarantees that only one\n     * thread can be in indexDeferredItemsInternal at a time, but does not require us to \n     * hold the Mailbox lock during the whole operation.  Threads can block\n     * waiting for other indexDeferredItems threads to complete -- they will be run\n     * once the operation completes.\n     */\n    private void indexDeferredItems() {\n        assert(!Thread.holdsLock(this));\n        assert(!Thread.holdsLock(mIndexingDeferredItemsLock));\n        \n        synchronized(mIndexingDeferredItemsLock) {\n            synchronized(this) {\n                mLastIndexDeferredTime = System.currentTimeMillis();\n                \n                // must sync on 'this' to get correct value.  OK to release the \n                // lock afterwards as we're just checking for 0 and we know the value\n                // can't go DOWN since we're holding mIndexingDeferredItemsLock\n                if (getIndexDeferredCount() <= 0)\n                    return;\n            }\n            while (mIndexingDeferredItems) {\n                try {\n                    mIndexingDeferredItemsLock.wait();\n                } catch (InterruptedException e) {}\n            }\n            mIndexingDeferredItems = true;\n        }\n        try {\n            // at this point we know we're the only one in here\n            indexDeferredItemsInternal();\n        } finally {\n            synchronized(mIndexingDeferredItemsLock) {\n                synchronized(this) {\n                    mLastIndexDeferredTime = System.currentTimeMillis();\n                }                \n                mIndexingDeferredItems = false;\n                mIndexingDeferredItemsLock.notify();\n            }\n        }\n    }\n    \n    /**\n     * Do the actual work, index all the deferred items\n     */\n    private void indexDeferredItemsInternal() {\n        assert(!Thread.holdsLock(this));\n        assert(!Thread.holdsLock(mIndexingDeferredItemsLock));\n        assert (mIndexingDeferredItems);\n\n        long start = 0;\n        if (ZimbraLog.mailbox.isInfoEnabled()) \n            start = System.currentTimeMillis();\n        \n        ///////////////////////////////\n        // Get the list of deferred items to index \n        Collection<SearchResult>items = new ArrayList<SearchResult>();\n        synchronized(this) {\n            if (getIndexDeferredCount() <= 0) // check again, now that we have the mbox lock\n                return;\n            \n            try {\n                boolean success = false;\n                try {\n                    beginTransaction(\"IndexDeferredItems_Select\", null);\n                    DbSearchConstraints c = new DbSearchConstraints();\n                    c.mailbox = this;\n                    c.tags = new HashSet<Tag>();\n                    c.tags.add(this.mIndexingDeferredFlag);\n                    c.sort = DbSearch.SORT_NONE;\n                    DbSearch.search(items, getOperationConnection(), c, SearchResult.ExtraData.NONE);\n                    \n                    int deferredCount = getIndexDeferredCount();\n                    if (items.size() != deferredCount) {\n                        if (ZimbraLog.mailbox.isDebugEnabled())\n                            ZimbraLog.mailbox.debug(\"IndexDeferredItems: Deferred count out of sync - found \"+items.size()+\" deferred items (count=\"+getIndexDeferredCount()+\")\");\n                        mCurrentChange.idxDeferred = items.size();\n                    } else {\n                        if (ZimbraLog.mailbox.isDebugEnabled())\n                            ZimbraLog.mailbox.debug(\"IndexDeferredItems: found \"+items.size()+\" deferred items (count=\"+getIndexDeferredCount()+\")\");\n                    }\n                    success = true;\n                } finally {\n                    endTransaction(success);\n                }\n            } catch (ServiceException e) {\n                ZimbraLog.mailbox.info(\"Unable to index deferred items due to exception in step 1\", e);\n                return;\n            }\n        }\n\n        BatchedIndexStatus status = new BatchedIndexStatus();\n        \n        try {\n            indexItemList(items, true, status);\n        } catch (ServiceException e) {\n            assert(false);\n            ZimbraLog.mailbox.error(\"Unexpected exception from Mailbox.indexItemList\", e);\n        }\n\n        if (ZimbraLog.mailbox.isInfoEnabled()) {\n            long elapsed = System.currentTimeMillis() - start;\n            double itemsPerSec = (1000.0*(status.mNumProcessed-status.mNumFailed)) / elapsed;\n            int successful = status.mNumProcessed - status.mNumFailed;\n            if (ZimbraLog.mailbox.isInfoEnabled())\n                ZimbraLog.mailbox.info(\"Deferred Indexing: successfully indexed \"+successful+\" items in \"+elapsed+\"ms (\"+itemsPerSec+\"/sec). (\"+\n                    (status.mNumFailed)+ \" items failed to index).  IndexDeferredCount now at \"+getIndexDeferredCount());\n        }\n    }\n    \n    /**\n     * Index a (protentially very large) list of MailItems.  Extract the indexable data outside of\n     * the mailbox lock and then index a chunk of items at a time into the mailbox.\n     *\n     * @param items\n     * @param forReindexAPI if TRUE, then this function will check the\n     * \n     * @throws ServiceException.INTERRUPTED if status.mCancel is set to TRUE (by some other thread, synchronized on the Mailbox)\n     * \n     */\n    private void indexItemList(Collection<SearchResult> items, boolean deferredItemsOnly, BatchedIndexStatus status) throws ServiceException {\n        assert(!Thread.holdsLock(this));\n        \n        ///////////////////////////////////\n        // Do the actual indexing: iterate through the list of items, fetch each one\n        // and call generateIndexData().  Buffer the items,IndexData into a chunk\n        // and when the chunk gets sufficiently large, run a Mailbox transaction\n        // to actually do the indexing\n        \n        // we reindex 'chunks' of items -- up to a certain size or count\n        List<Pair<MailItem, List<org.apache.lucene.document.Document>>> chunk = new ArrayList<Pair<MailItem, List<org.apache.lucene.document.Document>>>();\n        long itemSize = 0;\n        \n        // track the total number of deferred items which are indexed by looking at the\n        // deferred count before and after each chunk transaction\n        int idxDeferredChange = 0;\n        int itemsAttempted = 0;\n        \n        for (Iterator<SearchResult> iter = items.iterator(); iter.hasNext(); ) {\n            SearchResult sr = iter.next();\n            itemsAttempted++;\n\n            //\n            // First step: fetch the MailItem and generate the list Lucene documents to index.  \n            // Do this without holding the Mailbox lock.  Once we've accumulated a \"chunk\"\n            // of items, do a mailbox transaction to actually add them to the index\n            //\n            \n            MailItem item = null;\n            try {\n                item = getItemById(null, sr.id, sr.type);\n            } catch(ServiceException  e) {\n                if (ZimbraLog.index.isDebugEnabled())\n                    ZimbraLog.index.debug(\"Error fetching deferred item id = \" + sr.id + \".  Item will not be indexed.\", e);\n            } catch(java.lang.RuntimeException e) {\n                if (ZimbraLog.index.isDebugEnabled())\n                    ZimbraLog.index.debug(\"Error fetching deferred item id = \" + sr.id + \".  Item will not be indexed.\", e);\n            }\n            if (item != null && (!deferredItemsOnly || item.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED))) {\n                itemSize += item.getSize();\n                try {\n                    assert(!Thread.holdsLock(this));\n                    chunk.add(new Pair<MailItem, List<org.apache.lucene.document.Document>>(item, item.generateIndexData(true)));\n                } catch (MailItem.TemporaryIndexingException e) {\n                    // temporary error\n                    if (ZimbraLog.index.isInfoEnabled())\n                        ZimbraLog.index.info(\"Temporary error generating index data for item ID: \" + item.getId() + \".  Indexing will be retried\", e);\n                }\n            } else {\n                if (ZimbraLog.index.isDebugEnabled())\n                    ZimbraLog.index.debug(\"SKIPPING indexing of item \" + sr.id + \" ptr=\" + item);\n            }\n            \n            int chunkSizeToUse = sBatchIndexMaxItemsPerTransaction;\n            if (mLastIndexingFailureTimestamp > 0) {\n                // Our most recent index attempts have all failed.  Lets NOT try a big full-size chunk\n                // since they are expensive.  Instead we'll try a small number of items and see if \n                // we can make any of them index correctly...\n                chunkSizeToUse = 5;\n            }\n\n            if (!iter.hasNext() || itemSize > sBatchIndexMaxBytesPerTransaction || chunk.size() >= chunkSizeToUse) {\n                //\n                // Second step: we have a chunk of items and their corresponding index data -- add them to the index\n                //\n                try { \n                    synchronized(this) {\n                        if (status.mCancel) {\n                            ZimbraLog.mailbox.warn(\"CANCELLING batch index of Mailbox \"+getId()+\" before it is complete.  (\"+status.mNumProcessed+\" processed out of \"+items.size()+\")\");                            \n                            throw ServiceException.INTERRUPTED(\"ReIndexing Canceled\");\n                        }\n                        int idxDeferredStart = this.getIndexDeferredCount();\n                        try {\n                            boolean success = false;\n                            try {\n                                beginTransaction(\"IndexItemList_Chunk\", null);\n                                for (Pair<MailItem, List<org.apache.lucene.document.Document>> p : chunk) {\n                                    if (!deferredItemsOnly || (p.getFirst().getFlagBitmask()&Flag.BITMASK_INDEXING_DEFERRED)!=0) {\n                                        mCurrentChange.addIndexedItem(p.getFirst(), false, p.getSecond());\n                                    }\n                                }\n                                success = true;\n                            } finally {\n                                endTransaction(success);\n                            }\n                        } catch (ServiceException e) {\n                            if (ZimbraLog.index.isInfoEnabled()) {\n                                StringBuilder sb = new StringBuilder();\n                                for (Pair<MailItem, List<org.apache.lucene.document.Document>> p : chunk) \n                                    sb.append(p.getFirst().getId()).append(',');\n                                ZimbraLog.index.info(\"Error deferred-indexing one chunk: \"+sb.toString()+\" skipping it (will retry)\", e);\n                            }\n                        }\n                        if (deferredItemsOnly) {\n                            // can infer success/failure by looking at IndexDeferredCount\n                            int idxDeferredCountNow = this.getIndexDeferredCount();\n                            idxDeferredChange +=  idxDeferredCountNow - idxDeferredStart;\n                            status.mNumProcessed = itemsAttempted;\n                            // success = idxDeferredChange\n                            // failure + success = attempt\n                            // failure = accempt - success\n                            status.mNumFailed = itemsAttempted + idxDeferredChange;\n                            if (status.mNumFailed >= chunkSizeToUse) {\n                                ZimbraLog.index.warn(\"Possibly corrupt index: Too many failures (\"+status.mNumFailed+\") trying to indexItemList (total list size=\"+items.size()+\") Aborting\");\n                                return;\n                            }\n                        } else {\n                            // can't track failures easily, skip it. \n                            status.mNumProcessed = itemsAttempted;\n                        }\n                    }\n                } finally {\n                    chunk.clear();\n                    itemSize = 0;\n                }\n            }\n            if (ZimbraLog.mailbox.isInfoEnabled() && ((itemsAttempted % 2000) == 0)) {\n                ZimbraLog.mailbox.info(\"Batch Indexing: Mailbox \"+getId()+\" on item \"+mReIndexStatus.mNumProcessed+\" out of \"+items.size());\n            }\n        }\n    }\n    \n    \n    /**\n     * Entry point for Redo-logging system only.  Everybody else should use queueItemForIndexing inside a transactino\n     * \n     * @throws ServiceException\n     */\n    synchronized public void redoIndexItem(MailItem item, boolean deleteFirst, int itemId, byte itemType, long timestamp, \n                              boolean noRedo, List<org.apache.lucene.document.Document> docList)\n    {\n        IndexItem redo = null;\n        if (!noRedo) {\n            redo = new IndexItem(getId(), item.getId(), itemType, deleteFirst);\n            redo.start(System.currentTimeMillis());\n            redo.log();\n            redo.allowCommit();\n        }\n        \n        boolean success = false;\n        try {\n            if (getMailboxIndex() != null) {\n                getMailboxIndex().indexMailItem(this, redo, deleteFirst, docList, item);\n            }\n            success = true;\n        } catch (Throwable t) {\n            ZimbraLog.index.info(\"Skipping indexing; Unable to parse message \" + itemId + \": \" + t.toString(), t);\n        } finally {\n            if (!success)\n                redo.abort();\n        }\n    }\n            \n    /**\n     * This is the preferred form of the API call.\n     * \n     * You **MUST** call {@link ZimbraQueryResults#doneWithSearchResults()} when you are done with the search results, otherwise\n     * resources will be leaked.\n     * \n     * @param proto  The soap protocol the request is coming from.  Determines the type of Element we create for proxied results.\n     * @param octxt  Operation Context\n     * @param params Search Parameters\n     * @return\n     * @throws IOException\n     * @throws ParseException\n     * @throws ServiceException\n     */\n    public ZimbraQueryResults search(SoapProtocol proto, OperationContext octxt, SearchParams params) throws IOException, ParseException, ServiceException {\n        if (octxt == null)\n            throw ServiceException.INVALID_REQUEST(\"The OperationContext must not be null\", null);\n        \n        try {\n            return MailboxIndex.search(proto, octxt, this, params, getIndexDeferredCount()>0);\n        } catch (MailServiceException e) {\n            if (e.getCode() == MailServiceException.TEXT_INDEX_OUT_OF_SYNC) {\n                indexDeferredItems();\n                return MailboxIndex.search(proto, octxt, this, params, false);\n            } else throw e;\n        }\n    }\n    \n    /**\n     * @param octxt\n     * @param params\n     * @return A \"mailbox neutral\" representation of the query string: ie one that is re-written so that all Folder names (and other by-name\n     *         search parts) are re-written using ID's.  This is useful in some situations where you want to proxy the search\n     *         request (since you cannot directly proxy a search request with local folder names in it)\n     * @throws IOException\n     * @throws ParseException\n     * @throws ServiceException\n     */\n    public String getRewrittenQueryString(OperationContext octxt, SearchParams params) throws ParseException, ServiceException {\n        if (octxt == null)\n            throw ServiceException.INVALID_REQUEST(\"The OperationContext must not be null\", null);\n        \n        // okay, lets run the search through the query parser -- this has the side-effect of\n        // re-writing the query in a format that is OK to proxy to the other server\n        ZimbraQuery zq = new ZimbraQuery(this, params);\n        return zq.toQueryString();\n    }\n\n    public synchronized FreeBusy getFreeBusy(OperationContext octxt, long start, long end)\n    throws ServiceException {\n        return getFreeBusy(octxt, getAccount().getName(), start, end, null);\n    }\n\n    public synchronized FreeBusy getFreeBusy(OperationContext octxt, long start, long end, Appointment exAppt)\n    throws ServiceException {\n        return getFreeBusy(octxt, getAccount().getName(), start, end, exAppt);\n    }\n\n    public synchronized FreeBusy getFreeBusy(OperationContext octxt, String name, long start, long end)\n    throws ServiceException {\n        return getFreeBusy(octxt, name, start, end, null);\n    }\n\n    public synchronized FreeBusy getFreeBusy(OperationContext octxt, String name, long start, long end, Appointment exAppt)\n    throws ServiceException {\n        Account authAcct;\n        boolean asAdmin;\n        if (octxt != null) {\n            authAcct = octxt.getAuthenticatedUser();\n            asAdmin = octxt.isUsingAdminPrivileges();\n        } else {\n            authAcct = null;\n            asAdmin = false;\n        }\n        AccessManager accessMgr = AccessManager.getInstance();\n        if (accessMgr.canPerform(authAcct, getAccount(), Right.RT_viewFreeBusy, asAdmin, true))\n            return com.zimbra.cs.fb.LocalFreeBusyProvider.getFreeBusyList(this, name, start, end, exAppt);\n        else\n            return FreeBusy.emptyFreeBusy(name, start, end);\n    }\n\n    private void addDomains(HashMap<String, DomainItem> domainItems, HashSet<BrowseTerm> newDomains, int flag) {\n        for (BrowseTerm domain : newDomains) {\n            DomainItem di = domainItems.get(domain.term);\n            if (di == null)\n                domainItems.put(domain.term, di = new DomainItem(domain));\n            di.addFlag(flag);\n        }\n    }\n    \n    public static enum BrowseBy {\n        attachments, domains, objects;\n    }\n\n    /**\n     * Return a list of all the {attachments} or {doamins} or {objects} in this Mailbox, optionally with a prefix string \n     * or limited by maximum number.  \n     *  \n     * @param octxt\n     * @param browseBy\n     * @param regex\n     * @param max Maximum number of results to return.  0 means \"return all results\"  If more than max entries exist, only the first max are returned, sorted by frequency.  \n     * @return\n     * @throws IOException\n     * @throws ServiceException\n     */\n    public synchronized BrowseResult browse(OperationContext octxt, BrowseBy browseBy, String regex, int max) throws IOException, ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"browse\", octxt);\n            if (!hasFullAccess())\n                throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions on this mailbox\");\n            \n            BrowseResult browseResult = new BrowseResult();\n\n            MailboxIndex idx = getMailboxIndex();\n            if (idx != null) {\n                switch(browseBy) {\n                    case attachments:\n                        idx.getAttachments(regex, browseResult.getResult());\n                        break;\n                    case domains:\n                        HashMap<String, DomainItem> domainItems = new HashMap<String, DomainItem>();\n                        HashSet<BrowseTerm> set = new HashSet<BrowseTerm>();\n        \n                        idx.getDomainsForField(LuceneFields.L_H_CC, regex, set);\n                        addDomains(domainItems, set, DomainItem.F_CC);\n        \n                        set.clear();\n                        idx.getDomainsForField(LuceneFields.L_H_FROM, regex, set);\n                        addDomains(domainItems, set, DomainItem.F_FROM);\n        \n                        set.clear();             \n                        idx.getDomainsForField(LuceneFields.L_H_TO, regex, set);\n                        addDomains(domainItems, set, DomainItem.F_TO);\n                        \n                        browseResult.getResult().addAll(domainItems.values());\n                        break;\n                    case objects:\n                        idx.getObjects(regex, browseResult.getResult());\n                        break;\n                    default:\n                        throw new IllegalArgumentException(\"Unknown browseBy: \"+browseBy);\n                }\n            }\n            \n            if (max > 0) {\n                if (browseResult.getResult().size() > max) {\n                    Comparator<BrowseTerm> reverseComp= new Comparator<BrowseTerm>() {\n                        public int compare(BrowseTerm o1, BrowseTerm o2) {\n                            int retVal = o2.freq - o1.freq;\n                            if (retVal == 0) {\n                                retVal = o1.term.compareTo(o2.term);\n                            }\n                            return retVal;\n                        }\n                    };\n//                    {\n//                        StringBuilder sb = new StringBuilder(\"UNSORTED: \");\n//                        for (BrowseTerm term : browseResult.getResult()) {\n//                            sb.append(term.term).append('(').append(term.freq).append(\"),\");\n//                        }\n//                        ZimbraLog.mailbox.info(sb.toString());\n//                    }\n                    \n                    Collections.sort(browseResult.getResult(), reverseComp);\n//                    {\n//                        StringBuilder sb = new StringBuilder(\"SORTED: \");\n//                        for (BrowseTerm term : browseResult.getResult()) {\n//                            sb.append(term.term).append('(').append(term.freq).append(\"),\");\n//                        }\n//                        ZimbraLog.mailbox.info(sb.toString());\n//                    }\n                    \n                    int num = 0;\n                    for (Iterator<BrowseTerm> iter = browseResult.getResult().iterator(); iter.hasNext(); ) {\n                        BrowseTerm curTerm = iter.next();\n//                        ZimbraLog.mailbox.info(\"Checking: \"+curTerm.term+\"(\"+curTerm.freq+\")\");\n                        if (++num > max)\n                            iter.remove();\n                    }\n                }\n            }\n                    \n//                }\n//                if (browseBy == BROWSE_BY_ATTACHMENTS) {\n//                    idx.getAttachments(browseResult.getResult());\n//                } else if (browseBy == BROWSE_BY_DOMAINS) {\n//                    HashMap<String, DomainItem> domainItems = new HashMap<String, DomainItem>();\n//                    HashSet<String> set = new HashSet<String>();\n//    \n//                    idx.getDomainsForField(LuceneFields.L_H_CC, set);\n//                    addDomains(domainItems, set, DomainItem.F_CC);\n//    \n//                    set.clear();\n//                    idx.getDomainsForField(LuceneFields.L_H_FROM, set);\n//                    addDomains(domainItems, set, DomainItem.F_FROM);\n//    \n//                    set.clear();             \n//                    idx.getDomainsForField(LuceneFields.L_H_TO, set);\n//                    addDomains(domainItems, set, DomainItem.F_TO);\n//    \n//                    browseResult.getResult().addAll(domainItems.values());\n//                } else if (browseBy == BROWSE_BY_OBJECTS) {\n//                    idx.getObjects(browseResult.getResult());\n//                } else { \n//                    // throw exception?\n//                }\n//            }\n            success = true;\n            return browseResult;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void dismissCalendarItemAlarm(OperationContext octxt, int calItemId, long dismissedAt)\n    throws ServiceException {\n        DismissCalendarItemAlarm redoRecorder = new DismissCalendarItemAlarm(getId(), calItemId, dismissedAt);\n        boolean success = false;\n        try {\n            beginTransaction(\"setLastAlarm\", octxt, redoRecorder);\n            CalendarItem calItem = getCalendarItemById(octxt, calItemId);\n            if (calItem == null)\n                throw MailServiceException.NO_SUCH_CALITEM(calItemId);\n            calItem.updateNextAlarm(dismissedAt + 1);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public static class SetCalendarItemData {\n        public Invite mInv;\n        public ParsedMessage mPm;\n\n        public String toString() {\n            StringBuilder toRet = new StringBuilder();\n            toRet.append(\"inv:\").append(mInv.toString()).append(\"\\n\");\n            return toRet.toString();\n        }\n    }\n\n    public synchronized int setCalendarItem(OperationContext octxt, int folderId,\n                                            SetCalendarItemData defaultInv,\n                                            SetCalendarItemData exceptions[],\n                                            List<ReplyInfo> replies)\n    throws ServiceException {\n        return setCalendarItem(octxt, folderId, 0, 0, defaultInv, exceptions, replies, 0);\n    }\n\n    /**\n     * @param octxt\n     * @param exceptions can be NULL\n     * @return calendar item ID \n     * @throws ServiceException\n     */\n    public synchronized int setCalendarItem(OperationContext octxt, int folderId, int flags, long tags,\n                                            SetCalendarItemData defaultInv,\n                                            SetCalendarItemData exceptions[],\n                                            List<ReplyInfo> replies, long nextAlarm)\n    throws ServiceException {\n        flags = (flags & ~Flag.FLAG_SYSTEM);\n        SetCalendarItem redoRecorder = new SetCalendarItem(getId(), attachmentsIndexingEnabled(), flags, tags);\n        \n        boolean deferIndexing = true;\n        \n        boolean success = false;\n        try {\n            beginTransaction(\"setCalendarItem\", octxt, redoRecorder);\n            SetCalendarItem redoPlayer = (octxt == null ? null : (SetCalendarItem) octxt.getPlayer());\n\n            // allocate IDs for all of the passed-in invites (and the calendar item!) if necessary\n            if (redoPlayer == null || redoPlayer.getCalendarItemId() == 0) {\n                if (defaultInv != null)\n                defaultInv.mInv.setInviteId(getNextItemId(Mailbox.ID_AUTO_INCREMENT));\n                if (exceptions != null) {\n                    for (SetCalendarItemData sad : exceptions)\n                        sad.mInv.setMailItemId(getNextItemId(Mailbox.ID_AUTO_INCREMENT));\n                }\n            }\n            redoRecorder.setData(defaultInv, exceptions, replies, nextAlarm);\n\n            short volumeId = redoPlayer == null ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n\n            // Make a single list containing default and exceptions.\n            int scidLen = (defaultInv != null ? 1 : 0) + (exceptions != null ? exceptions.length : 0);\n            List<SetCalendarItemData> scidList = new ArrayList<SetCalendarItemData>(scidLen);\n            if (defaultInv != null)\n                scidList.add(defaultInv);\n            if (exceptions != null) {\n                for (SetCalendarItemData scid : exceptions) {\n                    scidList.add(scid);\n                }\n            }\n\n            // bug 19868: Preserve invId of existing Invites.  We have to do this before making any\n            // calls to processNewInvite() because it'll delete all existing Invites and we'll lose\n            // old invId information.\n            if (!scidList.isEmpty()) {\n                CalendarItem existingCalItem = getCalendarItemByUid(scidList.get(0).mInv.getUid());\n                if (existingCalItem != null) {\n                    for (SetCalendarItemData scid : scidList) {\n                        Invite currInv = existingCalItem.getInvite(scid.mInv.getRecurId());\n                        if (currInv != null)\n                            scid.mInv.setInviteId(currInv.getMailItemId());\n                    }\n                }\n            }\n\n            boolean first = true;\n            CalendarItem calItem = null;\n            boolean calItemIsNew = true;\n            long oldNextAlarm = 0;\n            for (SetCalendarItemData scid : scidList) {\n                if (first) {\n                    // usually the default invite\n                    first = false;\n                    calItem = getCalendarItemByUid(scid.mInv.getUid());\n                    calItemIsNew = calItem == null;\n                    if (calItemIsNew) {\n                        if (deferIndexing) {\n                            flags |= Flag.BITMASK_INDEXING_DEFERRED;\n                            incrementIndexDeferredCount(1);\n                        }\n                        \n                        // ONLY create an calendar item if this is a REQUEST method...otherwise don't.\n                        String method = scid.mInv.getMethod();\n                        if (\"REQUEST\".equals(method) || \"PUBLISH\".equals(method)) {\n                            calItem = createCalendarItem(\n                                    folderId, volumeId, flags, tags,\n                                    scid.mInv.getUid(), scid.mPm, scid.mInv, 0);\n                        } else {\n                            return 0; // for now, just ignore this Invitation\n                        }\n                    } else {\n                        // Preserve alarm time before any modification is made to the item.\n                        AlarmData alarmData = calItem.getAlarmData();\n                        if (alarmData != null)\n                            oldNextAlarm = alarmData.getNextAt();\n\n                        calItem.setTags(flags, tags);\n                        calItem.processNewInvite(scid.mPm, scid.mInv, folderId, volumeId,\n                                                 nextAlarm, false, true);\n                    }\n                    redoRecorder.setCalendarItemAttrs(calItem.getId(), calItem.getFolderId(), volumeId);\n                } else {\n                    // exceptions\n                    calItem.processNewInvite(scid.mPm, scid.mInv, folderId, volumeId, nextAlarm, false, false);\n                }\n            }\n\n            // Recompute alarm time after processing all Invites.\n            if (nextAlarm == 0)\n                nextAlarm = oldNextAlarm;\n            calItem.updateNextAlarm(nextAlarm);\n\n            // Override replies list if one is provided.\n            // Null list means keep existing replies.  Empty list means to clear existing replies.\n            // List with one or more replies means replacing existing replies.\n            if (replies != null)\n                calItem.setReplies(replies);\n            \n            queueForIndexing(calItem, !calItemIsNew, null);\n            \n            success = true;\n            return calItem.getId();\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * Fix up timezone definitions in all appointments/tasks in the mailbox.\n     * @param octxt\n     * @param after only fix calendar items that have instances after this time\n     * @param fixupRules\n     * @return\n     * @throws ServiceException\n     */\n    public int fixAllCalendarItemTZ(\n            OperationContext octxt, long after, TimeZoneFixupRules fixupRules)\n    throws ServiceException {\n        int numFixedCalItems = 0;\n        int numFixedTZs = 0;\n        ZimbraLog.calendar.info(\"Started: timezone fixup in calendar of mailbox \" + getId());\n        List[] lists = new List[2];\n        lists[0] = getItemList(octxt, MailItem.TYPE_APPOINTMENT);\n        lists[1] = getItemList(octxt, MailItem.TYPE_TASK);\n        for (List items : lists) {\n            for (Iterator iter = items.iterator(); iter.hasNext(); ) {\n                Object obj = iter.next();\n                if (!(obj instanceof CalendarItem))\n                    continue;\n                CalendarItem calItem = (CalendarItem) obj;\n                long end = calItem.getEndTime();\n                if (end <= after)\n                    continue;\n                try {\n                    int num = fixCalendarItemTZ(octxt, calItem.getId(), fixupRules);\n                    numFixedTZs += num;\n                    if (num > 0)\n                        numFixedCalItems++;\n                } catch (ServiceException e) {\n                    ZimbraLog.calendar.error(\n                            \"Error fixing calendar item \" + calItem.getId() +\n                            \" in mailbox \" + getId() + \": \" + e.getMessage(), e);\n                }\n            }\n        }\n        ZimbraLog.calendar.info(\n                \"Finished: timezone fixup in calendar of mailbox \" +\n                getId() + \"; fixed \" + numFixedTZs + \" timezone entries in \" +\n                numFixedCalItems + \" calendar items\");\n        return numFixedCalItems;\n    }\n\n    /**\n     * Fix up timezone definitions in an appointment/task.  Fixup is\n     * required when governments change the daylight savings policy.\n     * @param octxt\n     * @param calItemId\n     * @param fixupRules rules specifying which timezones to fix and how\n     * @return number of timezone objects that were modified\n     * @throws ServiceException\n     */\n    public synchronized int fixCalendarItemTZ(\n            OperationContext octxt, int calItemId, TimeZoneFixupRules fixupRules)\n    throws ServiceException {\n        FixCalendarItemTZ redoRecorder = new FixCalendarItemTZ(getId(), calItemId);\n        boolean success = false;\n        try {\n            beginTransaction(\"fixCalendarItemTimeZone2\", octxt, redoRecorder);\n            CalendarItem calItem = getCalendarItemById(octxt, calItemId);\n            Map<String, ICalTimeZone> replaced = new HashMap<String, ICalTimeZone>();\n            int numFixed = fixupRules.fixCalendarItem(calItem, replaced);\n            if (numFixed > 0) {\n                ZimbraLog.calendar.info(\"Fixed \" + numFixed + \" timezone entries in calendar item \" + calItem.getId());\n                redoRecorder.setReplacementMap(replaced);\n                calItem.saveMetadata();\n                // Need to uncache and refetch the item because there are fields\n                // in the appointment/task that reference the old, pre-fix version\n                // of the timezones.  We can either visit them all and update them,\n                // or simply invalidate the calendar item and refetch it.\n                uncacheItem(calItemId);\n                calItem = getCalendarItemById(octxt, calItemId);\n                markItemModified(calItem, Change.MODIFIED_CONTENT | Change.MODIFIED_INVITE);\n                success = true;\n            }\n            return numFixed;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * Fix up timezone definitions in all appointments/tasks in the mailbox.\n     * @param octxt\n     * @param after\n     * @param country\n     * @return\n     * @throws ServiceException\n     */\n    public int fixAllCalendarItemTimeZone(\n            OperationContext octxt, long after, String country)\n    throws ServiceException {\n        int numFixed = 0;\n        ZimbraLog.calendar.info(\"Started: timezone fixup in calendar of mailbox \" + getId());\n        List[] lists = new List[2];\n        lists[0] = getItemList(octxt, MailItem.TYPE_APPOINTMENT);\n        lists[1] = getItemList(octxt, MailItem.TYPE_TASK);\n        for (List items : lists) {\n            for (Iterator iter = items.iterator(); iter.hasNext(); ) {\n                Object obj = iter.next();\n                if (!(obj instanceof CalendarItem))\n                    continue;\n                CalendarItem calItem = (CalendarItem) obj;\n                long end = calItem.getEndTime();\n                if (end < after)\n                    continue;\n                try {\n                    numFixed += fixCalendarItemTimeZone(octxt, calItem.getId(), after, country);\n                } catch (ServiceException e) {\n                    ZimbraLog.calendar.error(\n                            \"Error fixing calendar item \" + calItem.getId() +\n                            \" in mailbox \" + getId() + \": \" + e.getMessage(), e);\n                }\n            }\n        }\n        ZimbraLog.calendar.info(\n                \"Finished: timezone fixup in calendar of mailbox \" +\n                getId() + \"; fixed \" + numFixed + \" timezone entries\");\n        return numFixed;\n    }\n\n    /**\n     * Fix up timezone definitions in an appointment/task.  Fixup is\n     * required when governments change the daylight savings policy.\n     * @param octxt\n     * @param calItemId\n     * @param after only look at appointments/tasks that have instances after\n     *              this date/time\n     * @param country two-letter country code; apply fixup specific to this country;\n     *                default is null and means fixup will apply only the unambiguous\n     *                timezone changes\n     * @return number of timezone objects that were modified\n     * @throws ServiceException\n     */\n    public synchronized int fixCalendarItemTimeZone(\n            OperationContext octxt, int calItemId, long after, String country)\n    throws ServiceException {\n        FixCalendarItemTimeZone redoRecorder =\n            new FixCalendarItemTimeZone(getId(), calItemId, after, country);\n        boolean success = false;\n        try {\n            beginTransaction(\"fixCalendarItemTimeZone\", octxt, redoRecorder);\n            CalendarItem calItem = getCalendarItemById(octxt, calItemId);\n            int numFixed = TimeZoneFixup.fixCalendarItem(calItem, country);\n            if (numFixed > 0) {\n                ZimbraLog.calendar.info(\"Fixed \" + numFixed + \" timezone entries in calendar item \" + calItem.getId());\n                calItem.saveMetadata();\n                // Need to uncache and refetch the item because there are fields\n                // in the appointment/task that reference the old, pre-fix version\n                // of the timezones.  We can either visit them all and update them,\n                // or simply invalidate the calendar item and refetch it.\n                uncacheItem(calItemId);\n                calItem = getCalendarItemById(octxt, calItemId);\n                markItemModified(calItem, Change.MODIFIED_CONTENT | Change.MODIFIED_INVITE);\n                success = true;\n            }\n            return numFixed;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public int fixAllCalendarItemEndTime(OperationContext octxt)\n    throws ServiceException {\n        int numFixed = 0;\n        ZimbraLog.calendar.info(\"Started: end time fixup in calendar of mailbox \" + getId());\n        List[] lists = new List[2];\n        lists[0] = getItemList(octxt, MailItem.TYPE_APPOINTMENT);\n        lists[1] = getItemList(octxt, MailItem.TYPE_TASK);\n        for (List items : lists) {\n            for (Iterator iter = items.iterator(); iter.hasNext(); ) {\n                Object obj = iter.next();\n                if (!(obj instanceof CalendarItem))\n                    continue;\n                CalendarItem calItem = (CalendarItem) obj;\n                try {\n                    numFixed += fixCalendarItemEndTime(octxt, calItem);\n                } catch (ServiceException e) {\n                    ZimbraLog.calendar.error(\n                            \"Error fixing calendar item \" + calItem.getId() +\n                            \" in mailbox \" + getId() + \": \" + e.getMessage(), e);\n                }\n            }\n        }\n        ZimbraLog.calendar.info(\n                \"Finished: end time fixup in calendar of mailbox \" +\n                getId() + \"; fixed \" + numFixed + \" timezone entries\");\n        return numFixed;\n    }\n\n    public synchronized int fixCalendarItemEndTime(OperationContext octxt, CalendarItem calItem)\n    throws ServiceException {\n        FixCalendarItemEndTime redoRecorder = new FixCalendarItemEndTime(getId(), calItem.getId());\n        boolean success = false;\n        try {\n            beginTransaction(\"fixupCalendarItemEndTime\", octxt, redoRecorder);\n            int numFixed = calItem.fixRecurrenceEndTime();\n            if (numFixed > 0) {\n                ZimbraLog.calendar.info(\"Fixed calendar item \" + calItem.getId());\n                markItemModified(calItem, Change.MODIFIED_CONTENT | Change.MODIFIED_INVITE);\n                success = true;\n            }\n            return numFixed;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public int[] addInvite(OperationContext octxt, Invite inv, int folderId)\n    throws ServiceException {\n        maybeIndexDeferredItems();\n        return addInvite(octxt, inv, folderId, null, false, false);\n    }\n\n    public int[] addInvite(OperationContext octxt, Invite inv, int folderId, ParsedMessage pm)\n    throws ServiceException {\n        maybeIndexDeferredItems();\n        return addInvite(octxt, inv, folderId, pm, false, false);\n    }\n\n    public int[] addInvite(OperationContext octxt, Invite inv, int folderId, boolean preserveExistingAlarms)\n    throws ServiceException {\n        maybeIndexDeferredItems();\n        return addInvite(octxt, inv, folderId, null, preserveExistingAlarms, false);\n    }\n\n    /**\n     * Directly add an Invite into the system...this process also gets triggered when we add a Message\n     * that has a text/calendar Mime part: but this API is useful when you don't want to add a corresponding\n     * message.\n     * @param octxt\n     * @param inv\n     * @param pm NULL is OK here\n     * @param preserveExistingAlarms\n     * @param discardExistingInvites\n     * \n     * @return int[2] = { calendar-item-id, invite-mail-item-id }  Note that even though the invite has a mail-item-id, that mail-item does not really exist, it can ONLY be referenced through the calendar item \"calItemId-invMailItemId\"\n     * @throws ServiceException\n     */\n    public int[] addInvite(OperationContext octxt, Invite inv, int folderId, ParsedMessage pm,\n                           boolean preserveExistingAlarms, boolean discardExistingInvites)\n    throws ServiceException {\n        if (pm == null) {\n            inv.setDontIndexMimeMessage(true); // the MimeMessage is fake, so we don't need to index it\n            MimeMessage mm = CalendarMailSender.createCalendarMessage(inv);\n            pm = new ParsedMessage(mm, octxt == null ? System.currentTimeMillis() : octxt.getTimestamp(), true);\n        }\n\n        byte[] data = null;\n        try {\n            data = pm.getRawData();\n        } catch (MessagingException me) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(me);\n        } catch (IOException ioe) {\n            throw ServiceException.FAILURE(\"Caught IOException\", ioe);\n        }\n\n        CreateInvite redoRecorder =\n            new CreateInvite(mId, inv, folderId, data, preserveExistingAlarms, discardExistingInvites);\n\n        synchronized(this) {\n            boolean success = false;\n            try {\n                beginTransaction(\"addInvite\", octxt, redoRecorder);\n                CreateInvite redoPlayer = (octxt == null ? null : (CreateInvite) octxt.getPlayer());\n                short volumeId = redoPlayer == null ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n                \n                if (redoPlayer == null || redoPlayer.getCalendarItemId() == 0) {\n                    inv.setInviteId(getNextItemId(Mailbox.ID_AUTO_INCREMENT));\n                }\n                \n                boolean calItemIsNew = false;\n                CalendarItem calItem = getCalendarItemByUid(inv.getUid());\n                if (calItem == null) { \n                    // ONLY create an calendar item if this is a REQUEST method...otherwise don't.\n                    if (inv.getMethod().equals(\"REQUEST\") || inv.getMethod().equals(\"PUBLISH\")) {\n                        int flags = Flag.BITMASK_INDEXING_DEFERRED;\n                        incrementIndexDeferredCount(1);\n                        calItem = createCalendarItem(folderId, volumeId, flags, 0, inv.getUid(), pm, inv, 0);\n                        calItemIsNew = true;\n                    } else {\n//                      mLog.info(\"Mailbox \" + getId()+\" Message \"+getId()+\" SKIPPING Invite \"+method+\" b/c not a REQUEST and no CalendarItem could be found\");\n                        return null; // for now, just ignore this Invitation\n                    }\n                } else {\n                    if (!checkItemChangeID(calItem))\n                        throw MailServiceException.MODIFY_CONFLICT();\n                    if (inv.getMethod().equals(\"REQUEST\") || inv.getMethod().equals(\"PUBLISH\")) {\n                        // Preserve invId.  (bug 19868)\n                        Invite currInv = calItem.getInvite(inv.getRecurId());\n                        if (currInv != null)\n                            inv.setInviteId(currInv.getMailItemId());\n                    }\n                    calItem.processNewInvite(pm, inv, folderId, volumeId, 0,\n                                             preserveExistingAlarms, discardExistingInvites);\n                }\n                \n                queueForIndexing(calItem, !calItemIsNew, null);\n                redoRecorder.setCalendarItemAttrs(calItem.getId(), calItem.getFolderId(), volumeId);\n                \n                success = true;\n                return new int[] { calItem.getId(), inv.getMailItemId() };\n            } finally {\n                endTransaction(success);\n            }\n        }\n    }\n\n    public synchronized CalendarItem getCalendarItemByUid(String uid) throws ServiceException {\n        return getCalendarItemByUid(null, uid);\n    }\n    public synchronized CalendarItem getCalendarItemByUid(OperationContext octxt, String uid) throws ServiceException {\n        boolean success = false;\n        try {\n            beginTransaction(\"getCalendarItemByUid\", octxt);\n            MailItem.UnderlyingData data = DbMailItem.getCalendarItem(this, uid);\n            CalendarItem calItem = (CalendarItem) getItem(data);\n            success = true;\n            return calItem;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    private static final String DEDUPE_ALL    = \"dedupeAll\";\n    private static final String DEDUPE_INBOX  = \"moveSentMessageToInbox\";\n    private static final String DEDUPE_SECOND = \"secondCopyifOnToOrCC\";\n\n    private boolean dedupe(MimeMessage mm, Integer sentMsgId) throws ServiceException {\n        Account acct = getAccount();\n        String pref = acct.getAttr(Provisioning.A_zimbraPrefDedupeMessagesSentToSelf, null);\n        if (pref == null) {                                 // default to no deduping\n            return false;\n        } else if (pref.equalsIgnoreCase(DEDUPE_ALL)) {     // remove all duplicates\n            return true;\n        } else if (pref.equalsIgnoreCase(DEDUPE_SECOND)) {  // receive if we're not a direct recipient (to, cc, bcc)\n            try {\n                return !AccountUtil.isDirectRecipient(acct, mm);\n            } catch (Exception e) {\n                return false;\n            }\n        } else if (pref.equalsIgnoreCase(DEDUPE_INBOX)) {   // move the existing mail from sent to inbox\n                // XXX: not implemented\n                return false;\n        } else {\n                return false;\n    }\n    }\n\n    public int getConversationIdFromReferent(MimeMessage newMsg, int parentID) {\n        try {\n            // file into same conversation as parent message as long as subject hasn't really changed\n            Message parentMsg = getMessageById(null, parentID);\n            if (parentMsg.getNormalizedSubject().equals(ParsedMessage.normalize(newMsg.getSubject())))\n                return parentMsg.getConversationId();\n        } catch (Exception e) {\n            if (!(e instanceof MailServiceException.NoSuchItemException))\n                ZimbraLog.mailbox.warn(\"ignoring error while checking conversation: \" + parentID, e);\n        }\n        return ID_AUTO_INCREMENT;\n    }\n\n    /**\n     * Process an iCalendar REPLY containing a single VEVENT or VTODO.\n     * @param octxt\n     * @param inv REPLY iCalendar object\n     * @throws ServiceException\n     */\n    public synchronized void processICalReply(OperationContext octxt, Invite inv)\n    throws ServiceException {\n        ICalReply redoRecorder = new ICalReply(getId(), inv);\n        boolean success = false;\n        try {\n            beginTransaction(\"iCalReply\", octxt, redoRecorder);\n            String uid = inv.getUid();\n            CalendarItem calItem = getCalendarItemByUid(uid);\n            if (calItem == null) {\n                ZimbraLog.calendar.warn(\n                        \"Unknown calendar item UID \" + uid + \" in mailbox \" + getId());\n                return;\n            }\n            boolean added = calItem.processNewInviteReply(inv);\n// Do we _really_ need to reindex the CalendarItem when we receive a reply?  Not sure we do -tim  \n//            if (added) \n//                queueForIndexing(calItem, true, null);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    private AuthToken getAuthToken(OperationContext octxt) throws ServiceException {\n        AuthToken authToken = octxt == null ? null : octxt.getAuthToken();\n        \n        if (authToken == null) {\n            Account authuser = octxt == null ? getAccount() : octxt.getAuthenticatedUser();\n            boolean isAdminRequest = octxt == null ? false : octxt.isUsingAdminPrivileges();\n            authToken = AuthProvider.getAuthToken(authuser, isAdminRequest);\n        }\n        return authToken;\n    }\n    \n    private void processICalReplies(OperationContext octxt, ZVCalendar cal)\n    throws ServiceException {\n        List<Invite> components = Invite.createFromCalendar(getAccount(), null, cal, false);\n        for (Invite inv : components) {\n            String orgAddress;\n            if (inv.hasOrganizer()) {\n                ZOrganizer org = inv.getOrganizer();\n                orgAddress = org.getAddress();\n            } else {\n                ZimbraLog.calendar.warn(\"No ORGANIZER found in REPLY.  Assuming current mailbox.\");\n                orgAddress = getAccount().getName();\n            }\n            if (AccountUtil.addressMatchesAccount(getAccount(), orgAddress)) {\n                processICalReply(octxt, inv);\n            } else {\n                Account orgAccount = inv.getOrganizerAccount();\n                // Unknown organizer\n                if (orgAccount == null) {\n                    ZimbraLog.calendar.warn(\"Unknown organizer \" + orgAddress + \" in REPLY\");\n                    continue;\n                }\n                if (Provisioning.onLocalServer(orgAccount)) {\n                    // Run in the context of organizer's mailbox.\n                    Mailbox mbox = MailboxManager.getInstance().getMailboxByAccount(orgAccount);\n                    OperationContext orgOctxt = new OperationContext(mbox);\n                    mbox.processICalReply(orgOctxt, inv);\n                } else {\n                    // Organizer's mailbox is on a remote server.\n                    String uri = AccountUtil.getSoapUri(orgAccount);\n                    if (uri == null) {\n                        ZimbraLog.calendar.warn(\"Unable to determine URI for organizer account \" + orgAddress);\n                        continue;\n                    }\n                    try {\n                        // TODO: Get the iCalendar data from the\n                        // MIME part since we already have it.\n                        String ical;\n                        StringWriter sr = null;\n                        try {\n                            sr = new StringWriter();\n                            inv.newToICalendar(true).toICalendar(sr);\n                            ical = sr.toString();\n                        } finally {\n                            if (sr != null)\n                                sr.close();\n                        }\n                        Options options = new Options();\n                        options.setAuthToken(getAuthToken(octxt).toZAuthToken());\n                        options.setTargetAccount(orgAccount.getName());\n                        options.setTargetAccountBy(AccountBy.name);\n                        options.setUri(uri);\n                        options.setNoSession(true);\n                        ZMailbox zmbox = ZMailbox.getMailbox(options);\n                        zmbox.iCalReply(ical);\n                    } catch (IOException e) {\n                        throw ServiceException.FAILURE(\"Error while posting REPLY to organizer mailbox host\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    public Message addMessage(OperationContext octxt, ParsedMessage pm, int folderId, boolean noICal, int flags, String tags, int conversationId)\n    throws IOException, ServiceException {\n        SharedDeliveryContext sharedDeliveryCtxt = new SharedDeliveryContext();\n        return addMessage(octxt, pm, folderId, noICal, flags, tags, conversationId, \":API:\", sharedDeliveryCtxt);\n    } \n\n    public Message addMessage(OperationContext octxt, ParsedMessage pm, int folderId, boolean noICal, int flags, String tags)\n    throws IOException, ServiceException {\n        SharedDeliveryContext sharedDeliveryCtxt = new SharedDeliveryContext();\n        return addMessage(octxt, pm, folderId, noICal, flags, tags, ID_AUTO_INCREMENT, \":API:\", sharedDeliveryCtxt);\n    }\n\n    public Message addMessage(OperationContext octxt, ParsedMessage pm, int folderId, boolean noICal, int flags, String tags,\n                String rcptEmail, SharedDeliveryContext sharedDeliveryCtxt)\n    throws IOException, ServiceException {\n        return addMessage(octxt, pm, folderId, noICal, flags, tags, ID_AUTO_INCREMENT, rcptEmail, sharedDeliveryCtxt);\n    }\n\n    public Message addMessage(OperationContext octxt, ParsedMessage pm, int folderId,\n                boolean noICal, int flags, String tagStr, int conversationId,\n                String rcptEmail, SharedDeliveryContext sharedDeliveryCtxt)\n    throws IOException, ServiceException {\n        int batchIndexCount = getBatchedIndexingCount();\n        maybeIndexDeferredItems();\n        // make sure the message has been analyzed before taking the Mailbox lock\n        if (batchIndexCount == 0)\n            pm.analyzeFully();\n\n        // and then actually add the message\n        long start = ZimbraPerf.STOPWATCH_MBOX_ADD_MSG.start();\n\n        // We process calendar replies here, where no transaction has yet\n        // been started on the current mailbox.  This is because some replies\n        // may require starting a transaction on another mailbox.  We thus avoid\n        // starting a nested transaction, which doesn't work.\n        //\n        // In addition, the current mailbox is not locked/synchronized at this\n        // point.  If we were synchronized and a reply processing enters a\n        // synchronized method on another mailbox, we're locking two mailboxes\n        // and that can easily lead to deadlocks.\n        //\n        // TODO: Generalize this technique for all calendar operations, not\n        // just REPLY's.\n        //\n        if (!noICal) {\n            try {\n                ZVCalendar cal = pm.getiCalendar();\n                if (cal != null) {\n                    ICalTok method = cal.getMethod();\n                    if (ICalTok.REPLY.equals(method)) {\n                        processICalReplies(octxt, cal);\n                        noICal = true;\n                    }\n                }\n            } catch (Exception e) {\n                ZimbraLog.calendar.warn(\"Error during calendar processing.  Continuing with message add\", e);\n            }\n        }\n\n        Message msg = addMessageInternal(octxt, pm, folderId, noICal, flags, tagStr, conversationId, rcptEmail, null, sharedDeliveryCtxt);\n        ZimbraPerf.STOPWATCH_MBOX_ADD_MSG.stop(start);\n        return msg;\n    }\n\n    private synchronized Message addMessageInternal(OperationContext octxt, ParsedMessage pm, int folderId,\n                boolean noICal, int flags, String tagStr, int conversationId, \n                String rcptEmail, Message.DraftInfo dinfo, SharedDeliveryContext sharedDeliveryCtxt)\n    throws IOException, ServiceException {\n        if (pm == null)\n            throw ServiceException.INVALID_REQUEST(\"null ParsedMessage when adding message to mailbox \" + mId, null);\n\n        boolean debug = ZimbraLog.mailbox.isDebugEnabled();\n\n        if (conversationId <= HIGHEST_SYSTEM_ID)\n            conversationId = ID_AUTO_INCREMENT;\n\n        boolean needRedo = octxt == null || octxt.needRedo();\n        CreateMessage redoPlayer = (octxt == null ? null : (CreateMessage) octxt.getPlayer());\n        boolean isRedo = redoPlayer != null;\n\n        // quick check to make sure we don't deliver 5 copies of the same message\n        String msgidHeader = pm.getMessageID();\n        boolean isSent = ((flags & Flag.BITMASK_FROM_ME) != 0);\n        boolean checkDuplicates = (!isRedo && msgidHeader != null);\n        if (checkDuplicates && !isSent && mSentMessageIDs.containsKey(msgidHeader)) {\n            Integer sentMsgID = (Integer) mSentMessageIDs.get(msgidHeader);\n            // if the rules say to drop this duplicated incoming message, return null now\n            // don't dedupe messages carrying calendar part\n            if (pm.getiCalendar() == null && dedupe(pm.getMimeMessage(), sentMsgID))\n                return null;\n            // if we're not dropping the new message, see if it goes in the same conversation as the old sent message\n            if (conversationId == ID_AUTO_INCREMENT) {\n                conversationId = getConversationIdFromReferent(pm.getMimeMessage(), sentMsgID.intValue());\n                if (debug)  ZimbraLog.mailbox.debug(\"  duplicate detected but not deduped (\" + msgidHeader + \"); \" +\n                                                    \"will try to slot into conversation \" + conversationId);\n            }\n        }\n\n        // caller can't set system flags other than \\Draft and \\Sent\n        flags &= ~Flag.FLAG_SYSTEM | Flag.BITMASK_DRAFT | Flag.BITMASK_FROM_ME;\n        // caller can't specify non-message flags\n        flags &= Flag.FLAGS_GENERIC | Flag.FLAGS_MESSAGE;\n\n        String digest;\n        int msgSize;\n        try {\n            digest = pm.getRawDigest();\n            msgSize = pm.getRawSize();\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"Unable to get message properties.\", e);\n        }\n        \n        CreateMessage redoRecorder = new CreateMessage(mId, rcptEmail, pm.getReceivedDate(), sharedDeliveryCtxt.getShared(),\n                                                       digest, msgSize, folderId, noICal, flags, tagStr);\n        StoreIncomingBlob storeRedoRecorder = null;\n\n        // strip out unread flag for internal storage (don't do this before redoRecorder initialization)\n        boolean unread = (flags & Flag.BITMASK_UNREAD) > 0;\n        flags &= ~Flag.BITMASK_UNREAD;\n\n        boolean isSpam = folderId == ID_FOLDER_SPAM;\n        boolean isDraft = (flags & Flag.BITMASK_DRAFT) != 0;\n\n        Message msg = null;\n        Blob blob = null;\n        MailboxBlob mboxBlob = null;\n        boolean success = false;\n        Folder folder = null;\n        boolean deferIndexing = (getBatchedIndexingCount() > 0 || pm.hasTemporaryAnalysisFailure());\n\n        try {\n            beginTransaction(\"addMessage\", octxt, redoRecorder);\n            if (isRedo)\n                rcptEmail = redoPlayer.getRcptEmail();\n\n            // \"having attachments\" is currently tracked via flags\n            if (pm.hasAttachments())\n                flags |= Flag.BITMASK_ATTACHED;\n            else\n                flags &= ~Flag.BITMASK_ATTACHED;\n\n            // priority is calculated from headers\n            flags &= ~(Flag.BITMASK_HIGH_PRIORITY | Flag.BITMASK_LOW_PRIORITY);\n            flags |= pm.getPriorityBitmask();\n            \n            // batched indexing\n            if (deferIndexing) {\n                flags |= Flag.BITMASK_INDEXING_DEFERRED;\n                incrementIndexDeferredCount(1);\n            }\n\n            folder = getFolderById(folderId);\n            String subject = pm.getNormalizedSubject();\n            long tags = Tag.tagsToBitmask(tagStr);\n\n            // step 1: get an ID assigned for the new message\n            int messageId  = getNextItemId(!isRedo ? ID_AUTO_INCREMENT : redoPlayer.getMessageId());\n            if (isRedo)\n                conversationId = redoPlayer.getConvId();\n\n            // step 2: figure out where the message belongs\n            Conversation conv = null;\n            String hash = null;\n            if (!DebugConfig.disableConversation) {\n                if (conversationId != ID_AUTO_INCREMENT) {\n                    try {\n                        conv = getConversationById(conversationId);\n                        if (debug)  ZimbraLog.mailbox.debug(\"  fetched explicitly-specified conversation \" + conv.getId());\n                    } catch (ServiceException e) {\n                        if (e.getCode() != MailServiceException.NO_SUCH_CONV)\n                            throw e;\n                        if (debug)  ZimbraLog.mailbox.debug(\"  could not find explicitly-specified conversation \" + conversationId);\n                    }\n                } else if (!isRedo && !isSpam && !isDraft && pm.isReply()) {\n                    conv = getConversationByHash(hash = getHash(subject));\n                    if (debug)  ZimbraLog.mailbox.debug(\"  found conversation \" + (conv == null ? -1 : conv.getId()) + \" for hash: \" + hash);\n                    // the caller can specify the received date via ParsedMessge constructor or X-Zimbra-Received header\n                    if (conv != null && pm.getReceivedDate() > conv.getDate() + Constants.MILLIS_PER_MONTH) {\n                        // if the last message in the conv was more than 1 month ago, it's probably not related...\n                        conv = null;\n                        if (debug)  ZimbraLog.mailbox.debug(\"  but rejected it because it's too old\");\n                    }\n                }\n            }\n\n            // step 3: create the message and update the cache\n            //         and if the message is also an invite, deal with the calendar item\n            Conversation convTarget = (conv instanceof VirtualConversation ? null : conv);\n            if (convTarget != null && debug)\n                ZimbraLog.mailbox.debug(\"  placing message in existing conversation \" + convTarget.getId());\n\n            short volumeId = !isRedo ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n            ZVCalendar iCal = pm.getiCalendar();\n            msg = Message.create(messageId, folder, convTarget, pm, msgSize, digest,\n                        volumeId, unread, flags, tags, dinfo, noICal, iCal);\n\n            redoRecorder.setMessageId(msg.getId());\n\n            // step 4: create a conversation for the message, if necessary\n            if (!DebugConfig.disableConversation && convTarget == null) {\n                if (conv == null && conversationId == ID_AUTO_INCREMENT) {\n                    conv = VirtualConversation.create(this, msg);\n                    if (debug)  ZimbraLog.mailbox.debug(\"  placed message \" + msg.getId() + \" in vconv \" + conv.getId());\n                    redoRecorder.setConvFirstMsgId(-1);\n                } else {\n                    Message[] contents = null;\n                    VirtualConversation vconv = null;\n                    if (!isRedo) {\n                        vconv = (VirtualConversation) conv;\n                        contents = (conv == null ? new Message[] { msg } : new Message[] { vconv.getMessage(), msg });\n                    } else {\n                        // Executing redo.\n                        int convFirstMsgId = redoPlayer.getConvFirstMsgId();\n                        Message convFirstMsg = null;\n                        // If there was a virtual conversation, then...\n                        if (convFirstMsgId > 0) {\n                            try {\n                                convFirstMsg = getMessageById(octxt, redoPlayer.getConvFirstMsgId());\n                            } catch (MailServiceException e) {\n                                if (!MailServiceException.NO_SUCH_MSG.equals(e.getCode()))\n                                    throw e;\n                                // The first message of conversation may have been deleted\n                                // by user between the time of original operation and redo.\n                                // Handle the case by skipping the updating of its\n                                // conversation ID.\n                            }\n                            // The message may have become part of a real conversation\n                            // between the original operation and redo.  Leave it alone\n                            // in that case, and only join it to this message's conversation\n                            // if it is still a standalone message.\n                            if (convFirstMsg != null && convFirstMsg.getConversationId() < 0) {\n                                contents = new Message[] { convFirstMsg, msg };\n                                vconv = new VirtualConversation(this, convFirstMsg);\n                            }\n                        }\n                        if (contents == null)\n                            contents = new Message[] { msg };\n                    }\n                    redoRecorder.setConvFirstMsgId(vconv != null ? vconv.getMessageId() : -1);\n                    conv = createConversation(contents, conversationId);\n                    if (vconv != null) {\n                        if (debug)  ZimbraLog.mailbox.debug(\"  removed vconv \" + vconv.getId());\n                        vconv.removeChild(vconv.getMessage());\n                    }\n                }\n                if (!isSpam && !isDraft)\n                    openConversation(conv, hash);\n            } else {\n                // conversation feature turned off\n                redoRecorder.setConvFirstMsgId(-1);\n            }\n            redoRecorder.setConvId(conv != null && !(conv instanceof VirtualConversation) ? conv.getId() : -1);\n\n            // step 5: store the blob\n            // TODO: Add partition support.  Need to store as many times as there\n            //       are unique partitions in the set of recipient mailboxes.\n            StoreManager sm = StoreManager.getInstance();\n            if (sharedDeliveryCtxt.isFirst()) {\n                // This mailbox is the only recipient, or it is the first\n                // of multiple recipients.  Save message to incoming directory if\n                // it's not already there.\n                Blob preexisting = sharedDeliveryCtxt.getPreexistingBlob();\n                if (preexisting == null) {\n                    InputStream in = null;\n                    try {\n                        in = pm.getRawInputStream();\n                        if (!isRedo) {\n                            blob = sm.storeIncoming(in, msgSize, null, msg.getVolumeId());\n                        } else {\n                            // If message was delivered to a single recipient, ignore the path in the\n                            // redo item and store to a new incoming path.  (bug 22873)\n                            String path = sharedDeliveryCtxt.getShared() ? redoPlayer.getPath() : null;\n                            blob = sm.storeIncoming(in, msgSize, path, redoPlayer.getVolumeId());\n                        }\n                    } finally {\n                        ByteUtil.closeStream(in);\n                    }\n                } else {\n                    // Blob was already stored in incoming by the caller.\n                    sharedDeliveryCtxt.setBlob(preexisting);\n                    blob = preexisting;\n                }\n                String blobPath = blob.getPath();\n                short blobVolumeId = blob.getVolumeId();\n\n                if (sharedDeliveryCtxt.getShared()) {\n                    markOtherItemDirty(blob);\n\n                    // Log entry in redolog for blob save.  Blob bytes are\n                    // logged in StoreToIncoming entry.\n                    if (needRedo) {\n                        storeRedoRecorder = new StoreIncomingBlob(digest, msgSize, sharedDeliveryCtxt.getMailboxIdList());\n                        storeRedoRecorder.start(getOperationTimestampMillis());\n                        if (blob.isCompressed() || pm.wasMutated()) {\n                            storeRedoRecorder.setBlobBodyInfo(getData(pm), blobPath, blobVolumeId);\n                        } else {\n                            storeRedoRecorder.setBlobBodyInfo(blob.getFile(), blobVolumeId);\n                        }\n                        storeRedoRecorder.log();\n                    }\n\n                    // Create a link in mailbox directory and leave the incoming\n                    // copy alone, so other recipients can link to it later.\n                    redoRecorder.setMessageLinkInfo(blobPath, blobVolumeId, msg.getVolumeId());\n                    mboxBlob = sm.link(blob, this, messageId, msg.getSavedSequence(), msg.getVolumeId());\n                } else {\n                    // If the only recipient, move the incoming copy into\n                    // mailbox directory.  This is more efficient than\n                    // creating a link in mailbox directory and deleting\n                    // incoming copy.\n                    pm.closeFile();\n                    mboxBlob = sm.renameTo(blob, this, messageId, msg.getSavedSequence(), msg.getVolumeId());\n                    pm.fileMoved(mboxBlob.getBlob().getFile());\n\n                    // In single-recipient case the blob bytes are logged in\n                    // CreateMessage entry, to avoid having to write two\n                    // redolog entries for a single delivery.\n                    if (blob.isCompressed() || pm.wasMutated()) {\n                        redoRecorder.setMessageBodyInfo(getData(pm), blobPath, blobVolumeId);\n                    } else {\n                        redoRecorder.setMessageBodyInfo(mboxBlob.getBlob().getFile(), blobVolumeId);\n                    }\n                }\n            } else {\n                blob = sharedDeliveryCtxt.getBlob();\n                String srcPath;\n                Blob srcBlob;\n                MailboxBlob srcMboxBlob = sharedDeliveryCtxt.getMailboxBlob();\n                if (srcMboxBlob != null && srcMboxBlob.getMailbox().getId() == mId) {\n                    // With filter rules, a message can be copied to one or\n                    // more folders and optionally kept in Inbox, meaning\n                    // one delivery can result in multiple deliveries.  But\n                    // the first copy delivered will not know there are copies\n                    // coming, and if there was only one recipient for the\n                    // message, we will end up doing the rename case above.\n                    // Second and later copies cannot link to the blob file\n                    // in incoming directory because it was renamed out.\n                    // Instead they have to link to the MailboxBlob file of\n                    // the previous delivery.  (Bug 2283)\n                    srcPath = srcMboxBlob.getPath();\n                    srcBlob = srcMboxBlob.getBlob();\n                } else {\n                    // Second or later recipient in multi-recipient message.\n                    // Link to blob in incoming directory.\n                    srcPath = blob.getPath();\n                    srcBlob = blob;\n                }\n                redoRecorder.setMessageLinkInfo(srcPath, srcBlob.getVolumeId(), msg.getVolumeId());\n                mboxBlob = sm.link(srcBlob, this, messageId, msg.getSavedSequence(), msg.getVolumeId());\n            }\n            markOtherItemDirty(mboxBlob);\n\n            // don't call pm.generateLuceneDocuments() if we're deferring indexing -- don't\n            // want to force message analysis!\n            queueForIndexing(msg, false, deferIndexing ? null : pm.getLuceneDocuments());\n            assert(!deferIndexing || msg.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED));\n            success = true;\n        } finally {\n            if (storeRedoRecorder != null) {\n                if (success)  storeRedoRecorder.commit();\n                else          storeRedoRecorder.abort();\n            }\n\n            endTransaction(success);\n\n            if (success) {\n                // Everything worked.  Update the blob field in ParsedMessage\n                // so the next recipient in the multi-recipient case will link\n                // to this blob as opposed to saving its own copy.\n                sharedDeliveryCtxt.setBlob(blob);\n                sharedDeliveryCtxt.setMailboxBlob(mboxBlob);\n                sharedDeliveryCtxt.setFirst(false);\n            }\n        }\n        \n        // step 6: remember the Message-ID header so that we can avoid receiving duplicates\n        if (isSent && checkDuplicates)\n            mSentMessageIDs.put(msgidHeader, new Integer(msg.getId()));\n\n        // step 7: send lawful intercept message\n        try {\n            Notification.getInstance().interceptIfNecessary(this, pm.getMimeMessage(), \"add message\", folder);\n        } catch (ServiceException e) {\n            ZimbraLog.mailbox.error(\"Unable to send lawful intercept message.\", e);\n        }\n        \n        return msg;\n    }\n    \n    private byte[] getData(ParsedMessage pm) throws ServiceException {\n        try {\n            return pm.getRawData();\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"unable to get MIME data\", e);\n        } catch (MessagingException e) {\n            throw ServiceException.FAILURE(\"unable to get MIME data\", e);\n        }\n    }\n    \n    public static String getHash(String subject) {\n        return ByteUtil.getSHA1Digest(subject.getBytes(), true);\n    }\n\n    // please keep this package-visible but not public\n    void openConversation(Conversation conv, String hash) throws ServiceException {\n        if (hash == null)\n            hash = getHash(conv.getNormalizedSubject());\n        conv.open(hash);\n        markOtherItemDirty(hash);\n        mConvHashes.put(hash, new Integer(conv.getId()));\n    }\n\n    // please keep this package-visible but not public\n    void closeConversation(Conversation conv, String hash) throws ServiceException {\n        if (hash == null)\n            hash = getHash(conv.getSubject());\n        conv.close(hash);\n        mConvHashes.remove(hash);\n    }\n\n    // please keep this package-visible but not public\n    Conversation createConversation(Message[] contents, int id) throws ServiceException {\n        id = Math.max(id, ID_AUTO_INCREMENT);\n        Conversation conv = Conversation.create(this, getNextItemId(id), contents);\n        if (ZimbraLog.mailbox.isDebugEnabled()) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < contents.length; i++)\n                sb.append(i == 0 ? \"\" : \",\").append(contents[i].getId());\n            ZimbraLog.mailbox.debug(\"  created conv \" + conv.getId() + \" holding msg(s): \" + sb);\n        }\n        return conv;\n    }\n    \n    public Message saveDraft(OperationContext octxt, ParsedMessage pm, int id) throws IOException, ServiceException {\n        return saveDraft(octxt, pm, id, null, null, null);\n    }\n\n    public Message saveDraft(OperationContext octxt, ParsedMessage pm, int id, String origId, String replyType, String identityId)\n    throws IOException, ServiceException {\n        maybeIndexDeferredItems();\n        \n        // make sure the message has been analyzed before taking the Mailbox lock\n        if (getBatchedIndexingCount() == 0)\n            pm.analyzeFully();\n\n        // special-case saving a new draft\n        if (id == ID_AUTO_INCREMENT) {\n            Message.DraftInfo dinfo = null;\n            if ((replyType != null && origId != null) || (identityId != null && !identityId.equals(\"\")))\n                dinfo = new Message.DraftInfo(replyType, origId, identityId);\n            return addMessageInternal(octxt, pm, ID_FOLDER_DRAFTS, true, Flag.BITMASK_DRAFT | Flag.BITMASK_FROM_ME, null,\n                                      ID_AUTO_INCREMENT, \":API:\", dinfo, new SharedDeliveryContext());\n        } else {\n            return saveDraftInternal(octxt, pm, id);\n        }\n    }\n\n    private synchronized Message saveDraftInternal(OperationContext octxt, ParsedMessage pm, int id) throws IOException, ServiceException {\n        String digest = pm.getRawDigest();\n        int size = pm.getRawSize();\n        \n        SaveDraft redoRecorder = new SaveDraft(mId, id, digest, size);\n        boolean success = false;\n        \n        boolean deferIndexing = this.getBatchedIndexingCount() > 0 || pm.hasTemporaryAnalysisFailure();\n        InputStream in = null;\n            \n        try {\n            beginTransaction(\"saveDraft\", octxt, redoRecorder);\n            SaveDraft redoPlayer = (SaveDraft) mCurrentChange.getRedoPlayer();\n\n            Message msg = getMessageById(id);\n            if (!msg.isTagged(mDraftFlag))\n                throw MailServiceException.IMMUTABLE_OBJECT(id);\n            if (!checkItemChangeID(msg))\n                throw MailServiceException.MODIFY_CONFLICT();\n\n            // content changed, so we're obliged to change the IMAP uid\n            int imapID = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getImapId());\n            redoRecorder.setImapId(imapID);\n\n            short volumeId = redoPlayer == null ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n\n            // update the content and increment the revision number\n            in = pm.getRawInputStream();\n            Blob blob = msg.setContent(in, size, digest, volumeId, pm);\n            redoRecorder.setMessageBodyInfo(blob.getFile(), blob.getVolumeId());\n\n            queueForIndexing(msg, true, deferIndexing ? null : pm.getLuceneDocuments());\n                \n            success = true;\n            \n            try {\n                Notification.getInstance().interceptIfNecessary(this, pm.getMimeMessage(), \"save draft\", msg.getFolder());\n            } catch (ServiceException e) {\n                ZimbraLog.mailbox.error(\"Unable to send lawful intercept message.\", e);\n            }\n            \n            return msg;\n        } finally {\n            ByteUtil.closeStream(in);\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * Modify the Participant-Status of your LOCAL data part of an calendar item -- this is used when you Reply to\n     * an Invite so that you can track the fact that you've replied to it.\n     * \n     * @param octxt\n     * @param calItemId\n     * @param recurId\n     * @param cnStr\n     * @param addressStr\n     * @param cutypeStr\n     * @param roleStr\n     * @param partStatStr\n     * @param rsvp\n     * @param seqNo\n     * @param dtStamp\n     * @throws ServiceException\n     */\n    public synchronized void modifyPartStat(OperationContext octxt, int calItemId, RecurId recurId,\n                String cnStr, String addressStr, String cutypeStr, String roleStr, String partStatStr, Boolean rsvp, int seqNo, long dtStamp) \n    throws ServiceException {\n\n        ModifyInvitePartStat redoRecorder = new ModifyInvitePartStat(mId, calItemId, recurId, cnStr, addressStr, cutypeStr, roleStr, partStatStr, rsvp, seqNo, dtStamp);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"updateInvitePartStat\", octxt, redoRecorder);\n\n            CalendarItem calItem = getCalendarItemById(calItemId);\n\n            Account acct = getAccount();\n\n            calItem.modifyPartStat(acct, recurId, cnStr, addressStr, cutypeStr, roleStr, partStatStr, rsvp, seqNo, dtStamp);\n            markItemModified(calItem, Change.MODIFIED_INVITE);\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<Integer> resetImapUid(OperationContext octxt, List<Integer> itemIds) throws ServiceException {\n        SetImapUid redoRecorder = new SetImapUid(mId, itemIds);\n\n        List<Integer> newIds = new ArrayList<Integer>();\n        boolean success = false;\n        try {\n            beginTransaction(\"resetImapUid\", octxt, redoRecorder);\n            SetImapUid redoPlayer = (SetImapUid) mCurrentChange.getRedoPlayer();\n\n            for (int id : itemIds) {\n                MailItem item = getItemById(id, MailItem.TYPE_UNKNOWN);\n                int imapId = redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getImapUid(id);\n                item.setImapUid(getNextItemId(imapId));\n                redoRecorder.setImapUid(item.getId(), item.getImapUid());\n                newIds.add(item.getImapUid());\n            }\n            success = true;\n            return newIds;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void setColor(OperationContext octxt, int itemId, byte type, byte color) throws ServiceException {\n        setColor(octxt, new int[] { itemId }, type, color);\n    }\n    public synchronized void setColor(OperationContext octxt, int[] itemIds, byte type, byte color) throws ServiceException {\n        ColorItem redoRecorder = new ColorItem(mId, itemIds, type, color);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"setColor\", octxt, redoRecorder);\n\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items)\n                if (!checkItemChangeID(item))\n                    throw MailServiceException.MODIFY_CONFLICT();\n\n            for (MailItem item : items)\n                item.setColor(color);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void alterTag(OperationContext octxt, int itemId, byte type, int tagId, boolean addTag) throws ServiceException {\n        alterTag(octxt, new int[] { itemId }, type, tagId, addTag, null);\n    }\n    public synchronized void alterTag(OperationContext octxt, int itemId, byte type, int tagId, boolean addTag, TargetConstraint tcon)\n    throws ServiceException {\n        alterTag(octxt, new int[] { itemId }, type, tagId, addTag, tcon);\n    }\n    public synchronized void alterTag(OperationContext octxt, int[] itemIds, byte type, int tagId, boolean addTag, TargetConstraint tcon)\n    throws ServiceException {\n        AlterItemTag redoRecorder = new AlterItemTag(mId, itemIds, type, tagId, addTag, tcon);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"alterTag\", octxt, redoRecorder);\n            setOperationTargetConstraint(tcon);\n\n            Tag tag = (tagId < 0 ? getFlagById(tagId) : getTagById(tagId));\n\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items) {\n                if (!(item instanceof Conversation))\n                    if (!checkItemChangeID(item) && item instanceof Tag)\n                        throw MailServiceException.MODIFY_CONFLICT();\n            }\n\n            for (MailItem item : items) {\n                if (item == null)\n                    continue;\n                if (tagId == Flag.ID_FLAG_UNREAD) {\n                    item.alterUnread(addTag);\n                } else {\n                    item.alterTag(tag, addTag);\n                }\n            }\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void setTags(OperationContext octxt, int itemId, byte type, int flags, long tags) throws ServiceException {\n        setTags(octxt, itemId, type, flags, tags, null);\n    }\n    public synchronized void setTags(OperationContext octxt, int itemId, byte type, String flagStr, String tagIDs, TargetConstraint tcon)\n    throws ServiceException {\n        int flags = (flagStr == null ? MailItem.FLAG_UNCHANGED : Flag.flagsToBitmask(flagStr));\n        long tags = (tagIDs == null ? MailItem.TAG_UNCHANGED : Tag.tagsToBitmask(tagIDs));\n        setTags(octxt, itemId, type, flags, tags, tcon);\n    }\n    public synchronized void setTags(OperationContext octxt, int[] itemIds, byte type, String flagStr, String tagIDs, TargetConstraint tcon)\n    throws ServiceException {\n        int flags = (flagStr == null ? MailItem.FLAG_UNCHANGED : Flag.flagsToBitmask(flagStr));\n        long tags = (tagIDs == null ? MailItem.TAG_UNCHANGED : Tag.tagsToBitmask(tagIDs));\n        setTags(octxt, itemIds, type, flags, tags, tcon);\n    }\n    public synchronized void setTags(OperationContext octxt, int itemId, byte type, int flags, long tags, TargetConstraint tcon)\n    throws ServiceException {\n        setTags(octxt, new int[] { itemId }, type, flags, tags, tcon);\n    }\n    public synchronized void setTags(OperationContext octxt, int[] itemIds, byte type, int flags, long tags, TargetConstraint tcon)\n    throws ServiceException {\n        if (flags == MailItem.FLAG_UNCHANGED && tags == MailItem.TAG_UNCHANGED)\n            return;\n\n        SetItemTags redoRecorder = new SetItemTags(mId, itemIds, type, flags, tags, tcon);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"setTags\", octxt, redoRecorder);\n            setOperationTargetConstraint(tcon);\n\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items)\n                checkItemChangeID(item);\n\n            for (MailItem item : items) {\n                if (item == null)\n                    continue;\n\n                int iflags = flags;  long itags = tags;\n                if ((iflags & MailItem.FLAG_UNCHANGED) != 0)\n                    iflags = item.getFlagBitmask();\n                if ((itags & MailItem.TAG_UNCHANGED) != 0)\n                    itags = item.getTagBitmask();\n    \n                // Special-case the unread flag.  It's passed in as a flag from the outside,\n                // but treated as a separate argument inside the mailbox.\n                boolean iunread = (iflags & Flag.BITMASK_UNREAD) > 0;\n                iflags &= ~Flag.BITMASK_UNREAD;\n                item.setTags(iflags, itags);\n                if (mUnreadFlag.canTag(item))\n                    item.alterUnread(iunread);\n            }\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized MailItem copy(OperationContext octxt, int itemId, byte type, int folderId) throws ServiceException {\n        return copy(octxt, new int[] { itemId }, type, folderId).get(0);\n    }\n    public synchronized List<MailItem> copy(OperationContext octxt, int[] itemIds, byte type, int folderId) throws ServiceException {\n        short volumeId = Volume.getCurrentMessageVolume().getId();\n        CopyItem redoRecorder = new CopyItem(mId, type, folderId, volumeId);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"copy\", octxt, redoRecorder);\n            CopyItem redoPlayer = (CopyItem) mCurrentChange.getRedoPlayer();\n\n            List<MailItem> result = new ArrayList<MailItem>();\n\n            Folder folder = getFolderById(folderId);\n\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items)\n                checkItemChangeID(item);\n\n            for (MailItem item : items) {\n                MailItem copy;\n\n                if (item instanceof Conversation) {\n                    // this should be done in Conversation.copy(), but redolog issues make that impossible\n                    Conversation conv = (Conversation) item;\n                    List<Message> msgs = new ArrayList<Message>((int) conv.getSize());\n                    for (Message original : conv.getMessages(DbSearch.SORT_NONE)) {\n                        if (!original.canAccess(ACL.RIGHT_READ))\n                            continue;\n                        int newId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getDestId(original.getId()));\n                        Message msg = (Message) original.copy(folder, newId, ID_AUTO_INCREMENT, volumeId);\n                        msgs.add(msg);\n                        redoRecorder.setDestId(original.getId(), newId);\n                    }\n                    if (msgs.isEmpty()) {\n                        throw ServiceException.PERM_DENIED(\"you do not have sufficient permissions\");\n                    } else if (msgs.size() == 1) {\n                        copy = msgs.get(0).getParent();\n                    } else {\n                        int newId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getDestId(conv.getId()));\n                        copy = Conversation.create(this, newId, msgs.toArray(new Message[msgs.size()]));\n                        redoRecorder.setDestId(conv.getId(), newId);\n                    }\n                } else {\n                    int newId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getDestId(item.getId()));\n                    copy = item.copy(folder, newId, item.getParentId(), item.getVolumeId() == -1 ? -1 : volumeId);\n                    redoRecorder.setDestId(item.getId(), newId);\n                }\n\n                result.add(copy);\n            }\n\n            success = true;\n            return result;\n        } catch (IOException e) {\n            throw ServiceException.FAILURE(\"IOException while copying items\", e);\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized List<MailItem> imapCopy(OperationContext octxt, int[] itemIds, byte type, int folderId) throws IOException, ServiceException {\n        // this is an IMAP command, so we'd better be tracking IMAP changes by now...\n        beginTrackingImap();\n\n        for (int id : itemIds)\n            if (id <= 0)\n                throw MailItem.noSuchItem(id, type);\n\n        short volumeId = Volume.getCurrentMessageVolume().getId();\n        ImapCopyItem redoRecorder = new ImapCopyItem(mId, type, folderId, volumeId);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"icopy\", octxt, redoRecorder);\n            ImapCopyItem redoPlayer = (ImapCopyItem) mCurrentChange.getRedoPlayer();\n\n            Folder target = getFolderById(folderId);\n\n            // fetch the items to copy and make sure the caller is up-to-date on change IDs\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items)\n                checkItemChangeID(item);\n\n            List<MailItem> result = new ArrayList<MailItem>();\n\n            for (MailItem item : items) {\n                int srcId = item.getId();\n                int newId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getDestId(srcId));\n\n                MailItem copy = item.icopy(target, newId, item.getVolumeId() == -1 ? -1 : volumeId);\n                redoRecorder.setDestId(srcId, newId);\n    \n                result.add(copy);\n            }\n\n            success = true;\n            return result;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Moves an item from one folder into another in the same Mailbox.  The\n     *  target folder may not be a {@link Mountpoint} or {@link SearchFolder}.\n     *  To move an item between Mailboxes, you must do the copy by hand, then\n     *  remove the original.\n     *  \n     * @perms {@link ACL#RIGHT_INSERT} on the target folder,\n     *        {@link ACL#RIGHT_DELETE} on the source folder\n     * @param octxt     The context for this request (e.g. auth user id).\n     * @param itemId    The ID of the item to move.\n     * @param type      The type of the item or {@link MailItem#TYPE_UNKNOWN}.\n     * @param targetId  The ID of the target folder for the move. */\n    public synchronized void move(OperationContext octxt, int itemId, byte type, int targetId) throws ServiceException {\n        move(octxt, new int[] { itemId }, type, targetId, null);\n    }\n\n    /** Moves an item from one folder into another in the same Mailbox.  The\n     *  target folder may not be a {@link Mountpoint} or {@link SearchFolder}.\n     *  To move an item between Mailboxes, you must do the copy by hand, then\n     *  remove the original.\n     *  \n     * @perms {@link ACL#RIGHT_INSERT} on the target folder,\n     *        {@link ACL#RIGHT_DELETE} on the source folder\n     * @param octxt     The context for this request (e.g. auth user id).\n     * @param itemId    The ID of the item to move.\n     * @param type      The type of the item or {@link MailItem#TYPE_UNKNOWN}.\n     * @param targetId  The ID of the target folder for the move.\n     * @param tcon      An optional constraint on the item being moved. */\n    public synchronized void move(OperationContext octxt, int itemId, byte type, int targetId, TargetConstraint tcon) throws ServiceException {\n        move(octxt, new int[] { itemId }, type, targetId, tcon);\n    }\n\n    /** Moves a set of items into a given folder in the same Mailbox.  The\n     *  target folder may not be a {@link Mountpoint} or {@link SearchFolder}.\n     *  To move items between Mailboxes, you must do the copy by hand, then\n     *  remove the originals.\n     *  \n     * @perms {@link ACL#RIGHT_INSERT} on the target folder,\n     *        {@link ACL#RIGHT_DELETE} on all the the source folders\n     * @param octxt     The context for this request (e.g. auth user id).\n     * @param itemId    A list of the IDs of the items to move.\n     * @param type      The type of the items or {@link MailItem#TYPE_UNKNOWN}.\n     * @param targetId  The ID of the target folder for the move.\n     * @param tcon      An optional constraint on the items being moved. */\n    public synchronized void move(OperationContext octxt, int[] itemIds, byte type, int targetId, TargetConstraint tcon) throws ServiceException {\n        MoveItem redoRecorder = new MoveItem(mId, itemIds, type, targetId, tcon);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"move\", octxt, redoRecorder);\n            setOperationTargetConstraint(tcon);\n\n            Folder target = getFolderById(targetId);\n\n            MailItem[] items = getItemById(itemIds, type);\n            for (MailItem item : items)\n                checkItemChangeID(item);\n\n            int oldUIDNEXT = target.getImapUIDNEXT();\n            boolean resetUIDNEXT = false;\n\n            for (MailItem item : items) {\n                // do the move...\n                boolean moved = item.move(target);\n                \n                // ...and determine whether the move needs to cause an UIDNEXT change\n                if (moved && !resetUIDNEXT && isTrackingImap() && (item instanceof Conversation || item instanceof Message || item instanceof Contact))\n                    resetUIDNEXT = true;\n            }\n\n            // if this operation should cause the target folder's UIDNEXT value to change but it hasn't yet, do it here\n            if (resetUIDNEXT && oldUIDNEXT == target.getImapUIDNEXT()) {\n                MoveItem redoPlayer = (MoveItem) mCurrentChange.getRedoPlayer();\n                redoRecorder.setUIDNEXT(getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getUIDNEXT()));\n                target.updateUIDNEXT();\n            }\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void rename(OperationContext octxt, int id, byte type, String name, int folderId) throws ServiceException {\n        if (name != null && name.startsWith(\"/\")) {\n            rename(octxt, id, type, name);\n            return;\n        }\n\n        name = StringUtil.stripControlCharacters(name);\n        if (name == null || name.equals(\"\"))\n            throw ServiceException.INVALID_REQUEST(\"cannot set name to empty string\", null);\n\n        RenameItem redoRecorder = new RenameItem(mId, id, type, name, folderId);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"rename\", octxt, redoRecorder);\n\n            MailItem item = getItemById(id, type);\n            checkItemChangeID(item);\n            if (folderId <= 0)\n                folderId = item.getFolderId();\n\n            String oldName = item.getName();\n            \n            item.rename(name, getFolderById(folderId));\n\n            if (item instanceof Tag) {\n                mTagCache.remove(oldName.toLowerCase());\n                mTagCache.put(name.toLowerCase(), (Tag) item);\n            }\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void rename(OperationContext octxt, int id, byte type, String path) throws ServiceException {\n        if (path == null || !path.startsWith(\"/\")) {\n            rename(octxt, id, type, path, ID_AUTO_INCREMENT);\n            return;\n        }\n\n        RenameItemPath redoRecorder = new RenameItemPath(mId, id, type, path);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"renameFolderPath\", octxt, redoRecorder);\n            RenameItemPath redoPlayer = (RenameItemPath) mCurrentChange.getRedoPlayer();\n\n            MailItem item = getItemById(id, type);\n            Folder parent;\n            checkItemChangeID(item);\n\n            String[] parts = path.substring(1).split(\"/\");\n            if (parts.length == 0)\n                throw MailServiceException.ALREADY_EXISTS(path);\n            int[] recorderParentIds = new int[parts.length - 1];\n            int[] playerParentIds = redoPlayer == null ? null : redoPlayer.getParentIds();\n            if (playerParentIds != null && playerParentIds.length != recorderParentIds.length)\n                throw ServiceException.FAILURE(\"incorrect number of path segments in redo player\", null);\n\n            parent = getFolderById(ID_FOLDER_USER_ROOT);\n            for (int i = 0; i < parts.length - 1; i++) {\n                String name = MailItem.validateItemName(parts[i]);\n                int subfolderId = playerParentIds == null ? ID_AUTO_INCREMENT : playerParentIds[i];\n                Folder subfolder = parent.findSubfolder(name);\n                if (subfolder == null)\n                    subfolder = Folder.create(getNextItemId(subfolderId), this, parent, name);\n                else if (subfolderId != ID_AUTO_INCREMENT && subfolderId != subfolder.getId())\n                    throw ServiceException.FAILURE(\"parent folder id changed since operation was recorded\", null);\n                else if (!subfolder.getName().equals(name) && subfolder.isMutable())\n                    subfolder.rename(name, parent);\n                recorderParentIds[i] = subfolder.getId();\n                parent = subfolder;\n            }\n            redoRecorder.setParentIds(recorderParentIds);\n\n            String name = parts[parts.length - 1];\n\n            item.rename(name, parent);\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * Deletes the <tt>MailItem</tt> with the given id.  Does nothing\n     * if the <tt>MailItem</tt> doesn't exist.\n     */\n    public synchronized void delete(OperationContext octxt, int itemId, byte type) throws ServiceException {\n        delete(octxt, new int[] { itemId }, type, null);\n    }\n\n    public synchronized void delete(OperationContext octxt, MailItem item, TargetConstraint tcon) throws ServiceException {\n        delete(octxt, new int[] { item.getId() }, item.getType(), tcon);\n    }\n\n    /** Deletes the <tt>MailItem</tt> with the given id.  If there is no such\n     *  <tt>MailItem</tt>, nothing happens and no error is generated.  If the\n     *  id maps to an existing <tt>MailItem</tt> of an incompatible type,\n     *  however, an error is thrown. */\n    public synchronized void delete(OperationContext octxt, int itemId, byte type, TargetConstraint tcon) throws ServiceException {\n        delete(octxt, new int[] { itemId }, type, tcon);\n    }\n\n    /** Deletes the <tt>MailItem</tt>s with the given id.  If there is no\n     *  <tt>MailItem</tt> for a given id, that id is ignored.  If the id maps\n     *  to an existing <tt>MailItem</tt> of an incompatible type, however,\n     *  an error is thrown. */\n    public synchronized void delete(OperationContext octxt, int[] itemIds, byte type, TargetConstraint tcon) throws ServiceException {\n        DeleteItem redoRecorder = new DeleteItem(mId, itemIds, type, tcon);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"delete\", octxt, redoRecorder);\n            setOperationTargetConstraint(tcon);\n\n            for (int id : itemIds) {\n                if (id == ID_AUTO_INCREMENT)\n                    continue;\n\n                MailItem item;\n                try {\n                    item = getItemById(id, MailItem.TYPE_UNKNOWN);\n                } catch (NoSuchItemException nsie) {\n                    // trying to delete nonexistent things is A-OK!\n                    continue;\n                }\n\n                // however, trying to delete messages and passing in a folder ID is not OK\n                if (!MailItem.isAcceptableType(type, item.getType()))\n                    throw MailItem.noSuchItem(id, type);\n                if (!checkItemChangeID(item) && item instanceof Tag)\n                    throw MailServiceException.MODIFY_CONFLICT();\n\n                // delete the item, but don't write the tombstone until we're finished...\n                item.delete(MailItem.DeleteScope.ENTIRE_ITEM, false);\n            }\n\n            // deletes have already been collected, so fetch the tombstones and write once\n            TypedIdList tombstones = collectPendingTombstones();\n            if (tombstones != null && !tombstones.isEmpty())\n                DbMailItem.writeTombstones(this, tombstones);\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    TypedIdList collectPendingTombstones() {\n        if (!isTrackingSync() || mCurrentChange.deletes == null)\n            return null;\n        return new TypedIdList(mCurrentChange.deletes.itemIds);\n    }\n\n    public synchronized Tag createTag(OperationContext octxt, String name, byte color) throws ServiceException {\n        name = StringUtil.stripControlCharacters(name);\n        if (name == null || name.equals(\"\"))\n            throw ServiceException.INVALID_REQUEST(\"tag must have a name\", null);\n\n        CreateTag redoRecorder = new CreateTag(mId, name, color);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"createTag\", octxt, redoRecorder);\n            CreateTag redoPlayer = (CreateTag) mCurrentChange.getRedoPlayer();\n\n            int tagId = (redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getTagId());\n            if (tagId != ID_AUTO_INCREMENT)\n                if (!Tag.validateId(tagId))\n                    throw ServiceException.INVALID_REQUEST(\"invalid tag id \" + tagId, null);\n\n            if (tagId == ID_AUTO_INCREMENT) {\n                for (tagId = MailItem.TAG_ID_OFFSET; tagId < MailItem.TAG_ID_OFFSET + MailItem.MAX_TAG_COUNT; tagId++)\n                    if (mTagCache.get(new Integer(tagId)) == null)\n                        break;\n                if (tagId >= MailItem.TAG_ID_OFFSET + MailItem.MAX_TAG_COUNT)\n                    throw MailServiceException.TOO_MANY_TAGS();\n            }\n\n            Tag tag = Tag.create(this, tagId, name, color);\n            redoRecorder.setTagId(tagId);\n            success = true;\n            return tag;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized Note createNote(OperationContext octxt, String content, Rectangle location, byte color, int folderId)\n    throws ServiceException {\n        content = StringUtil.stripControlCharacters(content);\n        if (content == null || content.equals(\"\"))\n            throw ServiceException.INVALID_REQUEST(\"note content may not be empty\", null);\n\n        CreateNote redoRecorder = new CreateNote(mId, folderId, content, color, location);\n        \n        boolean success = false;\n        try {\n            beginTransaction(\"createNote\", octxt, redoRecorder);\n            CreateNote redoPlayer = (CreateNote) mCurrentChange.getRedoPlayer();\n\n            int noteId;\n            short volumeId;\n            if (redoPlayer == null) {\n                noteId = getNextItemId(ID_AUTO_INCREMENT);\n                volumeId = Volume.getCurrentMessageVolume().getId();\n            } else {\n                noteId = getNextItemId(redoPlayer.getNoteId());\n                volumeId = redoPlayer.getVolumeId();\n            }\n            Note note = Note.create(noteId, getFolderById(folderId), volumeId, content, location, color);\n\n            redoRecorder.setNoteId(note.getId());\n            redoRecorder.setVolumeId(note.getVolumeId());\n            queueForIndexing(note, false, null);\n            success = true;\n            return note;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void editNote(OperationContext octxt, int noteId, String content) throws ServiceException {\n        content = StringUtil.stripControlCharacters(content);\n        if (content == null || content.equals(\"\"))\n            throw ServiceException.INVALID_REQUEST(\"note content may not be empty\", null);\n\n        EditNote redoRecorder = new EditNote(mId, noteId, content);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"editNote\", octxt, redoRecorder);\n\n            Note note = getNoteById(noteId);\n            checkItemChangeID(note);\n\n            note.setContent(content);\n            queueForIndexing(note, true, null);\n            \n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void repositionNote(OperationContext octxt, int noteId, Rectangle location)\n    throws ServiceException {\n        if (location == null)\n            throw new IllegalArgumentException(\"must specify note bounds\");\n\n        RepositionNote redoRecorder = new RepositionNote(mId, noteId, location);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"repositionNote\", octxt, redoRecorder);\n\n            Note note = getNoteById(noteId);\n            checkItemChangeID(note);\n\n            note.reposition(location);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    CalendarItem createCalendarItem(int folderId, short volumeId, int flags, long tags, String uid,\n                                    ParsedMessage pm, Invite invite, long nextAlarm)\n    throws ServiceException {\n        OperationContext octxt = getOperationContext();\n        Account authAccount = octxt != null ? octxt.getAuthenticatedUser() : null;\n        boolean asAdmin = octxt != null ? octxt.isUsingAdminPrivileges() : false;\n        boolean denyPrivateAccess = authAccount != null && !Account.allowPrivateAccess(authAccount, getAccount(), asAdmin);\n        boolean isCalendarResource = getAccount() instanceof CalendarResource;\n        // Don't allow creating a private appointment on behalf of another user,\n        // unless that other user is a calendar resource.\n        if (denyPrivateAccess && !invite.isPublic() && !isCalendarResource)\n            throw ServiceException.PERM_DENIED(\"private appointment/task cannot be created on behalf of another user\");\n\n        // FIXME: assuming that we're in the middle of a AddInvite op\n        CreateCalendarItemPlayer redoPlayer = (CreateCalendarItemPlayer) mCurrentChange.getRedoPlayer();\n        CreateCalendarItemRecorder redoRecorder = (CreateCalendarItemRecorder) mCurrentChange.getRedoRecorder();\n\n        int newCalItemId = redoPlayer == null ? Mailbox.ID_AUTO_INCREMENT : redoPlayer.getCalendarItemId();\n        int createId = getNextItemId(newCalItemId);\n\n        CalendarItem calItem = CalendarItem.create(createId, getFolderById(folderId), volumeId, flags, tags,\n                                                   uid, pm, invite, nextAlarm);\n\n        if (redoRecorder != null)\n            redoRecorder.setCalendarItemAttrs(calItem.getId(), calItem.getFolderId(), calItem.getVolumeId());\n        return calItem;\n    }\n\n    public Contact createContact(OperationContext octxt, ParsedContact pc, int folderId, String tags) throws ServiceException {\n        return createContactInternal(octxt, pc.analyze(this), folderId, tags);\n    }\n\n    private synchronized Contact createContactInternal(OperationContext octxt, ParsedContact pc, int folderId, String tags)\n    throws ServiceException {\n        CreateContact redoRecorder = new CreateContact(mId, folderId, pc, tags);\n\n        boolean deferIndexing = getBatchedIndexingCount() > 0 || pc.hasTemporaryAnalysisFailure();\n        List<org.apache.lucene.document.Document> indexData = null;\n        if (!deferIndexing) {\n            try {\n                indexData = pc.getLuceneDocuments(this);\n            } catch (ServiceException e) {\n                ZimbraLog.index.info(\"Caught exception analyzing new contact in folder \"+folderId+\".  Contact will not be indexed.\", e);\n                indexData = Collections.emptyList();\n            }\n        }\n        \n        boolean success = false;\n        try {\n            beginTransaction(\"createContact\", octxt, redoRecorder);\n            CreateContact redoPlayer = (CreateContact) mCurrentChange.getRedoPlayer();\n            boolean isRedo = redoPlayer != null;\n\n            int contactId = getNextItemId(isRedo ? redoPlayer.getContactId() : ID_AUTO_INCREMENT);\n            short volumeId = -1;\n            if (pc.hasAttachment()) {\n                if (isRedo)\n                    volumeId = redoPlayer.getVolumeId();\n                if (volumeId == -1)\n                    volumeId = Volume.getCurrentMessageVolume().getId();\n            }\n            \n            int flags = 0;\n            if (deferIndexing) {\n                flags |= Flag.BITMASK_INDEXING_DEFERRED;\n                incrementIndexDeferredCount(1);\n            }\n\n            Contact con = Contact.create(contactId, getFolderById(folderId), volumeId, pc, flags, tags);\n\n            if (pc.hasAttachment()) {\n                try {\n                    StoreManager sm = StoreManager.getInstance();\n                    Blob blob = sm.storeIncoming(pc.getBlob(), pc.getDigest(), null, volumeId);\n                    MailboxBlob mblob = sm.renameTo(blob, this, contactId, getOperationChangeID(), volumeId);\n\n                    markOtherItemDirty(mblob);\n                } catch (IOException ioe) {\n                    throw ServiceException.FAILURE(\"could not save contact blob\", ioe);\n                }\n            }\n\n            redoRecorder.setContactId(con.getId());\n            redoRecorder.setVolumeId(volumeId);\n            \n            queueForIndexing(con, false, deferIndexing ? null : indexData);\n\n            success = true;\n            return con;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public void modifyContact(OperationContext octxt, int contactId, ParsedContact pc) throws ServiceException {\n        modifyContactInternal(octxt, contactId, pc.analyze(this));\n    }\n\n    public void modifyContactInternal(OperationContext octxt, int contactId, ParsedContact pc) throws ServiceException {\n        ModifyContact redoRecorder = new ModifyContact(mId, contactId, pc);\n        pc.analyze(this);\n        \n        List<org.apache.lucene.document.Document> indexData = null;\n        boolean deferIndexing = this.getBatchedIndexingCount() > 0 || pc.hasTemporaryAnalysisFailure();\n        if (!deferIndexing) {\n            try {\n                indexData = pc.getLuceneDocuments(this);\n            } catch (Exception e) {\n                ZimbraLog.index.info(\"Caught exception analyzing contact \"+contactId+\".  Contact will not be indexed.\", e);\n                indexData = new ArrayList<org.apache.lucene.document.Document>();\n            }\n        }\n        \n        synchronized (this) {\n            boolean success = false;\n            try {\n                beginTransaction(\"modifyContact\", octxt, redoRecorder);\n                ModifyContact redoPlayer = (ModifyContact) mCurrentChange.getRedoPlayer();\n                \n                Contact con = getContactById(contactId);\n                if (!checkItemChangeID(con))\n                    throw MailServiceException.MODIFY_CONFLICT();\n                \n                short volumeId = -1;\n                if (pc.hasAttachment()) {\n                    if (redoPlayer != null)\n                        volumeId = redoPlayer.getVolumeId();\n                    if (volumeId == -1)\n                        volumeId = Volume.getCurrentMessageVolume().getId();\n                }\n                \n                try {\n                    if (pc.getBlob() == null && con.getDigest() == null)\n                        con.setFields(pc);\n                    else\n                        con.setContent(pc.getBlob(), pc.getDigest(), volumeId, pc);\n                } catch (IOException ioe) {\n                    throw ServiceException.FAILURE(\"could not save contact blob\", ioe);\n                }\n                \n                redoRecorder.setVolumeId(volumeId);\n                queueForIndexing(con, true, indexData);\n                    \n                success = true;\n            } finally {\n                endTransaction(success);\n            }\n        }\n    }\n\n    /**\n     * @see #createFolder(OperationContext, String, int, byte, byteint, byte, String)\n     */\n    public synchronized Folder createFolder(OperationContext octxt, String name, int parentId, byte defaultView, int flags, byte color, String url)\n    throws ServiceException {\n\t\treturn createFolder(octxt, name, parentId, (byte)0, defaultView, flags, color, url);\n\t}\n\n    public synchronized Folder createFolder(OperationContext octxt, String name, int parentId, byte attrs, byte defaultView, int flags, byte color, String url)\n    throws ServiceException {\n        CreateFolder redoRecorder = new CreateFolder(mId, name, parentId, attrs, defaultView, flags, color, url);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"createFolder\", octxt, redoRecorder);\n            CreateFolder redoPlayer = (CreateFolder) mCurrentChange.getRedoPlayer();\n\n            int folderId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getFolderId());\n            Folder folder = Folder.create(folderId, this, getFolderById(parentId), name, attrs, defaultView, flags, color, url);\n            redoRecorder.setFolderId(folder.getId());\n            success = true;\n            return folder;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * @see #createFolder(OperationContext, String, int, byte, int, byte, String)\n     */\n    public synchronized Folder createFolder(OperationContext octxt, String path, byte attrs, byte defaultView) throws ServiceException {\n        return createFolder(octxt, path, attrs, defaultView, 0, MailItem.DEFAULT_COLOR, null);\n    }\n\n    /**\n     * Creates a folder.  Implicitly creates any parent folders in <tt>path</tt> if necessary.\n     * \n     * @param octxt the operation context\n     * @param path the slash-separated folder path\n     * @param attrs the folder attributes, or <tt>0</tt> for the default attributes\n     * @param defaultView the folder view, or <tt>0</tt> for the default view\n     * @param flags the folder flags, or <tt>0</tt> for no flags\n     * @param color the folder color, or {@link MailItem#DEFAULT_COLOR}\n     * @param url the folder URL, or <tt>null</tt>\n     * @return the new folder\n     * @see Folder#getAttributes()\n     * @see Folder#getDefaultView()\n     * @see MailItem#getColor()\n     * \n     * @throws ServiceException if the folder creation fails\n     */\n    public synchronized Folder createFolder(OperationContext octxt, String path, byte attrs, byte defaultView, int flags, byte color, String url)\n    throws ServiceException {\n        if (path == null)\n            throw ServiceException.FAILURE(\"null path passed to Mailbox.createFolderPath\", null);\n        if (!path.startsWith(\"/\"))\n            path = '/' + path;\n        if (path.endsWith(\"/\") && path.length() > 1)\n            path = path.substring(0, path.length() - 1);\n\n        CreateFolderPath redoRecorder = new CreateFolderPath(mId, path, attrs, defaultView, flags, color, url);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"createFolderPath\", octxt, redoRecorder);\n            CreateFolderPath redoPlayer = (CreateFolderPath) mCurrentChange.getRedoPlayer();\n\n            String[] parts = path.substring(1).split(\"/\");\n            if (parts.length == 0)\n                throw MailServiceException.ALREADY_EXISTS(path);\n            int[] recorderFolderIds = new int[parts.length];\n            int[] playerFolderIds = redoPlayer == null ? null : redoPlayer.getFolderIds();\n            if (playerFolderIds != null && playerFolderIds.length != recorderFolderIds.length)\n                throw ServiceException.FAILURE(\"incorrect number of path segments in redo player\", null);\n\n            Folder folder = getFolderById(ID_FOLDER_USER_ROOT);\n            for (int i = 0; i < parts.length; i++) {\n                boolean last = i == parts.length - 1;\n                int folderId = playerFolderIds == null ? ID_AUTO_INCREMENT : playerFolderIds[i];\n                Folder subfolder = folder.findSubfolder(parts[i]);\n                if (subfolder == null)\n                    subfolder = Folder.create(getNextItemId(folderId), this, folder, parts[i], (byte) 0,\n                                              last ? defaultView : MailItem.TYPE_UNKNOWN, flags, color, last ? url : null);\n                else if (folderId != ID_AUTO_INCREMENT && folderId != subfolder.getId())\n                    throw ServiceException.FAILURE(\"parent folder id changed since operation was recorded\", null);\n                else if (last)\n                    throw MailServiceException.ALREADY_EXISTS(path);\n                recorderFolderIds[i] = subfolder.getId();\n                folder = subfolder;\n            }\n            redoRecorder.setFolderIds(recorderFolderIds);\n            success = true;\n            return folder;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void grantAccess(OperationContext octxt, int folderId, String grantee, byte granteeType, short rights, String args) throws ServiceException {\n        GrantAccess redoPlayer = new GrantAccess(mId, folderId, grantee, granteeType, rights, args);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"grantAccess\", octxt, redoPlayer);\n\n            Folder folder = getFolderById(folderId);\n            checkItemChangeID(folder);\n            folder.grantAccess(grantee, granteeType, rights, args);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void revokeAccess(OperationContext octxt, int folderId, String grantee) throws ServiceException {\n        RevokeAccess redoPlayer = new RevokeAccess(mId, folderId, grantee);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"revokeAccess\", octxt, redoPlayer);\n\n            Folder folder = getFolderById(folderId);\n            checkItemChangeID(folder);\n            folder.revokeAccess(grantee);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void setPermissions(OperationContext octxt, int folderId, ACL acl) throws ServiceException {\n        SetPermissions redoPlayer = new SetPermissions(mId, folderId, acl);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"setPermissions\", octxt, redoPlayer);\n\n            Folder folder = getFolderById(folderId);\n            checkItemChangeID(folder);\n            folder.setPermissions(acl);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void setFolderUrl(OperationContext octxt, int folderId, String url) throws ServiceException {\n        SetFolderUrl redoRecorder = new SetFolderUrl(mId, folderId, url);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"setFolderUrl\", octxt, redoRecorder);\n\n            Folder folder = getFolderById(folderId);\n            checkItemChangeID(folder);\n            folder.setUrl(url);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void synchronizeFolder(OperationContext octxt, int folderId) throws ServiceException {\n        Folder folder = getFolderById(octxt, folderId);\n        if (!folder.getUrl().equals(\"\"))\n            importFeed(octxt, folderId, folder.getUrl(), true);\n    }\n\n    public synchronized void importFeed(OperationContext octxt, int folderId, String url, boolean subscription) throws ServiceException {\n        if (url == null || url.equals(\"\"))\n            return;\n\n        // get the remote data, skipping anything we've already seen (if applicable)\n        Folder folder = getFolderById(octxt, folderId);\n        Folder.SyncData fsd = subscription ? folder.getSyncData() : null;\n        FeedManager.SubscriptionData sdata = FeedManager.retrieveRemoteDatasource(getAccount(), url, fsd);\n\n        // If syncing a folder with calendar items, remember the current items.  After applying the new\n        // appointments/tasks, we need to remove ones that were not updated because they are apparently\n        // deleted from the source feed.\n        boolean isCalendar = folder.getDefaultView() == MailItem.TYPE_APPOINTMENT ||\n                             folder.getDefaultView() == MailItem.TYPE_TASK;\n        Set<Integer> existingCalItems = new HashSet<Integer>();\n        if (subscription && isCalendar) {\n            for (int i : listItemIds(octxt, MailItem.TYPE_UNKNOWN, folderId))\n                existingCalItems.add(i);\n        }\n\n        // if there's nothing to add, we can short-circuit here\n        if (sdata.items.isEmpty()) {\n            if (subscription && isCalendar)\n                emptyFolder(octxt, folderId, false);\n            return;\n        }\n\n        // disable modification conflict checks, as we've already wiped the folder and we may hit an appoinment >1 times\n        OperationContext octxtNoConflicts = new OperationContext(octxt).unsetChangeConstraint();\n\n        boolean preserveExistingAlarms = true;\n        // add the newly-fetched items to the folder\n        for (Object obj : sdata.items) {\n            try {\n                if (obj instanceof Invite) {\n                    int calIds[] = addInvite(octxtNoConflicts, (Invite) obj, folderId, preserveExistingAlarms);\n                    if (calIds != null && calIds.length > 0)\n                        existingCalItems.remove(calIds[0]);\n                } else if (obj instanceof ParsedMessage) {\n                    addMessage(octxtNoConflicts, (ParsedMessage) obj, folderId, true, Flag.BITMASK_UNREAD, null);\n                }\n            } catch (IOException e) {\n                throw ServiceException.FAILURE(\"IOException\", e);\n            }\n        }\n\n        // Delete calendar items that have been deleted in the source feed.\n        for (int toRemove : existingCalItems) {\n            delete(octxtNoConflicts, toRemove, MailItem.TYPE_UNKNOWN);\n        }\n\n        // update the subscription to avoid downloading items twice\n        if (subscription && sdata.lastDate > 0) {\n            try {\n                setSubscriptionData(octxt, folderId, sdata.lastDate, sdata.lastGuid);\n            } catch (Exception e) {\n                ZimbraLog.mailbox.warn(\"could not update feed metadata\", e);\n            }\n        }\n    }\n\n    public synchronized void setSubscriptionData(OperationContext octxt, int folderId, long date, String guid) throws ServiceException {\n        SetSubscriptionData redoRecorder = new SetSubscriptionData(mId, folderId, date, guid);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"setSubscriptionData\", octxt, redoRecorder);\n            getFolderById(folderId).setSubscriptionData(guid, date);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void emptyFolder(OperationContext octxt, int folderId, boolean removeSubfolders)\n    throws ServiceException {\n        EmptyFolder redoRecorder = new EmptyFolder(mId, folderId, removeSubfolders);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"emptyFolder\", octxt, redoRecorder);\n\n            Folder folder = getFolderById(folderId);\n            folder.empty(removeSubfolders);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized SearchFolder createSearchFolder(OperationContext octxt, int folderId, String name, String query, String types, String sort, byte color)\n    throws ServiceException {\n        CreateSavedSearch redoRecorder = new CreateSavedSearch(mId, folderId, name, query, types, sort, color);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"createSearchFolder\", octxt, redoRecorder);\n            CreateSavedSearch redoPlayer = (CreateSavedSearch) mCurrentChange.getRedoPlayer();\n\n            int searchId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getSearchId());\n            SearchFolder search = SearchFolder.create(searchId, getFolderById(folderId), name, query, types, sort, color);\n            redoRecorder.setSearchId(search.getId());\n            success = true;\n            return search;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized void modifySearchFolder(OperationContext octxt, int id, String query, String types, String sort)\n    throws ServiceException {\n        ModifySavedSearch redoRecorder = new ModifySavedSearch(mId, id, query, types, sort);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"modifySearchFolder\", octxt, redoRecorder);\n\n            SearchFolder search = getSearchFolderById(id);\n            checkItemChangeID(search);\n\n            search.changeQuery(query, types, sort);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public synchronized Mountpoint createMountpoint(OperationContext octxt, int folderId, String name, String ownerId, int remoteId, byte view, int flags, byte color)\n    throws ServiceException {\n        CreateMountpoint redoRecorder = new CreateMountpoint(mId, folderId, name, ownerId, remoteId, view, flags, color);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"createMountpoint\", octxt, redoRecorder);\n            CreateMountpoint redoPlayer = (CreateMountpoint) mCurrentChange.getRedoPlayer();\n\n            int mptId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getId());\n            Mountpoint mpt = Mountpoint.create(mptId, getFolderById(folderId), name, ownerId, remoteId, view, flags, color);\n            redoRecorder.setId(mpt.getId());\n            success = true;\n            return mpt;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /**\n     * This is the nightly \"delete old messages based on some criteria\" thing that gets spawned\n     * by a cron job.  It can hopefully be moved into a zmmailbox script at some point\n     * \n     * Purge means 'delete forever' in this case.\n     * \n     * @param octxt\n     * @throws ServiceException\n     */\n    public synchronized void purgeMessages(OperationContext octxt) throws ServiceException {\n        ZimbraLog.purge.info(\"Purging messages.\");\n\n        Account acct = getAccount();\n        \n        if (ZimbraLog.purge.isDebugEnabled()) {\n            ZimbraLog.purge.debug(\"System retention policy: Trash=%s, Junk=%s, All messages=%s\",\n                acct.getAttr(Provisioning.A_zimbraMailTrashLifetime),\n                acct.getAttr(Provisioning.A_zimbraMailSpamLifetime),\n                acct.getAttr(Provisioning.A_zimbraMailMessageLifetime));\n            ZimbraLog.purge.debug(\"User-specified retention policy: Inbox read=%s, Inbox unread=%s, Sent=%s, Junk=%s, Trash=%s\",\n                acct.getAttr(Provisioning.A_zimbraPrefInboxReadLifetime),\n                acct.getAttr(Provisioning.A_zimbraPrefInboxUnreadLifetime),\n                acct.getAttr(Provisioning.A_zimbraPrefSentLifetime),\n                acct.getAttr(Provisioning.A_zimbraPrefJunkLifetime),\n                acct.getAttr(Provisioning.A_zimbraPrefTrashLifetime));\n        }\n\n        int globalTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraMailMessageLifetime, 0) / 1000);\n        int systemTrashTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraMailTrashLifetime, 0) / 1000);\n        int systemJunkTimeout  = (int) (acct.getTimeInterval(Provisioning.A_zimbraMailSpamLifetime, 0) / 1000);\n\n        int userInboxReadTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraPrefInboxReadLifetime, 0) / 1000);\n        int userInboxUnreadTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraPrefInboxUnreadLifetime, 0) / 1000);\n        int userTrashTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraPrefTrashLifetime, 0) / 1000);\n        int userJunkTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraPrefJunkLifetime, 0) / 1000);\n        int userSentTimeout = (int) (acct.getTimeInterval(Provisioning.A_zimbraPrefSentLifetime, 0) / 1000);\n\n        int trashTimeout = pickTimeout(systemTrashTimeout, userTrashTimeout);\n        int junkTimeout = pickTimeout(systemJunkTimeout, userJunkTimeout);\n\n        if (globalTimeout <= 0 && trashTimeout <= 0 && junkTimeout <= 0 &&\n            userInboxReadTimeout <= 0 && userInboxReadTimeout <= 0 &&\n            userInboxUnreadTimeout <= 0 && userSentTimeout <= 0)\n            // Nothing to do\n            return;\n\n        // sanity-check the really dangerous value...\n        if (globalTimeout > 0 && globalTimeout < Constants.SECONDS_PER_MONTH) {\n            // this min is also used by POP3 EXPIRE command. update Pop3Handler.MIN_EPXIRE_DAYS if it changes.\n            ZimbraLog.purge.warn(\"global message timeout < 1 month; defaulting to 31 days\");\n            globalTimeout = Constants.SECONDS_PER_MONTH;\n        }\n\n        PurgeOldMessages redoRecorder = new PurgeOldMessages(mId);\n\n        boolean success = false;\n        try {\n            beginTransaction(\"purgeMessages\", octxt, redoRecorder);\n\n            // get the folders we're going to be purging\n            Folder trash = getFolderById(ID_FOLDER_TRASH);\n            Folder junk  = getFolderById(ID_FOLDER_SPAM);\n            Folder sent = getFolderById(ID_FOLDER_SENT);\n            Folder inbox = getFolderById(ID_FOLDER_INBOX);\n\n            if (globalTimeout > 0)\n                Folder.purgeMessages(this, null, getOperationTimestamp() - globalTimeout, null);\n            if (trashTimeout > 0)\n                Folder.purgeMessages(this, trash, getOperationTimestamp() - trashTimeout, null);\n            if (junkTimeout > 0)\n                Folder.purgeMessages(this, junk, getOperationTimestamp() - junkTimeout, null);\n            if (userInboxReadTimeout > 0)\n                Folder.purgeMessages(this, inbox, getOperationTimestamp() - userInboxReadTimeout, false);\n            if (userInboxUnreadTimeout > 0)\n                Folder.purgeMessages(this, inbox, getOperationTimestamp() - userInboxUnreadTimeout, true);\n            if (userSentTimeout > 0)\n                Folder.purgeMessages(this, sent, getOperationTimestamp() - userSentTimeout, null);\n\n            // deletes have already been collected, so fetch the tombstones and write once\n            TypedIdList tombstones = collectPendingTombstones();\n            if (tombstones != null && !tombstones.isEmpty())\n                DbMailItem.writeTombstones(this, tombstones);\n\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    /** Returns the smaller non-zero value, or <tt>0</tt> if both\n     *  <tt>t1</tt> and <tt>t2</tt> are <tt>0</tt>. */\n    private int pickTimeout(int t1, int t2) {\n        if (t1 == 0)\n            return t2;\n        if (t2 == 0)\n            return t1;\n        return Math.min(t1, t2);\n    }\n\n    public synchronized void purgeImapDeleted(OperationContext octxt) throws ServiceException {\n        PurgeImapDeleted redoRecorder = new PurgeImapDeleted(mId);\n        boolean success = false;\n        try {\n            beginTransaction(\"purgeImapDeleted\", octxt, redoRecorder);\n\n            Set<Folder> purgeable = getAccessibleFolders((short) (ACL.RIGHT_READ | ACL.RIGHT_DELETE));\n            PendingDelete info = DbMailItem.getImapDeleted(this, purgeable);\n            MailItem.delete(this, info, null, MailItem.DeleteScope.ENTIRE_ITEM, true);\n            success = true;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public WikiItem createWiki(OperationContext octxt, int folderId, String wikiword, String author, InputStream data)\n    throws ServiceException {\n        return (WikiItem) createDocument(octxt, folderId, wikiword, WikiItem.WIKI_CONTENT_TYPE, author, data, MailItem.TYPE_WIKI);\n    }\n\n    public Document createDocument(OperationContext octxt, int folderId, String filename, String mimeType, String author, InputStream data)\n    throws ServiceException {\n        return createDocument(octxt, folderId, filename, mimeType, author, data, MailItem.TYPE_DOCUMENT);\n    }\n    \t\n    public Document createDocument(OperationContext octxt, int folderId, String filename, String mimeType, String author, InputStream data, byte type)\n    throws ServiceException {\n        maybeIndexDeferredItems();\n        try {\n            ParsedDocument pd = new ParsedDocument(data, filename, mimeType, System.currentTimeMillis(), author);\n            return createDocument(octxt, folderId, pd, type);\n        } catch (IOException e) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(e);\n        }\n    }\n\n    public synchronized Document createDocument(OperationContext octxt, int folderId, ParsedDocument pd, byte type)\n    throws ServiceException {\n        SaveDocument redoRecorder = new SaveDocument(mId, pd.getDigest(), pd.getSize(), folderId);\n        boolean success = false;\n        try {\n            beginTransaction(\"createDoc\", octxt, redoRecorder);\n            redoRecorder.setDocument(pd);\n            redoRecorder.setItemType(type);\n            \n            SaveDocument redoPlayer = (octxt == null ? null : (SaveDocument) octxt.getPlayer());\n            int itemId  = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getMessageId());\n            short volumeId = redoPlayer == null ? pd.getBlob().getVolumeId() : redoPlayer.getVolumeId();\n\n            Document doc;\n            if (type == MailItem.TYPE_DOCUMENT)\n                doc = Document.create(itemId, getFolderById(folderId), volumeId, pd.getFilename(), pd.getContentType(), pd);\n            else if (type == MailItem.TYPE_WIKI)\n                doc = WikiItem.create(itemId, getFolderById(folderId), volumeId, pd.getFilename(), pd);\n            else\n                throw MailServiceException.INVALID_TYPE(type);\n\n            redoRecorder.setMessageId(doc.getId());\n            Blob blob = doc.setContent(pd);\n            redoRecorder.setMessageBodyInfo(blob.getFile(), blob.getVolumeId());\n\n            queueForIndexing(doc, false, this.getBatchedIndexingCount() > 0 ? null : pd.getDocumentList());\n            success = true;\n            return doc;\n        } catch (IOException ioe) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(ioe);\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public Document addDocumentRevision(OperationContext octxt, int docId, byte type, InputStream data, String author) throws ServiceException {\n        maybeIndexDeferredItems();\n        Document doc = getDocumentById(octxt, docId);\n        try {\n            ParsedDocument pd = new ParsedDocument(data, doc.getName(), doc.getContentType(), System.currentTimeMillis(), author);\n            return addDocumentRevision(octxt, docId, type, pd);\n        } catch (IOException e) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(e);\n        }\n    }\n\n    public synchronized Document addDocumentRevision(OperationContext octxt, int docId, byte type, ParsedDocument pd) throws ServiceException {\n        AddDocumentRevision redoRecorder = new AddDocumentRevision(mId, pd.getDigest(), pd.getSize(), 0);\n        \n        boolean deferIndexing = this.getBatchedIndexingCount() > 0 || pd.hasTemporaryAnalysisFailure();\n        \n        boolean success = false;\n        try {\n            beginTransaction(\"addDocumentRevision\", octxt, redoRecorder);\n\n            Document doc = getDocumentById(docId);\n            Blob blob = doc.setContent(pd);\n\n            redoRecorder.setDocument(pd);\n            redoRecorder.setDocId(docId);\n            redoRecorder.setItemType(type);\n            // TODO: simplify the redoRecorder by not subclassing from CreateMessage\n            redoRecorder.setMessageBodyInfo(blob.getFile(), blob.getVolumeId());\n            \n            queueForIndexing(doc, false, deferIndexing ? null : pd.getDocumentList());\n\n            success = true;\n            return doc;\n        } catch (IOException ioe) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(ioe);\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n    public Message updateOrCreateChat(OperationContext octxt, ParsedMessage pm, int id) throws IOException, ServiceException {\n        // make sure the message has been analzyed before taking the Mailbox lock\n        if (getBatchedIndexingCount() == 0)\n            pm.analyzeFully();\n        try {\n            pm.getRawData();\n        } catch (MessagingException me) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(me);\n        }\n        // special-case saving a new Chat\n        if (id == ID_AUTO_INCREMENT)\n            return createChat(octxt, pm, ID_FOLDER_IM_LOGS, Flag.BITMASK_FROM_ME, null);\n        else\n            return updateChat(octxt, pm, id);\n    }\n\n    public Chat createChat(OperationContext octxt, ParsedMessage pm, int folderId, int flags, String tagsStr)\n    throws IOException, ServiceException {\n        if (pm == null)\n            throw ServiceException.INVALID_REQUEST(\"null ParsedMessage when adding chat to mailbox \" + mId, null);\n\n        byte[] data;\n        String digest;\n        int msgSize;\n        try {\n            data = pm.getRawData();  \n            digest = pm.getRawDigest();  \n            msgSize = pm.getRawSize();\n        } catch (MessagingException me) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(me);\n        }\n\n        maybeIndexDeferredItems();\n        boolean deferIndexing = getBatchedIndexingCount() > 0;\n        List<org.apache.lucene.document.Document> docList = null;\n        if (!deferIndexing) {\n            pm.analyzeFully();\n            docList = pm.getLuceneDocuments();\n        }\n\n        synchronized (this) {\n            if (deferIndexing) {\n                flags |= Flag.BITMASK_INDEXING_DEFERRED;\n                incrementIndexDeferredCount(1);\n            }\n            \n            CreateChat redoRecorder = new CreateChat(mId, digest, msgSize, folderId, flags, tagsStr);\n            Blob blob = null;\n            \n            boolean success = false;\n            try {\n                beginTransaction(\"createChat\", octxt, redoRecorder);\n                CreateChat redoPlayer = (octxt == null ? null : (CreateChat) octxt.getPlayer());\n                \n                long tags = Tag.tagsToBitmask(tagsStr);\n                int itemId = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getMessageId());\n                short volumeId = redoPlayer == null ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n\n                StoreManager sm = StoreManager.getInstance();\n                blob = sm.storeIncoming(data, digest, null, volumeId);\n                redoRecorder.setMessageBodyInfo(data, blob.getPath(), blob.getVolumeId());\n                markOtherItemDirty(blob);\n\n                Chat chat = Chat.create(itemId, getFolderById(folderId), pm, msgSize, digest, volumeId, false, flags, tags);\n                sm.link(blob, this, itemId, chat.getSavedSequence(), chat.getVolumeId());\n                redoRecorder.setMessageId(chat.getId());\n                \n                queueForIndexing(chat, false, docList);\n                assert(!deferIndexing || chat.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED));\n                success = true;\n                return chat;\n            } finally {\n                endTransaction(success);\n            }\n        }\n    }\n    \n    public synchronized Chat updateChat(OperationContext octxt, ParsedMessage pm, int id) throws IOException, ServiceException {\n        byte[] data;\n        String digest;\n        int size;\n        try {\n            data = pm.getRawData();  \n            digest = pm.getRawDigest();  \n            size = pm.getRawSize();\n        } catch (MessagingException me) {\n            throw MailServiceException.MESSAGE_PARSE_ERROR(me);\n        }\n\n        boolean deferIndexing = getIndexDeferredCount() > 0 || pm.hasTemporaryAnalysisFailure();\n        List<org.apache.lucene.document.Document> docList = null;\n        if (!deferIndexing)\n            docList = pm.getLuceneDocuments();\n\n        SaveChat redoRecorder = new SaveChat(mId, id, digest, size, -1, 0, null);\n        boolean success = false;\n        try {\n            beginTransaction(\"saveChat\", octxt, redoRecorder);\n            SaveChat redoPlayer = (SaveChat) mCurrentChange.getRedoPlayer();\n            Chat chat = (Chat) getItemById(id, MailItem.TYPE_CHAT);\n            \n            if (!chat.isMutable()) \n                throw MailServiceException.IMMUTABLE_OBJECT(id);\n            if (!checkItemChangeID(chat))\n                throw MailServiceException.MODIFY_CONFLICT();\n\n            // content changed, so we're obliged to change the IMAP uid\n            int imapID = getNextItemId(redoPlayer == null ? ID_AUTO_INCREMENT : redoPlayer.getImapId());\n            redoRecorder.setImapId(imapID);\n\n            short volumeId = redoPlayer == null ? Volume.getCurrentMessageVolume().getId() : redoPlayer.getVolumeId();\n\n            // update the content and increment the revision number\n            Blob blob = chat.setContent(data, digest, volumeId, pm);\n            redoRecorder.setMessageBodyInfo(data, blob.getPath(), blob.getVolumeId());\n\n            // NOTE: msg is now uncached (will this cause problems during commit/reindex?)\n            queueForIndexing(chat, true, docList);\n\n            success = true;\n            return chat;\n        } finally {\n            endTransaction(success);\n        }\n    }\n\n\n    // Coordinate other conflicting operations (such as backup) and shared delivery, delivery of a message to\n    // multiple recipients.  Such operation on a mailbox and shared delivery\n    // are mutually exclusive.  More precisely, the op may not begin\n    // when there is a shared delivery in progress for the mailbox.\n    // Delivery of a shared message to the mailbox must be denied and\n    // deferred when the mailbox is being operated on or has a request\n    // for such op pending.\n    private static class SharedDeliveryCoordinator {\n        public int mNumDelivs;\n        public boolean mSharedDeliveryAllowed;\n        public SharedDeliveryCoordinator() {\n            mNumDelivs = 0;\n            mSharedDeliveryAllowed = true;\n        }\n    }\n\n    private SharedDeliveryCoordinator mSharedDelivCoord =\n        new SharedDeliveryCoordinator();\n\n    /**\n     * Puts mailbox in shared delivery mode.  A shared delivery is delivery of\n     * a message to multiple recipients.  Conflicting op on mailbox is disallowed\n     * while mailbox is in shared delivery mode.  (See bug 2187)\n     * Conversely, a shared delivery may not start on a mailbox that is\n     * currently being operated on or when there is a pending op request.\n     * For example, thread A puts mailbox in shared delivery mode.  Thread B\n     * then tries to backup the mailbox.  Backup cannot start until thread A is\n     * done, but mailbox is immediately put into backup-pending mode.\n     * Thread C then tries to do another shared delivery on the mailbox, but\n     * is not allowed to do so because of thread B's pending backup request.\n     * A thread that calls this method must call endSharedDelivery() after\n     * delivering the message.\n     * @return true if shared delivery may begin; false if shared delivery may\n     *         not begin because of a pending backup request\n     */\n    public boolean beginSharedDelivery() {\n        synchronized (mSharedDelivCoord) {\n            assert(mSharedDelivCoord.mNumDelivs >= 0);\n            if (mSharedDelivCoord.mSharedDeliveryAllowed) {\n                mSharedDelivCoord.mNumDelivs++;\n                if (ZimbraLog.mailbox.isDebugEnabled()) {\n                    ZimbraLog.mailbox.debug(\"# of shared deliv incr to \" + mSharedDelivCoord.mNumDelivs +\n                                \" for mailbox \" + getId());\n                }\n                return true;\n            } else {\n                // If request for other ops is pending on this mailbox, don't allow\n                // any more shared deliveries from starting.\n                return false;\n            }\n        }\n    }\n\n    /**\n     * @see com.zimbra.cs.mailbox.Mailbox#beginSharedDelivery()\n     */\n    public void endSharedDelivery() {\n        synchronized (mSharedDelivCoord) {\n            mSharedDelivCoord.mNumDelivs--;\n            if (ZimbraLog.mailbox.isDebugEnabled()) {\n                ZimbraLog.mailbox.debug(\"# of shared deliv decr to \" + mSharedDelivCoord.mNumDelivs +\n                            \" for mailbox \" + getId());\n            }\n            assert(mSharedDelivCoord.mNumDelivs >= 0);\n            if (mSharedDelivCoord.mNumDelivs == 0) {\n                // Wake up any waiting backup thread.\n                mSharedDelivCoord.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Turns shared delivery on/off.  If turning off, waits until the op can begin,\n     * i.e. until all currently ongoing shared deliveries finish.  A thread\n     * turning shared delivery off must turn it on at the end of the operation, otherwise\n     * no further shared deliveries are possible to the mailbox.\n     * @param onoff\n     */\n    public void setSharedDeliveryAllowed(boolean onoff) {\n        synchronized (mSharedDelivCoord) {\n            if (onoff) {\n                // allow shared delivery\n                mSharedDelivCoord.mSharedDeliveryAllowed = true;\n            } else {\n                // disallow shared delivery\n                mSharedDelivCoord.mSharedDeliveryAllowed = false;\n            }\n            mSharedDelivCoord.notifyAll();\n        }\n    }\n\n    /**\n     * Wait until shared delivery is completed on this mailbox.  Other conflicting ops may begin when\n     * there is no shared delivery in progress.  Call setSharedDeliveryAllowed(false)\n     * before calling this method.\n     *\n     */\n    public void waitUntilSharedDeliveryCompletes() {\n        synchronized (mSharedDelivCoord) {\n            while (mSharedDelivCoord.mNumDelivs > 0) {\n                try {\n                    mSharedDelivCoord.wait(3000);\n                    ZimbraLog.misc.info(\"wake up from wait for completion of shared delivery; mailbox=\" + getId() + \n                                \" # of shared deliv=\" + mSharedDelivCoord.mNumDelivs);\n                } catch (InterruptedException e) {}\n            }\n        }\n    }\n\n    /**\n     * Tests whether shared delivery is completed on this mailbox.  Other conflicting ops may begin when\n     * there is no shared delivery in progress.\n     */\n    public boolean isSharedDeliveryComplete() {\n        synchronized (mSharedDelivCoord) {\n            return mSharedDelivCoord.mNumDelivs < 1;\n        }\n    }\n\n\n    /**\n     * Be very careful when changing code in this method.  The order of almost\n     * every line of code is important to ensure correct redo logging and crash\n     * recovery.\n     * @param success\n     * @throws ServiceException\n     */\n    synchronized void endTransaction(boolean success) throws ServiceException {\n        assert(Thread.holdsLock(this));\n        if (!mCurrentChange.isActive()) {\n            // would like to throw here, but it might cover another exception...\n            ZimbraLog.mailbox.warn(\"cannot end a transaction when not inside a transaction\", new Exception());\n            return;\n        }\n        if (!mCurrentChange.endChange())\n            return;\n\n        Connection conn = mCurrentChange.conn;\n        ServiceException exception = null;\n\n        // update mailbox size and folder unread/message counts\n        if (success) {\n            try {\n                snapshotCounts();\n            } catch (ServiceException e) {\n                exception = e;\n                success = false;\n            }\n        }\n\n        // Failure case is very simple.  Just rollback the database and cache\n        // and return.  We haven't logged anything to the redo log for this\n        // transaction, so no redo cleanup is necessary.\n        if (!success) {\n            if (conn != null)\n                DbPool.quietRollback(conn);\n            rollbackCache(mCurrentChange);\n            if (exception != null)\n                throw exception;\n            return;\n        }\n\n        boolean needRedo = true;\n        if (mCurrentChange.octxt != null)\n            needRedo = mCurrentChange.octxt.needRedo();\n        RedoableOp redoRecorder = mCurrentChange.recorder;\n        List<IndexItem> indexRedoList = null;\n        Map<MailItem, MailboxChange.IndexItemEntry> itemsToIndex = mCurrentChange.indexItems;\n        boolean indexingNeeded = !itemsToIndex.isEmpty() && !DebugConfig.disableIndexing;\n\n        // 1. Log the change redo record for main transaction.\n        //    If indexing is to be followed, log this entry\n        //    without requiring fsync, because logging for\n        //    indexing entry will do fsync, which will fsync\n        //    this entry at the same time.\n        if (redoRecorder != null && needRedo)\n            redoRecorder.log(!indexingNeeded);\n\n        boolean allGood = false;\n        try {\n            if (indexingNeeded) {\n                indexRedoList = new ArrayList<IndexItem>();\n                \n                // See bug 15072 - we need to clear mCurrentChange.indexItems (it is stored in a temporary)\n                // here, just in case item.reindex() recurses into a new transaction...\n                mCurrentChange.indexItems = new HashMap<MailItem, MailboxChange.IndexItemEntry>();\n                \n                // track to see if we make a net change to idxDeferredCount -- if so we'll need to re-write the Mailbox\n                // row to the DB an extra time\n                int idxDeferredChange = 0;\n                \n                List<Integer> deferredTagsToClear = new ArrayList<Integer>();\n                List<Integer> deferredTagsToSet = new ArrayList<Integer>();\n                \n                try {\n                    if (mMailboxIndex != null)\n                        mMailboxIndex.deleteDocuments(mCurrentChange.indexItemsToDelete);\n                } catch (IOException e) {\n                    if (ZimbraLog.index.isDebugEnabled())\n                        ZimbraLog.index.debug(\"Caught IOException attempting to delete index entries in EndTransaction\", e);\n                }\n\n                int numIndexingExceptions = 0;\n                \n                for (Map.Entry<MailItem, MailboxChange.IndexItemEntry> entry : itemsToIndex.entrySet()) {\n                    MailItem item = entry.getKey();\n                    if (entry.getValue().mData == null) {\n                        ZimbraLog.index.warn(\"Got NULL index data in endTransaction.  Item \"+item.getId()+\" will not be indexed.\");\n                        continue;\n                    }\n                    if (entry.getValue().mData.size() == 0 && !entry.getValue().mDeleteFirst &&((item.getFlagBitmask()&Flag.BITMASK_INDEXING_DEFERRED)==0)) \n                        continue; // nothing to do here.\n                    \n                    IndexItem indexRedo = null;\n                    \n                    if (needRedo) {\n                        indexRedo = new IndexItem(mId, item.getId(), item.getType(), entry.getValue().mDeleteFirst);\n                        indexRedo.start(getOperationTimestampMillis());\n                        if (redoRecorder != null) {\n                            indexRedo.setParentOp(redoRecorder);\n                            indexRedoList.add(indexRedo);\n                        } else {\n                            // there's no outer redoOp here so don't bother with the list, we can let this indexRedo commit whenever it wants to\n                            indexRedo.allowCommit();\n                        }\n                    }\n\n                    try {\n                        // 2. Index the item before committing the main\n                        // transaction.  This allows us to set the \"Indexing Deferred\n                        // for this item\" flag if indexing fails, without creating\n                        // an extra DB transaction.  Write the log record for indexing \n                        // only after indexing actually works.\n                        if (getMailboxIndex() != null) {\n                            getMailboxIndex().indexMailItem(this, indexRedo, entry.getValue().mDeleteFirst, entry.getValue().mData, item);\n                        }\n                        \n                        if ((item.getFlagBitmask() & Flag.BITMASK_INDEXING_DEFERRED) != 0) {\n                            // IndexingDeferredFlag set, so we need to clear it\n                            deferredTagsToClear.add(item.getId());\n                            item.tagChanged(mIndexingDeferredFlag, false);\n                            this.incrementIndexDeferredCount(-1);\n                            idxDeferredChange--;\n                        }\n                        \n                        // 3. Write the change redo record for indexing\n                        //    sub-transaction to guarantee that it appears in the\n                        //    redo log stream before the commit record for main\n                        //    transaction.  If main transaction commit record is\n                        //    written first and the server crashes before writing\n                        //    the indexing change record, we won't be able to\n                        //    re-execute indexing during crash recovery, and we will\n                        //    end up with an unindexed item.\n                        if (needRedo)\n                            indexRedo.log();\n\n                        // successfully indexed something!  The index isn't totally corrupt: zero out the \n                        // failure timestamp so that indexItemList can use the full transaction size\n                        mLastIndexingFailureTimestamp = 0;\n                        \n                    } catch (Exception e) {\n                        if (numIndexingExceptions == 0) {\n                            // log the first exception at INFO level, but log the rest of them at DEBUG\n                            if (ZimbraLog.index.isDebugEnabled())\n                                ZimbraLog.index.debug(\"Caught exception while indexing message id \"+item.mId+\" - indexing deferred\", e);\n                        } else {\n                            if (ZimbraLog.index.isDebugEnabled())\n                                ZimbraLog.index.debug(\"Caught exception while indexing message id \"+item.mId+\" - indexing deferred\", e);\n                        }\n                        \n                        if (!item.isFlagSet(Flag.BITMASK_INDEXING_DEFERRED)) {\n                            // IndexingDeferredFlag NOT set, so we need to set it\n                            deferredTagsToSet.add(item.getId());\n                            item.tagChanged(mIndexingDeferredFlag, true);\n                            this.incrementIndexDeferredCount(1);\n                            idxDeferredChange++;\n                        }\n                        numIndexingExceptions++;\n                    }\n                }\n                \n                if (!deferredTagsToClear.isEmpty()) {\n                    if (conn == null)\n                        conn = getOperationConnection();\n                    DbMailItem.alterTag(mIndexingDeferredFlag, deferredTagsToClear, false);\n                }\n                if (!deferredTagsToSet.isEmpty()) {\n                    if (conn == null)\n                        conn = getOperationConnection();\n                    DbMailItem.alterTag(mIndexingDeferredFlag, deferredTagsToSet, true);\n                }\n                if (idxDeferredChange != 0) {\n                    DbMailbox.updateMailboxStats(this);// must persist idxDeferedCount to DB\n                    if (ZimbraLog.index.isDebugEnabled()) \n                        ZimbraLog.index.debug(\"Indexing deferred count changed (\"+idxDeferredChange+\").  Currently \"+this.getIndexDeferredCount()+\" deferred index items.\");\n                }\n                \n                if (numIndexingExceptions >= itemsToIndex.size()) {\n                    ZimbraLog.index.warn(\"Possibly corrupt index: \"+numIndexingExceptions+\" indexing operations failed in mailbox transaction.\");\n                    mLastIndexingFailureTimestamp = System.currentTimeMillis();\n                }\n            }\n            \n            // 4. Commit the main transaction in database.\n            if (conn != null) {\n                try {\n                    conn.commit();\n                } catch (Throwable t) {\n                    // Any exception during database commit is a disaster\n                    // because we don't know if the change is committed or\n                    // not.  Force the server to abort.  Next restart will\n                    // redo the operation to ensure the change is made and\n                    // committed.  (bug 2121)\n                    Zimbra.halt(\"Unable to commit database transaction.  Forcing server to abort.\", t);\n                }\n            }\n            \n            allGood = true;\n        } finally {\n            if (!allGood) {\n                // We will get here if indexing commit failed.\n                // (Database commit hasn't happened.)\n\n                // Write abort redo records to prevent the transactions from\n                // being redone during crash recovery.\n\n                // Write abort redo entries before doing database rollback.\n                // If we do rollback first and server crashes, crash\n                // recovery will try to redo the operation.\n\n                // Write abort redo record for indexing transaction before writing\n                // abort record for main.  This prevents indexing from\n                // being redone during crash recovery when main transaction\n                // was never committed.\n                if (needRedo) {\n                    if (indexRedoList != null)\n                        for (IndexItem indexRedo : indexRedoList) \n                            indexRedo.abort();\n                    \n                    if (redoRecorder != null)\n                        redoRecorder.abort();\n                }\n                if (conn != null)\n                    DbPool.quietRollback(conn);\n                rollbackCache(mCurrentChange);\n            }\n        }\n\n        if (allGood) {\n            if (needRedo) {\n                // 5. Write commit record for main transaction.\n                //    By writing the commit record for main transaction before\n                //    calling MailItem.reindex(), we are guaranteed to see the\n                //    commit-main record in the redo stream before\n                //    commit-index record.  This order ensures that during\n                //    crash recovery the main transaction is redone before\n                //    indexing.  If the order were reversed, crash recovery\n                //    would attempt to index an item which hasn't been created\n                //    yet or would attempt to index the item with\n                //    pre-modification value.  The first case would result in\n                //    a redo error, and the second case would index the wrong\n                //    value.\n                if (redoRecorder != null) {\n                    \n                    if (mCurrentChange.mDirty != null && mCurrentChange.mDirty.changedTypes != 0) {\n                        // if an \"all accounts\" waitset is active, and this change has an appropriate type,\n                        // then we'll need to set a commit-callback\n                        AllAccountsRedoCommitCallback cb =\n                            AllAccountsRedoCommitCallback.getRedoCallbackIfNecessary(getAccountId(), mCurrentChange.mDirty.changedTypes);\n                        if (cb != null) {\n                            redoRecorder.setCommitCallback(cb);\n                        }\n                    }\n                    redoRecorder.commit();\n                }\n    \n                // 6. The commit redo record for indexing sub-transaction is\n                //    written in batch by another thread.  To avoid the batch\n                //    commit thread's writing commit-index before this thread's\n                //    writing commit-main (step 5 above), the index redo object\n                //    is initialized to block the commit attempt by default.\n                //    At this point we've written the commit-main record, so\n                //    unblock the commit on indexing.\n                if (indexRedoList != null)\n                    for (IndexItem indexRedo : indexRedoList)\n                        indexRedo.allowCommit();\n            }\n\n            // 7. We are finally done with database and redo commits.\n            //    Cache update comes last.\n            commitCache(mCurrentChange);\n        }\n    }\n\n    // if the incoming message has one of these flags, don't up our \"new messages\" counter\n    public static final int NON_DELIVERY_FLAGS = Flag.BITMASK_DRAFT | Flag.BITMASK_FROM_ME | Flag.BITMASK_COPIED | Flag.BITMASK_DELETED;\n\n    void snapshotCounts() throws ServiceException {\n        // for write ops, update the \"new messages\" count in the DB appropriately\n        RedoableOp recorder = mCurrentChange.recorder;\n        if (recorder != null && mCurrentChange.getRedoPlayer() == null) {\n            boolean isNewMessage = recorder.getOpCode() == RedoableOp.OP_CREATE_MESSAGE;\n            if (isNewMessage) {\n                CreateMessage cm = (CreateMessage) recorder;\n                if (cm.getFolderId() == ID_FOLDER_SPAM || cm.getFolderId() == ID_FOLDER_TRASH)\n                    isNewMessage = false;\n                else if ((cm.getFlags() & NON_DELIVERY_FLAGS) != 0)\n                    isNewMessage = false;\n                else if (mCurrentChange.octxt != null && mCurrentChange.octxt.getSession() != null && !mCurrentChange.octxt.isDelegatedRequest(this))\n                    isNewMessage = false;\n            }\n            boolean isSoapRequest = mCurrentChange.octxt != null && mCurrentChange.octxt.getSession() instanceof SoapSession;\n            if (isNewMessage)\n                mCurrentChange.recent = mData.recentMessages + 1;\n            else if (isSoapRequest && mData.recentMessages != 0)\n                mCurrentChange.recent = 0;\n        }\n\n        if (mCurrentChange.isMailboxRowDirty(mData))\n            DbMailbox.updateMailboxStats(this);\n\n        if (mCurrentChange.mDirty != null && mCurrentChange.mDirty.hasNotifications()) {\n            if (mCurrentChange.mDirty.created != null) {\n                for (MailItem item : mCurrentChange.mDirty.created.values()) {\n                    if (item instanceof Folder && item.getSize() != 0)\n                        ((Folder) item).saveFolderCounts(false);\n                    else if (item instanceof Tag && item.isUnread())\n                        ((Tag) item).saveTagCounts();\n                }\n            }\n\n            if (mCurrentChange.mDirty.modified != null) {\n                for (Change change : mCurrentChange.mDirty.modified.values()) {\n                    if ((change.why & (Change.MODIFIED_UNREAD | Change.MODIFIED_SIZE)) != 0 && change.what instanceof Folder)\n                        ((Folder) change.what).saveFolderCounts(false);\n                    else if ((change.why & Change.MODIFIED_UNREAD) != 0 && change.what instanceof Tag)\n                        ((Tag) change.what).saveTagCounts();\n                }\n            }\n        }\n    }\n\n    private void commitCache(MailboxChange change) {\n        assert(Thread.holdsLock(this));\n        if (change == null)\n            return;\n\n        // save for notifications (below)\n        PendingModifications dirty = null;\n        if (change.mDirty != null && change.mDirty.hasNotifications()) {\n            dirty = change.mDirty;\n            change.mDirty = new PendingModifications();\n        }\n\n        Session source = mCurrentChange.octxt == null ? null : mCurrentChange.octxt.getSession();\n\n        try {\n            // the mailbox data has changed, so commit the changes\n            if (change.sync != null)\n                mData.trackSync = change.sync;\n            if (change.imap != null)\n                mData.trackImap = change.imap;\n            if (change.size != MailboxChange.NO_CHANGE)\n                mData.size = change.size;\n            if (change.itemId != MailboxChange.NO_CHANGE)\n                mData.lastItemId = change.itemId;\n            if (change.contacts != MailboxChange.NO_CHANGE)\n                mData.contacts = change.contacts;\n            if (change.changeId != MailboxChange.NO_CHANGE && change.changeId > mData.lastChangeId) {\n                mData.lastChangeId   = change.changeId;\n                mData.lastChangeDate = change.timestamp;\n            }\n            if (change.accessed != MailboxChange.NO_CHANGE)\n                mData.lastWriteDate = change.accessed;\n            if (change.recent != MailboxChange.NO_CHANGE)\n                mData.recentMessages = change.recent;\n            if (change.config != null) {\n                if (change.config.getSecond() == null) {\n                    if (mData.configKeys != null)\n                        mData.configKeys.remove(change.config.getFirst());\n                } else {\n                    if (mData.configKeys == null)\n                        mData.configKeys = new HashSet<String>(1);\n                    mData.configKeys.add(change.config.getFirst());\n                }\n            }\n            if (change.idxDeferred != MailboxChange.NO_CHANGE)\n                mData.idxDeferredCount = change.idxDeferred;\n\n            // delete any index entries associated with items deleted from db\n            PendingDelete deletes = mCurrentChange.deletes;\n            if (deletes != null && deletes.indexIds != null && !deletes.indexIds.isEmpty() && mMailboxIndex != null) {\n                try {\n                    List<Integer> idxDeleted = mMailboxIndex.deleteDocuments(deletes.indexIds);\n                    if (idxDeleted.size() != deletes.indexIds.size()) {\n                        if (ZimbraLog.index.isInfoEnabled()) \n                            ZimbraLog.index.info(\"could not delete all index entries for items: \" + deletes.itemIds.getAll());\n                    }\n                } catch (IOException e) {\n                    ZimbraLog.index.info(\"ignoring error while deleting index entries for items: \" + deletes.itemIds.getAll(), e);\n                }\n            }\n\n            // remove cached messages\n            if (deletes != null && deletes.blobs != null) {\n                for (String digest : deletes.blobDigests)\n                    MessageCache.purge(digest);\n            }\n\n            // delete any blobs associated with items deleted from db/index\n            StoreManager sm = StoreManager.getInstance();\n            if (deletes != null && deletes.blobs != null) {\n                for (MailboxBlob blob : deletes.blobs) {\n                    try {\n                        if (blob != null)\n                        sm.delete(blob);\n                    } catch (IOException e) {\n                        ZimbraLog.mailbox.warn(\"could not delete blob \" + blob.getPath() + \" during commit\");\n                    }\n                }\n            }\n        } catch (RuntimeException e) {\n            ZimbraLog.mailbox.error(\"ignoring error during cache commit\", e);\n        } finally {\n            // keep our MailItem cache at a reasonable size\n            trimItemCache();\n            // make sure we're ready for the next change\n            change.reset();\n        }\n\n        // if the calendar items has changed in the mailbox,\n        // recalculate the free/busy for the user and propogate to\n        // other system.\n    \tif (dirty != null && dirty.hasNotifications()) {\n    \t\tFreeBusyProvider.mailboxChanged(getAccountId(), dirty.changedTypes);\n        \tMailboxListener.mailboxChanged(getAccountId(), dirty.changedTypes, change.octxt);\n    \t}\n\n        // committed changes, so notify any listeners\n        if (!mListeners.isEmpty() && dirty != null && dirty.hasNotifications()) {\n            for (Session session : new ArrayList<Session>(mListeners)) {\n                try {\n                    session.notifyPendingChanges(dirty, mData.lastChangeId, source);\n                } catch (RuntimeException e) {\n                    ZimbraLog.mailbox.error(\"ignoring error during notification\", e);\n                }\n            }\n        }\n    }\n\n    private void rollbackCache(MailboxChange change) {\n        if (change == null)\n            return;\n\n        try {\n            // rolling back changes, so purge dirty items from the various caches\n            Map cache = change.itemCache;\n            for (Map map : new Map[] {change.mDirty.created, change.mDirty.deleted, change.mDirty.modified}) {\n                if (map != null) {\n                    for (Object obj : map.values()) {\n                        if (obj instanceof Change)\n                            obj = ((Change) obj).what;\n\n                        if (obj instanceof Tag)\n                            purge(MailItem.TYPE_TAG);\n                        else if (obj instanceof Folder)\n                            purge(MailItem.TYPE_FOLDER);\n                        else if (obj instanceof MailItem && cache != null)\n                            cache.remove(new Integer(((MailItem) obj).getId()));\n                        else if (obj instanceof Integer && cache != null)\n                            cache.remove(obj);\n                    }\n                }\n            }\n\n            // roll back any changes to external items\n            // FIXME: handle mOtherDirtyStuff:\n            //    - LeafNodeInfo (re-index all un-indexed files)\n            //    - MailboxBlob  (delink/remove new file)\n            //    - String       (remove from mConvHashes map)\n            StoreManager sm = StoreManager.getInstance();\n            for (Object obj : change.mOtherDirtyStuff) {\n                if (obj instanceof MailboxBlob) {\n                    MailboxBlob mblob = (MailboxBlob) obj;\n                    try {\n                        sm.delete(mblob);\n                    } catch (IOException e) {\n                        ZimbraLog.mailbox.warn(\"could not delete blob \" + mblob.getPath() + \" during rollback\");\n                    }\n                } else if (obj instanceof Blob) {\n                    Blob blob = (Blob) obj;\n                    try {\n                        sm.delete(blob);\n                    } catch (IOException e) {\n                        ZimbraLog.mailbox.warn(\"could not delete blob \" + blob.getPath() + \" during rollback\");\n                    }\n                } else if (obj instanceof String && obj != null) {\n                    mConvHashes.remove(obj);\n                }\n            }\n        } catch (RuntimeException e) {\n            ZimbraLog.mailbox.error(\"ignoring error during cache rollback\", e);\n        } finally {\n            // keep our MailItem cache at a reasonable size\n            trimItemCache();\n            // toss any pending changes to the Mailbox object and get ready for the next change\n            change.reset();\n        }\n    }\n\n    private void trimItemCache() {\n        try {\n            int sizeTarget = mListeners.isEmpty() ? MAX_ITEM_CACHE_WITHOUT_LISTENERS : MAX_ITEM_CACHE_WITH_LISTENERS;\n            Map cache = mCurrentChange.itemCache;\n            if (cache == null)\n                return;\n            int excess = cache.size() - sizeTarget;\n            if (excess < 0)\n                return;\n            // cache the overflow to avoid the Iterator's ConcurrentModificationException\n            Object[] overflow = new Object[excess];\n            int i = 0;\n            for (Iterator it = cache.values().iterator(); i < excess && it.hasNext(); ) {\n                Object obj = it.next();\n                if (obj instanceof MailItem)\n                    overflow[i++] = obj;\n                else\n                    it.remove();\n            }\n            // trim the excess; note that \"uncache\" can cascade and take out child items\n            while (--i >= 0) {\n                if (cache.size() <= sizeTarget)\n                    return;\n                if (overflow[i] instanceof MailItem)\n                    try {\n                        uncache((MailItem) overflow[i]);\n                    } catch (ServiceException e) { }\n            }\n        } catch (RuntimeException e) {\n            ZimbraLog.mailbox.error(\"ignoring error during item cache trim\", e);\n        }\n    }\n\n    public boolean attachmentsIndexingEnabled() throws ServiceException {\n        return getAccount().getBooleanAttr(Provisioning.A_zimbraAttachmentsIndexingEnabled, true);\n    }\n\n    private void logCacheActivity(Integer key, byte type, MailItem item) {\n        // The global item cache counter always gets updated\n        if (!isCachedType(type)) {\n            ZimbraPerf.COUNTER_MBOX_ITEM_CACHE.increment(item == null ? 0 : 100);\n        }\n\n        // the per-access log only gets updated when cache or perf debug logging is on\n        if (!ZimbraLog.cache.isDebugEnabled())\n            return;\n\n        if (item == null) {\n            ZimbraLog.cache.debug(\"Cache miss for item \" + key + \" in mailbox \" + getId());\n            return;\n        }\n\n        // Don't log cache hits for folders, search folders and tags.  We always\n        // keep these in memory, so cache hits are not interesting.\n        if (isCachedType(type))\n            return;\n        ZimbraLog.cache.debug(\"Cache hit for \" + MailItem.getNameForType(type) + \" \" + key + \" in mailbox \" + getId());\n    }\n\n    private static final String CN_ID         = \"id\";\n    private static final String CN_ACCOUNT_ID = \"account_id\";\n    private static final String CN_NEXT_ID    = \"next_item_id\";\n    private static final String CN_SIZE       = \"size\";\n\n    @Override public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"mailbox: {\");\n        sb.append(CN_ID).append(\": \").append(mId).append(\", \");\n        sb.append(CN_ACCOUNT_ID).append(\": \").append(mData.accountId).append(\", \");\n        sb.append(CN_NEXT_ID).append(\": \").append(mData.lastItemId).append(\", \");\n        sb.append(CN_SIZE).append(\": \").append(mData.size);\n        sb.append(\"}\");\n        return sb.toString();\n    }\n}\n",
    "vulnerability_type": "Path Traversal",
    "repo": "zm-mailbox",
    "commit": "722012c30f7ea999894907047cbe262225b55d0b",
    "commit_msg": "(split)bug: 28633\n\nSome prerequisites for writing a reminder fixup tool:\n\n* REST import of ics used to preserve existing alarms when updating existing appointments.  The default has been changed to use the alarms specified in the ics being imported.  This is a more intuitive default anyway.\n\n* Added \"preserveAlarms\" URL query string parameter for REST ics import.  When this argument is set (e.g. http://.../Calendar?fmt=ics&preserveAlarms=1) we're back to the old behavior of preserving existing alarms.  If it's unset, use alarm definitions from ics file.\n\n* zmmailbox postRestURL command gets --preserveAlarms option to match the query string parameter.\n\n* zmmailbox getRestURL command gets --startTime and --endTime options, corresponding to \"start\" and \"end\" arguments on REST URL interface, so the REST export via zmmailbox can limit the date range.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=28633\n\nCopied from Perforce\n Change: 101069",
    "original_file": "Mailbox.java",
    "confidence_score": 1.0
  },
  {
    "serial_no": 21,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n *\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007 Zimbra, Inc.\n *\n * The contents of this file are subject to the Yahoo! Public License\n * Version 1.0 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n *\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.taglib.bean;\n\nimport com.zimbra.common.calendar.TZIDMapper;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.soap.VoiceConstants;\nimport com.zimbra.cs.taglib.ZJspSession;\nimport com.zimbra.cs.zclient.ZAppointmentHit;\nimport com.zimbra.cs.zclient.ZEmailAddress;\nimport com.zimbra.cs.zclient.ZFilterAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZDiscardAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZFileIntoAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZKeepAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZMarkAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZRedirectAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZStopAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZTagAction;\nimport com.zimbra.cs.zclient.ZFilterCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZAddressBookCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZAttachmentExistsCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZBodyCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZDateCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZHeaderCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZHeaderExistsCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZSizeCondition;\nimport com.zimbra.cs.zclient.ZFolder;\nimport com.zimbra.cs.zclient.ZFolder.Color;\nimport com.zimbra.cs.zclient.ZFolder.View;\nimport com.zimbra.cs.zclient.ZInvite;\nimport com.zimbra.cs.zclient.ZInvite.ZAttendee;\nimport com.zimbra.cs.zclient.ZInvite.ZComponent;\nimport com.zimbra.cs.zclient.ZInvite.ZWeekDay;\nimport com.zimbra.cs.zclient.ZMailbox;\nimport com.zimbra.cs.zclient.ZShare;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence.ZSimpleRecurrenceType;\nimport com.zimbra.cs.zclient.ZTag;\nimport com.zimbra.cs.zclient.ZSearchParams;\nimport com.zimbra.cs.zclient.ZPhone;\nimport com.zimbra.cs.zclient.ZPhoneAccount;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport javax.servlet.jsp.PageContext;\nimport javax.servlet.jsp.jstl.fmt.LocaleSupport;\nimport javax.servlet.http.HttpServletRequest;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class BeanUtils {\n\n    private static void addAddr(StringBuilder sb, ZEmailAddress email, int size) {\n        if (email == null) return;\n        if (sb.length() > 0) sb.append(\", \");\n        if (size > 1 && email.getDisplay() != null)\n            sb.append(email.getDisplay());\n        else if (email.getPersonal() != null)\n            sb.append(email.getPersonal());\n        else if (email.getAddress() != null)\n            sb.append(email.getAddress());\n    }\n\n    public static String getAddrs(List<ZEmailAddress> addrs) {\n        if ( addrs == null) return null;\n        int len = addrs.size();\n        StringBuilder sb = new StringBuilder();\n        for (ZEmailAddress addr: addrs) {\n            addAddr(sb, addr, len);\n        }\n        String result = sb.toString();\n        return result.length() == 0 ? null : result;\n    }\n\n    public static String joinLines(String lines, String sep) {\n        StringBuilder result = new StringBuilder();\n        for (String line : lines.split(\"(?m)\\\\n\")) {\n            if (line.length() > 0) {\n                if (result.length() > 0) result.append(sep);\n                result.append(line);\n            }\n        }\n        return result.toString();\n    }\n\n    public static String getHeaderAddrs(List<ZEmailAddress> addrs, String type) {\n        if ( addrs == null) return null;\n        StringBuilder sb = new StringBuilder();\n        for (ZEmailAddress addr: addrs) {\n            if (type != null && addr.getType().equals(type)) {\n                if (sb.length() > 0) sb.append(\", \");\n                String p = addr.getPersonal();\n                boolean useP = p!= null && p.length() > 0;\n                if (useP) sb.append(p);\n                String a = addr.getAddress();\n                if (a != null && a.length() > 0) {\n                    if (useP) sb.append(\" <\");\n                    sb.append(a);\n                    if (useP) sb.append('>');\n                }\n            }\n        }\n        String result = sb.toString();\n        return result.length() == 0 ? null : result;\n    }\n\n    public static String getAddr(ZEmailAddress addr) {\n        String result;\n        if ( addr == null) return null;\n        else if (addr.getPersonal() != null)\n            result = addr.getPersonal();\n        else if (addr.getAddress() != null)\n            result = addr.getAddress();\n        else\n            return null;\n        return result.length() == 0 ? null : result;\n    }\n\n    private static String escapeDollarSign(String value) {\n        if (value == null || value.length() == 0 || value.indexOf('$') == -1)\n            return value;\n        return value.replace(\"$\", \"\\\\$\");\n    }\n\n    public static void main(String args[]) {\n        System.out.println(escapeDollarSign(\"hello world\"));\n        System.out.println(escapeDollarSign(\"hello$world\"));\n        System.out.println(escapeDollarSign(\"hello$4\"));\n    }\n\n    private static String replaceAll(String text, Pattern pattern, String replace) {\n        Matcher m = pattern.matcher(text);\n        StringBuffer sb = null;\n        replace = escapeDollarSign(replace);\n        while (m.find()) {\n            if (sb == null) sb = new StringBuffer();\n            m.appendReplacement(sb, replace);\n        }\n        if (sb != null) m.appendTail(sb);\n        return sb == null ? text : sb.toString();\n    }\n\n    private static final Pattern sAMP = Pattern.compile(\"&\", Pattern.MULTILINE);\n    private static final Pattern sTWO_SPACES = Pattern.compile(\"  \", Pattern.MULTILINE);\n    private static final Pattern sLEADING_SPACE = Pattern.compile(\"^ \", Pattern.MULTILINE);\n    private static final Pattern sTAB = Pattern.compile(\"\\\\t\", Pattern.MULTILINE);\n    private static final Pattern sLT = Pattern.compile(\"<\", Pattern.MULTILINE);\n    private static final Pattern sGT = Pattern.compile(\">\", Pattern.MULTILINE);\n    private static final Pattern sDBLQT = Pattern.compile(\"\\\"\", Pattern.MULTILINE);\n    private static final Pattern sNL = Pattern.compile(\"\\\\r?\\\\n\", Pattern.MULTILINE);\n    private static final Pattern sSTART = Pattern.compile(\"^\", Pattern.MULTILINE);\n    private static final Pattern sURL = Pattern.compile(\n            \"((telnet:)|((https?|ftp|gopher|news|file):\\\\/\\\\/)|(www\\\\.[\\\\w\\\\.\\\\_\\\\-]+))[^\\\\s\\\\xA0\\\\(\\\\)\\\\<\\\\>\\\\[\\\\]\\\\{\\\\}\\'\\\"]*\",\n            Pattern.MULTILINE);\n\n    public static String prefixContent(String content, String prefix) {\n        if (content == null || prefix == null) return \"\";\n        return replaceAll(content, sSTART, prefix);\n    }\n\n    public static String htmlEncode(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        return s;\n    }\n\n    public static String encodeHtmlAttr(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        s = replaceAll(s, sDBLQT, \"&quot;\");\n        return s;\n    }\n\n    private static String internalTextToHtml(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sTWO_SPACES, \" &nbsp;\");\n        s = replaceAll(s, sLEADING_SPACE, \"&nbsp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        s = replaceAll(s, sTAB, \"<pre style='display:inline;'>\\t</pre>\");\n        s = replaceAll(s, sNL, \"<br />\");\n        return s;\n    }\n\n    public static String textToHtml(String text) {\n        if (text == null) return null;\n        Matcher m = sURL.matcher(text);\n        StringBuilder sb = new StringBuilder();\n        int lastIndex = 0; // lastIndex we copied from\n        while (m.find()) {\n            //if (sb == null) sb = new StringBuilder();\n            if (m.start() > lastIndex) {\n                sb.append(internalTextToHtml(text.substring(lastIndex, m.start())));\n            }\n            String url = m.group();\n            char last = url.charAt(url.length()-1);\n            if (last == '.' || last == '!' || last == ',')\n                url = url.substring(0, url.length()-1);\n\n            sb.append(\"<a class='zUrl' target='_blank' href='\");\n            if (url.length() > 4 && url.substring(0,4).startsWith(\"www.\")) sb.append(\"http://\");\n            sb.append(url);\n            sb.append(\"'>\");\n            sb.append(htmlEncode(url));\n            sb.append(\"</a>\");\n            lastIndex = m.start()+url.length();\n        }\n        if (lastIndex < text.length()) {\n            sb.append(internalTextToHtml(text.substring(lastIndex)));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * truncat given text at length, then walk back until you hit a whitespace.\n     *\n     * @param text text to truncate\n     * @param length length to truncate too\n     * @param ellipses whether or not to add ellipses\n     * @return truncated string\n     */\n    public static String truncate(String text, int length, boolean ellipses) {\n        if (text.length() < length) return text;\n        if (length <= 0) return ellipses ? \"...\" : \"\";\n        int n = Math.min(length, text.length());\n        for (int i=n-1; i > 0; i--) {\n            if (Character.isWhitespace(text.charAt(i))) {\n                return text.substring(0, i)+(ellipses ? \" ...\" : \"\");\n            }\n        }\n        return text.subSequence(0, length)+(ellipses ? \" ...\" : \"\");\n    }\n\n    public static String displaySize(long size) {\n        return displaySize(size, 0);\n    }\n\n    public static String displaySize(long size, int fractions) {\n        String units;\n        double dsize;\n        if (size >= 1073741824) {\n            dsize = size/1073741824.0;\n            units = \" GB\";\n        } else if (size >= 1048576) {\n            dsize = size/1048576.0;\n            units = \" MB\";\n        } else if (size >= 1024) {\n            dsize = size/1024.0;\n            units = \" KB\";\n        } else {\n            dsize = size;\n            units = \" B\";\n        }\n\n        if (fractions == 0) {\n            return Math.round(dsize) + units;\n        } else {\n            String str = String.format(\"%.\"+fractions+\"f\", dsize);\n            int p = str.length()-1;\n            if (fractions > 0 && str.charAt(p) == '0') {\n                while (str.charAt(p) == '0' && p > 0) p--;\n                if (str.charAt(p) == '.') p--;\n                str = str.substring(0, p+1);\n            }\n            return str + units;\n        }\n    }\n\n    public static String displaySizePercent(long size, long max) {\n        String formt = \" \";\n        double dsize;\n        dsize = (size*100)/(double)max;\n        dsize = Math.round(dsize);\n        return dsize + formt;\n    }\n\n    private enum DateTimeFmt { DTF_TIME_SHORT, DTF_DATE_MEDIUM, DTF_DATE_SHORT }\n\n    private static DateFormat getDateFormat(PageContext pc, DateTimeFmt fmt) {\n        DateFormat df = (DateFormat) pc.getAttribute(fmt.name(), PageContext.REQUEST_SCOPE);\n        if (df == null) {\n            switch (fmt) {\n            case DTF_DATE_MEDIUM:\n                df = new SimpleDateFormat(LocaleSupport.getLocalizedMessage(pc, \"ZM_formatDateMediumNoYear\"));\n                break;\n            case DTF_TIME_SHORT:\n                df = DateFormat.getTimeInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n                break;\n            case DTF_DATE_SHORT:\n            default:\n                df = DateFormat.getDateInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n                break;\n            }\n            pc.setAttribute(fmt.name(), df, PageContext.REQUEST_SCOPE);\n        }\n        return df;\n    }\n\n    public static String displayMsgDate(PageContext pc, Date msg) throws ServiceException, JspException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        TimeZone tz = mbox.getPrefs().getTimeZone();\n        Calendar cal = Calendar.getInstance(tz);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n\n        long nowTime = cal.getTimeInMillis();\n        long msgTime = msg.getTime();\n\n        if (msgTime >= nowTime) {\n            // show hour and return\n            DateFormat df = getDateFormat(pc, DateTimeFmt.DTF_TIME_SHORT);\n            df.setTimeZone(tz);\n            return df.format(msg);\n        }\n\n        long nowYear = cal.get(Calendar.YEAR);\n        cal.setTimeInMillis(msgTime);\n        long msgYear = cal.get(Calendar.YEAR);\n\n        if (nowYear == msgYear) {\n            DateFormat df = getDateFormat(pc, DateTimeFmt.DTF_DATE_MEDIUM);\n            df.setTimeZone(tz);\n            return df.format(msg);\n        } else {\n            DateFormat df = getDateFormat(pc, DateTimeFmt.DTF_DATE_SHORT);\n            df.setTimeZone(tz);\n            return df.format(msg);\n        }\n    }\n\n    public static String displayDuration(PageContext pc, long duration) throws ServiceException, JspException {\n        long totalSeconds = duration / 1000;\n        long seconds = totalSeconds % 60;\n        long minutes = (totalSeconds - seconds) / 60;\n        if (minutes > 0) {\n            return LocaleSupport.getLocalizedMessage(pc, \"durationDisplayMinutes\", new Object[]{minutes, seconds});\n        } else {\n            return LocaleSupport.getLocalizedMessage(pc, \"durationDisplaySeconds\", new Object[]{seconds});\n        }\n    }\n\n    public static String getAttr(PageContext pc, String attr) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        List<String> val = mbox.getAccountInfo(false).getAttrs().get(attr);\n        return (val.size() > 0) ? val.get(0) : null;\n    }\n\n    public static String repeatString(String string, int count) {\n        if (count==0) return \"\";\n        StringBuilder sb = new StringBuilder(string.length()*count);\n        while(count-- > 0) sb.append(string);\n        return sb.toString();\n    }\n\n    private static final Pattern sCOMMA = Pattern.compile(\",\");\n\n    private static  boolean inList(String id, String[] list) {\n        for (String s : list) if (s.equals(id)) return true;\n        return false;\n    }\n\n    // todo: add some per-requeset caching?\n    public static List<ZTagBean> getAvailableTags(PageContext pc, String idList, boolean excludeList) throws JspException {\n        try {\n            String[] ids = (idList == null || idList.length() == 0) ? new String[0] : sCOMMA.split(idList);\n            List<ZTagBean> tags = new ArrayList<ZTagBean>();\n\n            if (!excludeList && ids.length == 0)\n                return tags;\n\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            List<ZTag> allTags = mbox.getAllTags();\n\n            for (ZTag tag : allTags) {\n                if (excludeList) {\n                    if (!inList(tag.getId(), ids))\n                        tags.add(new ZTagBean(tag));\n                } else {\n                    if (inList(tag.getId(), ids))\n                        tags.add(new ZTagBean(tag));\n                }\n            }\n            return tags;\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    // todo: add some per-requeset caching?\n    public static List<ZTagBean> getTags(PageContext pc, String idList) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (idList == null || idList.length() == 0) return null;\n            String[] ids = sCOMMA.split(idList);\n            List<ZTagBean> tags = new ArrayList<ZTagBean>(ids.length);\n            for (String id: ids) {\n                ZTag tag = mbox.getTagById(id);\n                if (tag != null) tags.add(new ZTagBean(tag));\n            }\n            return tags;\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n\n    }\n\n    // todo: add some per-request caching?\n    public static String getTagNames(PageContext pc, String idList) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (idList == null || idList.length() == 0) return null;\n            String[] ids = sCOMMA.split(idList);\n            StringBuilder sb = new StringBuilder();\n            for (String id: ids) {\n                ZTag tag = mbox.getTagById(id);\n                if (tag != null) {\n                    if (sb.length() > 0) sb.append(',');\n                    sb.append(tag.getName());\n                }\n            }\n            return sb.toString();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getTagName(PageContext pc, String id) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (id == null) return null;\n            ZTag tag = mbox.getTagById(id);\n            return tag == null ? null : tag.getName();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getServerName(PageContext pc) {\n        return  ((HttpServletRequest) pc.getRequest()).getServerName();\n    }\n    public static ZTagBean getTag(PageContext pc, String id) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (id == null) return null;\n            ZTag tag = mbox.getTagById(id);\n            return tag == null ? null : new ZTagBean(tag);\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n\n    public static ZFolderBean getFolder(PageContext pc, String id) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        if (id == null) return null;\n        ZFolder f = mbox.getFolderById(id);\n        return f == null ? null : new ZFolderBean(f);\n    }\n\n    public static String getFolderName(PageContext pc, String id) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        if (id == null) return null;\n        ZFolder f = mbox.getFolderById(id);\n        if (f == null) return null;\n        String lname = LocaleSupport.getLocalizedMessage(pc, \"FOLDER_LABEL_\"+f.getId());\n        return (lname == null || lname.startsWith(\"???\")) ? f.getName() : lname;\n    }\n\n    private static long sUrlRandSalt = 0;\n\n    /**\n     *\n     * @return some random string for a URL to add to deal with caching. random value returned is not secure!\n     */\n    public static String getUrlRand() {\n        return (System.currentTimeMillis() - 1167421101179L) + \".\" + sUrlRandSalt++;\n    }\n\n\n    private static Context sEnvCtxt = null;\n\n    static {\n         try {\n            Context sInitCtxt = new InitialContext();\n            sEnvCtxt = (Context) sInitCtxt.lookup(\"java:comp/env\");\n        } catch (NamingException e) {\n             /* ignore */\n        }\n    }\n\n    public static String getEnvString(String key, String defaultValue) {\n        try {\n            String value = sEnvCtxt == null ? defaultValue : (String) sEnvCtxt.lookup(key);\n            return value == null ? defaultValue : value;\n        } catch (NamingException e) {\n            return defaultValue;\n        }\n    }\n\n    public static boolean isAddressBook(ZFilterCondition condition) {\n        return condition instanceof ZAddressBookCondition;\n    }\n\n    public static ZAddressBookCondition getAddressBook(ZFilterCondition condition) {\n        return isAddressBook(condition) ? (ZAddressBookCondition) condition : null;\n    }\n\n    public static boolean isBody(ZFilterCondition condition) {\n        return condition instanceof ZBodyCondition;\n    }\n\n    public static ZBodyCondition getBody(ZFilterCondition condition) {\n        return isBody(condition) ? (ZBodyCondition) condition : null;\n    }\n\n    public static boolean isSize(ZFilterCondition condition) {\n        return condition instanceof ZSizeCondition;\n    }\n\n    public static ZSizeCondition getSize(ZFilterCondition condition) {\n        return isSize(condition) ? (ZSizeCondition) condition : null;\n    }\n\n    public static boolean isDate(ZFilterCondition condition) {\n        return condition instanceof ZDateCondition;\n    }\n\n    public static ZDateCondition getDate(ZFilterCondition condition) {\n        return isDate(condition) ? (ZDateCondition) condition : null;\n    }\n\n    public static boolean isHeader(ZFilterCondition condition) {\n        return condition instanceof ZHeaderCondition;\n    }\n\n    public static ZHeaderCondition getHeader(ZFilterCondition condition) {\n        return isHeader(condition) ? (ZHeaderCondition) condition : null;\n    }\n\n    public static boolean isHeaderExists(ZFilterCondition condition) {\n        return condition instanceof ZHeaderExistsCondition;\n    }\n\n    public static ZHeaderExistsCondition getHeaderExists(ZFilterCondition condition) {\n        return isHeaderExists(condition) ? (ZHeaderExistsCondition) condition : null;\n    }\n\n    public static boolean isAttachmentExists(ZFilterCondition condition) {\n        return condition instanceof ZAttachmentExistsCondition;\n    }\n\n    public static ZAttachmentExistsCondition getAttachmentExists(ZFilterCondition condition) {\n        return isAttachmentExists(condition) ? (ZAttachmentExistsCondition) condition : null;\n    }\n\n    public static boolean isKeep(ZFilterAction action) {\n        return action instanceof ZKeepAction;\n    }\n\n    public static boolean isDiscard(ZFilterAction action) {\n        return action instanceof ZDiscardAction;\n    }\n\n    public static boolean isStop(ZFilterAction action) {\n        return action instanceof ZStopAction;\n    }\n\n    public static boolean isFileInto(ZFilterAction action) {\n        return action instanceof ZFileIntoAction;\n    }\n\n    public static ZFileIntoAction getFileInto(ZFilterAction action) {\n        return isFileInto(action) ? (ZFileIntoAction) action : null;\n    }\n\n    public static boolean isTag(ZFilterAction action) {\n        return action instanceof ZTagAction;\n    }\n\n    public static ZTagAction getTag(ZFilterAction action) {\n        return isTag(action) ? (ZTagAction) action : null;\n    }\n\n    public static boolean isFlag(ZFilterAction action) {\n        return action instanceof ZMarkAction;\n    }\n\n    public static ZMarkAction getFlag(ZFilterAction action) {\n        return isFlag(action) ? (ZMarkAction) action : null;\n    }\n\n    public static boolean isRedirect(ZFilterAction action) {\n        return action instanceof ZRedirectAction;\n    }\n\n    public static ZRedirectAction getRedirect(ZFilterAction action) {\n        return isRedirect(action) ? (ZRedirectAction) action : null;\n    }\n\n    public static Calendar getCalendarMidnight(long time, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(time);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getCalendar(long time, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(time);\n        return cal;\n    }\n\n    public static Calendar getToday(TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(System.currentTimeMillis());\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getTodayHour(int hour, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(System.currentTimeMillis());\n        cal.set(Calendar.HOUR_OF_DAY, hour);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getFirstDayOfMonthView(java.util.Calendar date, long prefFirstDayOfWeek) {\n         prefFirstDayOfWeek++; // pref goes 0-6, Calendar goes 1-7\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         cal.set(Calendar.DAY_OF_MONTH, 1);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n         if (dow == prefFirstDayOfWeek) {\n             cal.add(Calendar.DAY_OF_MONTH, -7);\n         } else {\n             cal.add(Calendar.DAY_OF_MONTH, - ((dow+(7-((int)prefFirstDayOfWeek)))%7));\n         }\n         return cal;\n     }\n\n    public static Calendar getFirstDayOfMultiDayView(java.util.Calendar date, long prefFirstDayOfWeek, String view) {\n\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n\n        // pref goes 0-6, Calendar goes 1-7\n        if (\"workWeek\".equalsIgnoreCase(view)) {\n                if (dow == Calendar.SUNDAY)\n                    cal.add(Calendar.DAY_OF_MONTH, 1);\n                else if (dow != Calendar.MONDAY)\n                    cal.add(Calendar.DAY_OF_MONTH, - (dow - Calendar.MONDAY));\n        } else if (\"week\".equalsIgnoreCase(view)) {\n                if (dow != prefFirstDayOfWeek)\n                    cal.add(Calendar.DAY_OF_MONTH, - (((dow-1) + (7- (int)prefFirstDayOfWeek)) % 7));\n        }\n         return cal;\n     }\n\n    public static void getNextDay(Calendar cal) {\n        cal.add(Calendar.DAY_OF_MONTH, 1);\n    }\n\n    public static void setDayOfWeek(Calendar cal, int dow) {\n        cal.set(Calendar.DAY_OF_WEEK, dow);\n    }\n\n    public static void setMonth(Calendar cal, int month) {\n        cal.set(Calendar.MONTH, month);\n    }\n\n    public static Calendar addDay(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.DAY_OF_MONTH, incr);\n        return other;\n    }\n\n    public static Calendar addMonth(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.MONTH, incr);\n        return other;\n    }\n\n    public static Calendar addYear(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.YEAR, incr);\n        return other;\n    }\n\n    public static Calendar relativeDay(Calendar cal, int offset) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.DAY_OF_MONTH, offset);\n        return other;\n    }\n\n    public static boolean isSameDate(Calendar day1, Calendar day2) {\n        return day1.get(Calendar.YEAR) ==  day2.get(Calendar.YEAR) &&\n                day1.get(Calendar.MONTH) ==  day2.get(Calendar.MONTH) &&\n                day1.get(Calendar.DAY_OF_MONTH) ==  day2.get(Calendar.DAY_OF_MONTH);\n    }\n\n    public static boolean isSameMonth(Calendar day1, Calendar day2) {\n        return day1.get(Calendar.YEAR) ==  day2.get(Calendar.YEAR) &&\n                day1.get(Calendar.MONTH) ==  day2.get(Calendar.MONTH);\n\n    }\n\n    public static int getYear(Calendar cal) { return cal.get(Calendar.YEAR); }\n    public static int getMonth(Calendar cal) { return cal.get(Calendar.MONTH); }\n    public static int getDay(Calendar cal) { return cal.get(Calendar.DAY_OF_MONTH); }\n    public static int getDayOfWeek(Calendar cal) { return cal.get(Calendar.DAY_OF_WEEK); }\n\n\n    public static String getCheckedCalendarFolderIds(ZMailboxBean mailbox) throws ServiceException {\n        StringBuilder sb = new StringBuilder();\n        getCheckedCalendarFoldersRecursive(mailbox.getMailbox().getUserRoot(), sb);\n        return sb.toString();\n    }\n\n    private static void getCheckedCalendarFoldersRecursive(ZFolder f, StringBuilder sb) {\n        if (f.getDefaultView() == View.appointment && f.isCheckedInUI()) {\n            if (sb.length() > 0) sb.append(',');\n            sb.append(f.getId());\n        }\n        for (ZFolder child : f.getSubFolders()) {\n            getCheckedCalendarFoldersRecursive(child, sb);\n        }\n    }\n\n    public static boolean hasAnyAppointments(ZApptSummariesBean summary, long start, long end) {\n        for (ZAppointmentHit appt : summary.getAppointments()) {\n            if (appt.isInRange(start, end)) return true;\n        }\n        return false;\n    }\n\n    private static final long MSECS_PER_MINUTE = 1000*60;\n    private static final long MSECS_PER_HOUR = MSECS_PER_MINUTE * 60;\n\n    public static long MSECS_PER_MINUTE() { return MSECS_PER_MINUTE; }\n    public static long MSECS_PER_HOUR() { return MSECS_PER_HOUR; }\n\n    public static String getWindowsId(TimeZone tz) {\n        return TZIDMapper.toWindows(tz.getID());\n    }\n\n    public static String getCanonicalTimeZoneId(String id) {\n        return TZIDMapper.canonicalize(id);\n    }\n\n    public static TimeZone getTimeZone(String id) {\n        id = TZIDMapper.toJava(id);\n        return id == null ? TimeZone.getDefault() : TimeZone.getTimeZone(id);\n    }\n\n    public static String getFolderStyleColor(String color, String view) throws ServiceException {\n        return ZFolderBean.getStyleColor(Color.fromString(color), View.fromString(view));\n    }\n\n    public static boolean actionSet(Map param, String action) {\n        return param.containsKey(action) || param.containsKey(action+\".x\");\n    }\n\n    public static boolean isSameTimeZone(String tz1, String tz2) {\n        return (tz1 == null || tz2 == null) ? tz1 == tz2 :\n                TZIDMapper.canonicalize(tz1).equals(TZIDMapper.canonicalize(tz2));\n    }\n\n    public static ZAttendee getMyAttendee(ZInvite invite, ZMailboxBean mailbox) throws ServiceException {\n        ZComponent comp = invite.getComponent();\n        List<ZAttendee> attendees = comp.getAttendees();\n        if (attendees != null) {\n            Set<String> myAddrs = mailbox.getAccountInfo().getEmailAddresses();\n            for (ZAttendee attendee : attendees) {\n                if (myAddrs.contains(attendee.getAddress()) || myAddrs.contains(attendee.getUrl()))\n                    return attendee;\n            }\n        }\n        return null;\n    }\n\n    public static String getRepeatBlurb(ZSimpleRecurrence repeat, PageContext pc, TimeZone timeZone, Date startDate) {\n        String r = \"\";\n        Calendar cal;\n\n        if (repeat == null || repeat.getType() == null) {\n            return LocaleSupport.getLocalizedMessage(pc, \"recurNone\");\n        }\n\n        switch (repeat.getType()) {\n            case NONE:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurNone\");\n                break;\n            case DAILY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurDailyEveryDay\");\n                break;\n            case DAILY_WEEKDAY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurDailyEveryWeekday\");\n                break;\n            case DAILY_INTERVAL:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurDailyEveryNumDays\", new Object[] {repeat.getDailyInterval()});\n                break;\n            case WEEKLY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurDailyEveryWeek\");\n                break;\n            case WEEKLY_BY_DAY:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getWeeklyByDay().ordinal()+1);\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurWeeklyEveryWeekday\", new Object[] {cal.getTime()});\n                break;\n            case WEEKLY_CUSTOM:\n                StringBuilder wc = new StringBuilder();\n                cal = getToday(timeZone);\n                wc.append(LocaleSupport.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeks\", new Object[] {repeat.getWeeklyInterval()}));\n                wc.append(\" \");\n                int wci = 1, wcmax = repeat.getWeeklyIntervalDays().size();\n                for (ZWeekDay day : repeat.getWeeklyIntervalDays()) {\n                    if (wci != 1 && wci != wcmax) wc.append(LocaleSupport.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksSep\")).append(\" \");\n                    if (wci != 1 && wci == wcmax) wc.append(\" \").append(LocaleSupport.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksLastSep\")).append(\" \");\n                    setDayOfWeek(cal, day.getOrdinal()+1);\n                    wc.append(LocaleSupport.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksDay\", new Object[] {cal.getTime()}));\n                    wci++;\n                }\n                r = wc.toString();\n                break;\n            case MONTHLY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurMonthly\");\n                break;\n            case MONTHLY_BY_MONTH_DAY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurMonthlyEveryNumMonthsDate\",\n                        new Object[] {repeat.getMonthlyMonthDay(), repeat.getMonthlyInterval()});\n                break;\n            case MONTHLY_RELATIVE:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getMonthlyRelativeDay().getDay().getOrdinal()+1);\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurMonthlyEveryNumMonthsNumDay\",\n                        new Object[] {\n                                repeat.getMonthlyRelativeDay().getWeekOrd(),\n                                cal.getTime(),\n                                repeat.getMonthlyInterval()\n                        });\n                break;\n            case YEARLY:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurYearly\");\n                break;\n            case YEARLY_BY_DATE:\n                cal = getToday(timeZone);\n                setMonth(cal, repeat.getYearlyByDateMonth()-1);\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurYearlyEveryDate\",\n                        new Object[] { cal.getTime(), repeat.getYearlyByDateMonthDay()});\n                break;\n            case YEARLY_RELATIVE:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getYearlyRelativeDay().getDay().getOrdinal()+1);\n                setMonth(cal, repeat.getYearlyRelativeMonth()-1);\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurYearlyEveryMonthNumDay\",\n                        new Object[] {\n                                repeat.getYearlyRelativeDay().getWeekOrd(),\n                                cal.getTime(),\n                                cal.getTime()\n                        });\n                break;\n            default:\n                r = LocaleSupport.getLocalizedMessage(pc, \"recurComplex\");\n                break;\n        }\n\n        if (repeat.getType() == ZSimpleRecurrenceType.NONE)\n            return r;\n\n        String e = \"\";\n\n        switch (repeat.getEnd()) {\n            case NEVER:\n                e = LocaleSupport.getLocalizedMessage(pc, \"recurEndNone\");\n                break;\n            case COUNT:\n                e = LocaleSupport.getLocalizedMessage(pc, \"recurEndNumber\", new Object[] {repeat.getCount()});\n                break;\n            case UNTIL:\n                DateFormat untilDf = DateFormat.getDateInstance(DateFormat.MEDIUM, pc.getRequest().getLocale());\n                if (timeZone != null) untilDf.setTimeZone(timeZone);\n                String untilDate = untilDf.format(repeat.getUntilDate().getDate());\n                e = LocaleSupport.getLocalizedMessage(pc, \"recurEndByDate\", new Object[] { untilDate});\n                break;\n        }\n\n        String s = \"\";\n        if (startDate != null) {\n            DateFormat startDf = DateFormat.getDateInstance(DateFormat.MEDIUM, pc.getRequest().getLocale());\n            if (timeZone != null) startDf.setTimeZone(timeZone);\n            s = LocaleSupport.getLocalizedMessage(pc, \"recurStart\", new Object[] { startDf.format(startDate)});\n\n        }\n\n        return LocaleSupport.getLocalizedMessage(pc, \"repeatBlurb\", new Object[] { r, e, s});\n    }\n\n    public static String getApptDateBlurb(PageContext pc, TimeZone timeZone, long startTime, long endTime, boolean allDay) {\n        Calendar startCal = getCalendar(startTime, timeZone);\n        Calendar endCal = getCalendar(endTime, timeZone);\n\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL, pc.getRequest().getLocale());\n        DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n        \n        if (timeZone != null) {\n            df.setTimeZone(timeZone);\n            tf.setTimeZone(timeZone);\n        }\n\n        boolean sameDate = isSameDate(startCal, endCal);\n\n        if (allDay && sameDate) {\n                return LocaleSupport.getLocalizedMessage(pc, \"apptDateBlurbAllDay\",\n                        new Object[] {df.format(startCal.getTime())});\n        } else if (allDay) {\n                return LocaleSupport.getLocalizedMessage(pc, \"apptDateBlurbAllDayDiffEndDay\",\n                        new Object[] {df.format(startCal.getTime()), df.format(endCal.getTime())});\n        } else if (sameDate) {\n                return LocaleSupport.getLocalizedMessage(pc, \"apptDateBlurb\",\n                        new Object[] {\n                                df.format(startCal.getTime()),\n                                tf.format(startCal.getTime()),\n                                tf.format(endCal.getTime())\n                        });\n        } else {\n                return LocaleSupport.getLocalizedMessage(pc, \"apptDateBlurbDiffEndDay\",\n                        new Object[] {\n                                df.format(startCal.getTime()),\n                                tf.format(startCal.getTime()),\n                                df.format(endCal.getTime()),\n                                tf.format(endCal.getTime())\n                        });\n        }\n    }\n\n    public static void clearMessageCache(ZMailboxBean mailbox) {\n        mailbox.getMailbox().clearMessageCache();\n    }\n\n    public static boolean hasShareMountPoint(ZMailboxBean mailbox, ZMessageBean message) {\n        ZShare share = message.getShare();\n        if (share == null) return false;\n\n        try {\n            ZFolder folder = mailbox.getMailbox().getFolderById(share.getGrantor().getId()+\":\"+share.getLink().getId());\n            return folder != null;\n        } catch (ServiceException e) {\n            return false;\n        }\n    }\n\n    public static String jsEncode(String str) {\n        return StringUtil.jsEncode(str);\n\t}\n\n    public static String getFolderRestURL(ZMailboxBean mailbox, ZFolderBean folder) throws JspTagException {\n        try {\n            return mailbox.getRestURI(folder.getRootRelativePath()).toString();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getVoiceFolderType(ZFolderBean folder) {\n        String name = folder.getName();\n        if (VoiceConstants.FNAME_PLACEDCALLS.equals(name) ||\n            VoiceConstants.FNAME_ANSWEREDCALLS.equals(name) ||\n            VoiceConstants.FNAME_MISSEDCALLS.equals(name)) {\n            return ZSearchParams.TYPE_CALL; \n        }\n        return ZSearchParams.TYPE_VOICE_MAIL;\n    }\n\n    public static String getVoiceFolderQuery(ZFolderBean folder) {\n        String id = folder.getId();\n        String phone = id.substring(id.indexOf('-') + 1);\n        String name = folder.getName();\n        return \"phone:\" + phone + \" \" + \"in:\\\"\" + name + \"\\\"\";\n    }\n\n    public static String getVoiceFolderName(PageContext pc, ZFolderBean folder) {\n        String name = folder.getName();\n        String key = null;\n        if (VoiceConstants.FNAME_PLACEDCALLS.equals(name)) {\n            key = \"placedCalls\";\n        } else if (VoiceConstants.FNAME_ANSWEREDCALLS.equals(name)) {\n            key = \"answeredCalls\";\n        } else if (VoiceConstants.FNAME_MISSEDCALLS.equals(name)) {\n            key = \"missedCalls\";\n        } else if (VoiceConstants.FNAME_VOICEMAILINBOX.equals(name)) {\n            key = \"voiceMail\";\n        } else if (VoiceConstants.FNAME_TRASH.equals(name)) {\n            key = \"trash\";\n        }\n        return key != null ? LocaleSupport.getLocalizedMessage(pc, key) : name;\n    }\n\n    public static String getPhoneDisplay(String name) {\n        return ZPhone.getDisplay(name);\n    }\n\n    public static String getPhoneFromVoiceQuery(String query) {\n        // Guess the phone name from query. If I knew better how to pass\n        // information around all these jsps, I wouldn't need to guess....\n        // TODO:\n        String phone = \"phone:\";\n        int match = query.indexOf(phone);\n        if (match != -1) {\n            int startIndex = match + phone.length();\n            int endIndex = query.indexOf(' ', startIndex);\n            if (endIndex == -1) {\n                endIndex = query.length();\n            }\n            return query.substring(startIndex, endIndex);\n        }\n        return \"\";\n    }\n\n    public static ZVoiceMailItemHitBean[] deserializeVoiceMailItemHits(String[] values, String phone) throws ServiceException {\n        if (values == null) {\n            return new ZVoiceMailItemHitBean[0]; \n        }\n        ZVoiceMailItemHitBean[] result = new ZVoiceMailItemHitBean[values.length];\n        for (int i = 0, count = values.length; i < count; i++) {\n            result[i] = ZVoiceMailItemHitBean.deserialize(values[i], phone);\n        }\n        return result;\n    }\n\n    public static String deserializeVoiceMailItemIds(String[] values, String phone) throws ServiceException {\n        if (values == null) {\n            return \"\"; \n        }\n        StringBuilder builder = new StringBuilder(128);\n        for (String value : values) {\n            if (builder.length() > 0) {\n                builder.append(',');\n            }\n            ZVoiceMailItemHitBean bean = ZVoiceMailItemHitBean.deserialize(value, phone);\n            builder.append(bean.getId());\n        }\n        return builder.toString();\n    }\n\n\tpublic static ZPhoneAccountBean getFirstPhoneAccount(PageContext pc) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tList<ZPhoneAccount> accounts = mbox.getAllPhoneAccounts();\n\t\treturn accounts.size() > 0 ? new ZPhoneAccountBean(accounts.get(0)) : null;\n\t}\n\n\tpublic static boolean getIsMyCard(PageContext pc, String ids) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\treturn mbox.getIsMyCard(ids);\n\t}\n\t\n\t/*\n\t * Start Yahoo! code\n\t */\n\tpublic static Calendar getYFirstDayOfMonthView(java.util.Calendar date, long prefFirstDayOfWeek) {\n         prefFirstDayOfWeek++; // pref goes 0-6, Calendar goes 1-7\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         cal.set(Calendar.DAY_OF_MONTH, 1);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n         if (dow != prefFirstDayOfWeek) {\n\t\t\tcal.add(Calendar.DAY_OF_MONTH, - ((dow+(7-((int)prefFirstDayOfWeek)))%7));\n         }\n         return cal;\n    }\n\t\n\tpublic static int getNumberOfWeeksOfMonth(java.util.Calendar date) {\n        Calendar cal = (Calendar)date.clone();\n        return cal.getActualMaximum(Calendar.WEEK_OF_MONTH);\n    }\n\n    /* End Yahoo! code */\n\n\tpublic static String getImagePath(PageContext pc, String relativePath) {\n\t\tfinal String ZIMBRA_IMAGE_SERVERS = \"zimbraImageServers\";\n\t\tString[] servers = (String[]) pc.getAttribute(ZIMBRA_IMAGE_SERVERS, PageContext.APPLICATION_SCOPE);\n\t\tif (servers == null) {\n\t\t\tString serverList = pc.getServletContext().getInitParameter(ZIMBRA_IMAGE_SERVERS);\n\t\t\tservers = (serverList == null || serverList.length() == 0) ? new String[0] : sCOMMA.split(serverList);\n\t\t\tfor (int i = 0, count = servers.length; i < count; i++) {\n\t\t\t\tservers[i] = servers[i].trim();\n\t\t\t}\n\t\t\tpc.setAttribute(ZIMBRA_IMAGE_SERVERS, servers, PageContext.APPLICATION_SCOPE);\n\t\t}\n\t\tif (servers.length > 0) {\n\t\t\t// Generate the url for the image. Path starts with \"//\" to pick up current protocol.\n\t\t\t// The use of hashCode just ensures that for any given image, the same server is always used.  \n\t\t\tint index = Math.abs(relativePath.hashCode()) % servers.length;\n\t\t\treturn \"//\" + servers[index] + \":\" +  pc.getRequest().getServerPort() + relativePath;\n\t\t} else {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t/**\n\t * \"Cooks\" the input string. (Removes special characters that can used to create xss attacks.)\n\t */\n\tpublic static String cook(String in) {\n\t\tif (in == null || in.length() == 0) {\n\t\t\treturn in;\n\t\t}\n\t\tStringBuilder result = new StringBuilder(in.length());\n\t\tfor (int i = 0; i < in.length(); i++) {\n\t\t\tchar c = in.charAt(i);\n\t\t\tswitch (c) {\n\t\t\t\tcase '<' : result.append(\"&lt;\"); break;\n\t\t\t\tcase '>' : result.append(\"&gt;\"); break;\n\t\t\t\tcase '&' : result.append(\"&amp;\"); break;\n\t\t\t\tcase '\\\"' : result.append(\"&quot;\"); break;\n\t\t\t\tcase '\\'' : result.append(\"&#039;\"); break;\n\t\t\t\tcase 0x0a : // Follow through...\n\t\t\t\tcase 0x0d : result.append(\" \"); break;\n\t\t\t\tdefault: result.append(c); break;\n\t\t\t}\n\t\t}\n\t\treturn result.toString();\n\t}\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-taglib",
    "commit": "bedb9171e08fa3400cb84f4e2504aa5ec1cda237",
    "commit_msg": "Bug: 22859\nxss problems in skin resources\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=22859\n\nCopied from Perforce\n Change: 78064",
    "original_file": "BeanUtils.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 22,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.taglib.bean;\n\nimport com.zimbra.common.calendar.TZIDMapper;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.HttpUtil;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.soap.VoiceConstants;\nimport com.zimbra.common.mailbox.ContactConstants;\nimport com.zimbra.common.mime.shim.JavaMailInternetAddress;\nimport com.zimbra.cs.service.util.ItemId;\nimport com.zimbra.cs.taglib.ZJspSession;\nimport com.zimbra.cs.zclient.ZFilterAction.ZDiscardAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZFileIntoAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZKeepAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZMarkAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZRedirectAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZStopAction;\nimport com.zimbra.cs.zclient.ZFilterAction.ZTagAction;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZAddressBookCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZAttachmentExistsCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZBodyCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZDateCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZHeaderCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZHeaderExistsCondition;\nimport com.zimbra.cs.zclient.ZFilterCondition.ZSizeCondition;\nimport com.zimbra.cs.zclient.ZFolder.Color;\nimport com.zimbra.cs.zclient.ZFolder.View;\nimport com.zimbra.cs.zclient.ZInvite.ZAttendee;\nimport com.zimbra.cs.zclient.ZInvite.ZComponent;\nimport com.zimbra.cs.zclient.ZInvite.ZWeekDay;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence.ZSimpleRecurrenceType;\nimport com.zimbra.cs.zclient.*;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport javax.servlet.ServletException;\nimport javax.servlet.jsp.JspException;\nimport javax.servlet.jsp.JspTagException;\nimport javax.servlet.jsp.PageContext;\nimport com.zimbra.cs.taglib.tag.i18n.I18nUtil;\nimport com.zimbra.cs.account.Account;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.mailbox.Contact;\nimport com.yahoo.platform.yui.compressor.JavaScriptCompressor;\nimport com.yahoo.platform.yui.compressor.CssCompressor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.AddressException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.text.DateFormatSymbols;\nimport java.text.NumberFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.io.StringReader;\nimport java.io.StringWriter;\n\nimport org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.EvaluatorException;\n\npublic class BeanUtils {\n\n    private static void addAddr(StringBuilder sb, ZEmailAddress email, int size) {\n        if (email == null) return;\n        if (sb.length() > 0) sb.append(\", \");\n        if (size > 1 && email.getDisplay() != null)\n            sb.append(email.getDisplay());\n        else if (email.getPersonal() != null)\n            sb.append(email.getPersonal());\n        else if (email.getAddress() != null)\n            sb.append(email.getAddress());\n    }\n\n    public static String getAddrs(List<ZEmailAddress> addrs) {\n        if ( addrs == null) return null;\n        int len = addrs.size();\n        StringBuilder sb = new StringBuilder();\n        for (ZEmailAddress addr: addrs) {\n            addAddr(sb, addr, len);\n        }\n        String result = sb.toString();\n        return result.length() == 0 ? null : result;\n    }\n\n    public static String joinLines(String lines, String sep) {\n        StringBuilder result = new StringBuilder();\n        for (String line : lines.split(\"(?m)\\\\n\")) {\n            if (line.length() > 0) {\n                if (result.length() > 0) result.append(sep);\n                result.append(line);\n            }\n        }\n        return result.toString();\n    }\n\n    public static String replaceAll(String org, String find, String replace) {\n        if(org != null && find != null && replace != null){\n            org = org.replaceAll(find,replace);\n        }\n        return org;\n    }\n\n\n    public static String getHeaderAddrs(List<ZEmailAddress> addrs, String type) {\n        if ( addrs == null) return null;\n        StringBuilder sb = new StringBuilder();\n        for (ZEmailAddress addr: addrs) {\n            if (type != null && addr.getType().equals(type)) {\n                if (sb.length() > 0) sb.append(\", \");\n                String p = addr.getPersonal();\n                boolean useP = p!= null && p.length() > 0;\n                if (useP) sb.append(p);\n                String a = addr.getAddress();\n                if (a != null && a.length() > 0) {\n                    if (useP) sb.append(\" <\");\n                    sb.append(a);\n                    if (useP) sb.append('>');\n                }\n            }\n        }\n        String result = sb.toString();\n        return result.length() == 0 ? null : result;\n    }\n\n    public static String getAddr(ZEmailAddress addr) {\n        String result;\n        if ( addr == null) return null;\n        else if (addr.getPersonal() != null)\n            result = addr.getPersonal();\n        else if (addr.getAddress() != null)\n            result = addr.getAddress();\n        else\n            return null;\n        return result.length() == 0 ? null : result;\n    }\n\n    public static DateFormatSymbols\n            getDateFormatSymbols(java.util.Locale userLocale, PageContext pc){\n        DateFormatSymbols dfs = new ExtendedDateFormatSymbols(userLocale,pc);\n        return dfs;\n    }\n    \n    private static String escapeDollarSign(String value) {\n        if (value == null || value.length() == 0 || value.indexOf('$') == -1)\n            return value;\n        return value.replace(\"$\", \"\\\\$\");\n    }\n\n    public static void main(String args[]) {\n        System.out.println(escapeDollarSign(\"hello world\"));\n        System.out.println(escapeDollarSign(\"hello$world\"));\n        System.out.println(escapeDollarSign(\"hello$4\"));\n    }\n\n    private static String replaceAll(String text, Pattern pattern, String replace) {\n        Matcher m = pattern.matcher(text);\n        StringBuffer sb = null;\n        replace = escapeDollarSign(replace);\n        while (m.find()) {\n            if (sb == null) sb = new StringBuffer();\n            m.appendReplacement(sb, replace);\n        }\n        if (sb != null) m.appendTail(sb);\n        return sb == null ? text : sb.toString();\n    }\n\n    private static final Pattern sAMP = Pattern.compile(\"&\", Pattern.MULTILINE);\n    private static final Pattern sTWO_SPACES = Pattern.compile(\"  \", Pattern.MULTILINE);\n    private static final Pattern sLEADING_SPACE = Pattern.compile(\"^ \", Pattern.MULTILINE);\n    private static final Pattern sTAB = Pattern.compile(\"\\\\t\", Pattern.MULTILINE);\n    private static final Pattern sLT = Pattern.compile(\"<\", Pattern.MULTILINE);\n    private static final Pattern sGT = Pattern.compile(\">\", Pattern.MULTILINE);\n    private static final Pattern sDBLQT = Pattern.compile(\"\\\"\", Pattern.MULTILINE);\n    private static final Pattern sNL = Pattern.compile(\"\\\\r?\\\\n\", Pattern.MULTILINE);\n    private static final Pattern sSTART = Pattern.compile(\"^\", Pattern.MULTILINE);\n    private static final Pattern sURL = Pattern.compile(\n            \"((telnet:)|((https?|ftp|gopher|news|file):\\\\/\\\\/)|(www\\\\.[\\\\w\\\\.\\\\_\\\\-]+))[^\\\\s\\\\xA0\\\\(\\\\)\\\\<\\\\>\\\\[\\\\]\\\\{\\\\}\\'\\\"]*\",\n            Pattern.MULTILINE);\n    private static final Pattern sHTMLDECODE = Pattern.compile(\"\\\\<.*?\\\\>\", Pattern.MULTILINE);\n\n    public static String prefixContent(String content, String prefix) {\n        if (content == null || prefix == null) return \"\";\n        return replaceAll(content, sSTART, prefix);\n    }\n\n    public static String htmlEncode(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        return s;\n    }\n\n    public static String htmlNewlineEncode(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        return text.replaceAll(\"\\n\",\"<br>\");\n    }\n\n    public static String htmlDecode(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, \"<br>\", \"\\n\");\n        s = replaceAll(s, sHTMLDECODE, \"\");\n        s = replaceAll(s, \"&amp;\", \"&\");\n        s = replaceAll(s, \"&nbsp;\", \" \");\n        s = replaceAll(s,\"&lt;\",\"<\");\n        s = replaceAll(s,\"&gt;\",\">\");\n        s = replaceAll(s,\"&quot;\",\"\\\"\");\n        return s;\n    }\n\n    public static String encodeHtmlAttr(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        s = replaceAll(s, sDBLQT, \"&quot;\");\n        return s;\n    }\n\n    public static String htmlRubyEncode(String base, String text) {\n        if (base != null && base.length() > 0 && text != null && text.length() > 0) {\n            StringBuilder str = new StringBuilder();\n            str.append(\"<ruby><rb>\");\n            str.append(htmlEncode(base));\n            str.append(\"</rb><rp>(</rp><rt>\");\n            str.append(htmlEncode(text));\n            str.append(\"</rt><rp>)</rp></ruby>\");\n            return str.toString();\n        }\n        String s = base != null && base.length() > 0 ? base :\n                  (text != null && text.length() > 0 ? text : \"\");\n        return htmlEncode(s);\n    }\n\n    private static String internalTextToHtml(String text) {\n        if (text == null || text.length() == 0) return \"\";\n        String s = replaceAll(text, sAMP, \"&amp;\");\n        s = replaceAll(s, sTWO_SPACES, \" &nbsp;\");\n        s = replaceAll(s, sLEADING_SPACE, \"&nbsp;\");\n        s = replaceAll(s, sLT, \"&lt;\");\n        s = replaceAll(s, sGT, \"&gt;\");\n        s = replaceAll(s, sTAB, \"<pre style='display:inline;'>\\t</pre>\");\n        s = replaceAll(s, sNL, \"<br />\");\n        return s;\n    }\n\n    public static String textToHtml(String text) {\n        if (text == null) return null;\n        Matcher m = sURL.matcher(text);\n        StringBuilder sb = new StringBuilder();\n        int lastIndex = 0; // lastIndex we copied from\n        while (m.find()) {\n            //if (sb == null) sb = new StringBuilder();\n            if (m.start() > lastIndex) {\n                sb.append(internalTextToHtml(text.substring(lastIndex, m.start())));\n            }\n            String url = m.group();\n            char last = url.charAt(url.length()-1);\n            if (last == '.' || last == '!' || last == ',')\n                url = url.substring(0, url.length()-1);\n\n            sb.append(\"<a class='zUrl' target='_blank' href='\");\n            if (url.length() > 4 && url.substring(0,4).startsWith(\"www.\")) sb.append(\"http://\");\n            sb.append(url);\n            sb.append(\"'>\");\n            sb.append(htmlEncode(url));\n            sb.append(\"</a>\");\n            lastIndex = m.start()+url.length();\n        }\n        if (lastIndex < text.length()) {\n            sb.append(internalTextToHtml(text.substring(lastIndex)));\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Remove HTML comments but do not remove the comments under style/script tags.\n     *\n     * @param html message body\n     * @return message body after removing HTML comments, if any\n     */\n    public static String stripHtmlComments(String html) {\n        String REGEX = \"<(?:!(?:--[\\\\s\\\\S]*?--\\\\s*)?(>)\\\\s*|(?:script|style|SCRIPT|STYLE)[\\\\s\\\\S]*?<\\\\/(?:script|style|SCRIPT|STYLE)>)\";\n        Pattern p = Pattern.compile(REGEX);\n\n        Matcher m = p.matcher(html); // get a matcher object\n        StringBuffer sb = new StringBuffer();\n        while(m.find()) {\n            if(m.group(1) != null)\n                m.appendReplacement(sb, \" \");\n            else {\n                // Use quoteReplacement() to escape the replacement text so that '$' and '/', if present\n                // in the replacement text, does not hold any special meaning.\n                m.appendReplacement(sb, Matcher.quoteReplacement(m.group()));\n            }\n        }\n        m.appendTail(sb);\n        return sb.toString();\n    }\n\n    /**\n     * truncat given text at length, then walk back until you hit a whitespace.\n     *\n     * @param text text to truncate\n     * @param length length to truncate too\n     * @param ellipses whether or not to add ellipses\n     * @return truncated string\n     */\n    public static String truncate(String text, int length, boolean ellipses) {\n        if (text.length() < length) return text;\n        if (length <= 0) return ellipses ? \"...\" : \"\";\n        int n = Math.min(length, text.length());\n        for (int i=n-1; i > 0; i--) {\n            if (Character.isWhitespace(text.charAt(i))) {\n                return text.substring(0, i)+(ellipses ? \" ...\" : \"\");\n            }\n        }\n        return text.subSequence(0, length)+(ellipses ? \" ...\" : \"\");\n    }\n\n    public static String truncateFixed(String text, int length, boolean ellipses) {\n        if (length <= 0) return ellipses ? \"...\" : \"\";\n\n        if (text.length() <= length) {\n            return text;\n        }                                                          \n        else {\n            String filler = (ellipses ? \"...\" : \"\");\n            return text.subSequence(0,length/2)+filler+text.subSequence((text.length() - length/2 + filler.length()),text.length()) ;\n        }\n    }\n\n    public static String displaySize(PageContext pc, long size) {\n        return displaySize(pc, size, 0);\n    }\n\n    public static String displaySize(PageContext pc, long size, int fractions) {\n        String units;\n        double dsize;\n        if (size >= 1073741824) {\n            dsize = size/1073741824.0;\n            if(pc == null){\n                units = \"GB\";\n            }else{\n                units = I18nUtil.getLocalizedMessage(pc, \"gb\");// \" GB\";\n            }\n\n        } else if (size >= 1048576) {\n            dsize = size/1048576.0;\n            if(pc == null){\n                units = \"MB\";\n            }else{\n                units = I18nUtil.getLocalizedMessage(pc, \"mb\");//\" MB\";\n            }\n        } else if (size >= 1024) {\n            dsize = size/1024.0;\n            if(pc == null){\n                units = \"KB\";\n            }else{\n                units = I18nUtil.getLocalizedMessage(pc, \"kb\");//\" KB\";\n            }\n        } else {\n            dsize = size;\n            if(pc == null){\n                units = \"b\";\n            }else{\n                units = I18nUtil.getLocalizedMessage(pc, \"b\");//\" B\";\n            }\n        }\n\n        Locale locale = I18nUtil.getLocale(\"en_US\"); // Default US, in case pc is null\n        if(pc != null){\n                locale = I18nUtil.findLocale(pc);\n        }\n        NumberFormat formatter = NumberFormat.getNumberInstance(locale);        \n        String str = dsize+\"\";\n        if (fractions == 0) {\n            str = formatter.format(Math.round(dsize));\n        } else {\n            formatter.setMaximumFractionDigits(fractions);\n            str = formatter.format(dsize);\n        }\n        return str + \" \" + units;\n    }\n\n    public static String displaySizePercent(long size, long max) {\n        String formt = \"%\";\n        double dsize;\n        dsize = (size*100)/(double)max;\n        return Math.round(dsize) + formt;\n    }\n\n    private enum DateTimeFmt { DTF_TIME_SHORT, DTF_DATE_MEDIUM, DTF_DATE_SHORT }\n\n    private static DateFormat getDateFormat(PageContext pc, DateTimeFmt fmt) {\n        DateFormat df = (DateFormat) pc.getAttribute(fmt.name(), PageContext.REQUEST_SCOPE);\n        if (df == null) {\n            switch (fmt) {\n            case DTF_DATE_MEDIUM:\n                df = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, \"ZM_formatDateMediumNoYear\"));\n                break;\n            case DTF_TIME_SHORT:\n                df = DateFormat.getTimeInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n                break;\n            case DTF_DATE_SHORT:\n            default:\n                df = DateFormat.getDateInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n                break;\n            }\n            pc.setAttribute(fmt.name(), df, PageContext.REQUEST_SCOPE);\n        }\n        return df;\n    }\n\n    public static String displayMsgDate(PageContext pc, Date msg) throws ServiceException, JspException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        TimeZone tz = mbox.getPrefs().getTimeZone();\n        Calendar cal = Calendar.getInstance(tz);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n\n        long nowTime = cal.getTimeInMillis();\n        long msgTime = msg.getTime();\n\n        if (msgTime >= nowTime) {\n            // show hour and return\n            DateFormat df = getDateFormat(pc, DateTimeFmt.DTF_TIME_SHORT);\n            df.setTimeZone(tz);\n            return df.format(msg);\n        }\n\n        long nowYear = cal.get(Calendar.YEAR);\n        cal.setTimeInMillis(msgTime);\n        long msgYear = cal.get(Calendar.YEAR);\n\n        Locale locale = I18nUtil.findLocale(pc);\n        if (nowYear == msgYear) {\n            DateFormat df = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, \"ZM_formatDateMediumNoYear\"),locale);\n            df.setTimeZone(tz);\n            return df.format(msg);\n        } else {\n\t\t\treturn displayDate(pc, msg, tz);\n        }\n    }\n\n\tpublic static String displayDate(PageContext pc, Date msg) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tTimeZone tz = mbox.getPrefs().getTimeZone();\n\t\treturn displayDate(pc, msg, tz);\n\t}\n\n\tprivate static String displayDate(PageContext pc, Date msg, TimeZone tz) {\n\t\tDateFormat df = getDateFormat(pc, DateTimeFmt.DTF_DATE_SHORT);\n\t\tdf.setTimeZone(tz);\n\t\treturn df.format(msg);\n\t}\n\n\tpublic static String displayDuration(PageContext pc, long duration) throws ServiceException, JspException {\n        long totalSeconds = duration / 1000;\n        long seconds = totalSeconds % 60;\n        long minutes = (totalSeconds - seconds) / 60;\n        if (minutes > 0) {\n            return I18nUtil.getLocalizedMessage(pc, \"durationDisplayMinutes\", new Object[]{minutes, seconds});\n        } else {\n            return I18nUtil.getLocalizedMessage(pc, \"durationDisplaySeconds\", new Object[]{seconds});\n        }\n    }\n\n\tpublic static String displayVoiceDate(PageContext pc, Date msg) throws ServiceException, JspException {\n\t\tfinal int ONE_DAY = 24 * 3600000;\n\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tTimeZone tz = mbox.getPrefs().getTimeZone();\n\t\tCalendar nowCal = Calendar.getInstance(tz);\n\t\tCalendar msgCal = Calendar.getInstance(tz);\n\n\t\tlong nowTime = nowCal.getTimeInMillis();\n\t\tmsgCal.setTime(msg);\n\t\tlong msgTime = msgCal.getTimeInMillis();\n\n\t\tCalendar yesterdayCal = Calendar.getInstance(tz);\n\t\tyesterdayCal.setTimeInMillis(nowTime - ONE_DAY);\n\n\t\tint nowDay = nowCal.get(Calendar.DAY_OF_MONTH);\n\t\tint nowYesterday = yesterdayCal.get(Calendar.DAY_OF_MONTH);\n\t\tint msgDay = msgCal.get(Calendar.DAY_OF_MONTH);\n\n\t\tString resource;\n\t\tif (nowTime - msgTime < ONE_DAY && nowDay == msgDay) {\n\t\t\tresource = \"ZM_formatVoiceDateToday\";\n\t\t} else if ((nowTime - msgTime) < (2 * ONE_DAY) && nowYesterday == msgDay) {\n\t\t\tresource = \"ZM_formatVoiceDateYesterday\";\n\t\t} else {\n\t\t\tresource = \"ZM_formatVoiceDate\";\n\t\t}\n\n\t\tDateFormat df = (DateFormat) pc.getAttribute(resource, PageContext.REQUEST_SCOPE);\n\t\tif (df == null) {\n\t\t\tdf = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, resource));\n\t\t\tpc.setAttribute(resource, df, PageContext.REQUEST_SCOPE);\n\t\t}\n\t\tdf.setTimeZone(tz);\n\t\treturn df.format(msgCal.getTime());\n\t}\n\n    public static String getAttr(PageContext pc, String attr) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        List<String> val = mbox.getAccountInfo(false).getAttrs().get(attr);\n        return (val.size() > 0) ? val.get(0) : null;\n    }\n\n   /**\n    * Checks for a provisioned attribute or a user account/COS attribute. If either is true this\n    * method will return true\n    */\n   public static boolean isProvOrAttr(PageContext pc, String attr) throws JspException, ServiceException {\n       Provisioning prov = Provisioning.getInstance();\n       return prov.getConfig().getBooleanAttr(attr, false) || Provisioning.TRUE.equals(getAttr(pc, attr));\n   }\n\n    public static String getMailURL(PageContext pc) {\n        try {\n            return Provisioning.getInstance().getLocalServer().getMailURL();\n        } catch (ServiceException e) {\n            return \"/zimbra\";\n        }\n    }\n\n    public static String repeatString(String string, int count) {\n        if (count==0) return \"\";\n        StringBuilder sb = new StringBuilder(string.length()*count);\n        while(count-- > 0) sb.append(string);\n        return sb.toString();\n    }\n\n    private static final Pattern sCOMMA = Pattern.compile(\",\");\n\n    private static  boolean inList(String id, String[] list) {\n        for (String s : list) if (s.equals(id)) return true;\n        return false;\n    }\n\n    // todo: add some per-requeset caching?\n    public static List<ZTagBean> getAvailableTags(PageContext pc, String idList, boolean excludeList) throws JspException {\n        try {\n            String[] ids = (idList == null || idList.length() == 0) ? new String[0] : sCOMMA.split(idList);\n            List<ZTagBean> tags = new ArrayList<ZTagBean>();\n\n            if (!excludeList && ids.length == 0)\n                return tags;\n\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            List<ZTag> allTags = mbox.getAllTags();\n\n            for (ZTag tag : allTags) {\n                if (excludeList) {\n                    if (!inList(tag.getId(), ids))\n                        tags.add(new ZTagBean(tag));\n                } else {\n                    if (inList(tag.getId(), ids))\n                        tags.add(new ZTagBean(tag));\n                }\n            }\n            return tags;\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    // todo: add some per-requeset caching?\n    public static List<ZTagBean> getTags(PageContext pc, String idList) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (idList == null || idList.length() == 0) return null;\n            String[] ids = sCOMMA.split(idList);\n            List<ZTagBean> tags = new ArrayList<ZTagBean>(ids.length);\n            for (String id: ids) {\n                ZTag tag = mbox.getTagById(id);\n                if (tag != null) tags.add(new ZTagBean(tag));\n            }\n            return tags;\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n\n    }\n\n    // todo: add some per-request caching?\n    public static String getTagNames(PageContext pc, String idList) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (idList == null || idList.length() == 0) return null;\n            String[] ids = sCOMMA.split(idList);\n            StringBuilder sb = new StringBuilder();\n            for (String id: ids) {\n                ZTag tag = mbox.getTagById(id);\n                if (tag != null) {\n                    if (sb.length() > 0) sb.append(',');\n                    sb.append(tag.getName());\n                }\n            }\n            return sb.toString();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getTagName(PageContext pc, String id) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (id == null) return null;\n            ZTag tag = mbox.getTagById(id);\n            return tag == null ? null : tag.getName();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getServerName(PageContext pc) {\n\t\tString serverName = pc.getRequest().getParameter(\"customerDomain\");\n        return serverName != null ? serverName.trim() : HttpUtil.getVirtualHost((HttpServletRequest) pc.getRequest());\n    }\n    \n    public static ZTagBean getTag(PageContext pc, String id) throws JspException {\n        try {\n            ZMailbox mbox = ZJspSession.getZMailbox(pc);\n            if (id == null) return null;\n            ZTag tag = mbox.getTagById(id);\n            return tag == null ? null : new ZTagBean(tag);\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String maskRemoteItemId(ZMailboxBean mailbox, String folderId, String id) throws JspException, ServiceException {\n        return mailbox.getMailbox().maskRemoteItemId(folderId, id);\n    }\n\n    public static String unmaskRemoteItemId(ZMailboxBean mailbox, String id) throws JspException, ServiceException {\n        return mailbox.getMailbox().unmaskRemoteItemId(id);\n    }\n\n    public static ZFolderBean getFolder(PageContext pc, String id) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        if (id == null) return null;\n        ZFolder f = mbox.getFolderById(id);\n        if (f == null) {\n            try {\n                ZGetInfoResult acctInfo = mbox.getAccountInfo(false);\n                String acctId = acctInfo.getId();\n                ItemId itemId = new ItemId(id, acctId);\n                if (!itemId.belongsTo(acctId)) {\n                    mbox = ZJspSession.getRestMailbox(pc, ZJspSession.getAuthToken(pc), itemId.getAccountId());\n                    if (mbox != null) {\n                        f = mbox.getFolderById(id);\n                    }\n                }\n            } catch (ServiceException se) {\n                //it's for some other acct, not a child we have permission for\n                f = null;\n            }\n        }        \n        return f == null ? null : new ZFolderBean(f);\n    }\n\n    public static String getFolderName(PageContext pc, String id) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        if (id == null) return null;\n        ZFolder f = mbox.getFolderById(id);\n        if (f == null) return null;\n        String lname = I18nUtil.getLocalizedMessage(pc, \"FOLDER_LABEL_\"+f.getId());\n        return (lname == null || lname.startsWith(\"???\")) ? f.getName() : lname;\n    }\n\n\tprivate static void getFolderPath(PageContext pc, ZFolder folder, StringBuilder builder) throws JspException, ServiceException {\n\t\tZFolder parent = folder.getParent();\n\t\tif (parent != null && !ZFolder.ID_USER_ROOT.equals(parent.getId())) {\n\t\t\tgetFolderPath(pc, parent, builder);\n\t\t\tbuilder.append(ZMailbox.PATH_SEPARATOR);\n\t\t}\n\t\tbuilder.append(getFolderName(pc, folder.getId()));\n\t}\n\t\n\tpublic static String getFolderPath(PageContext pc, String id) throws JspException, ServiceException {\n        ZMailbox mbox = ZJspSession.getZMailbox(pc);\n        if (id == null) return null;\n        ZFolder f = mbox.getFolderById(id);\n        if (f == null) return null;\n\t\tStringBuilder builder = new StringBuilder(256);\n\t\tgetFolderPath(pc, f, builder);\n\t\treturn BeanUtils.cook(builder.toString());\n    }\n\n    private static long sUrlRandSalt = 0;\n\n    /**\n     *\n     * @return some random string for a URL to add to deal with caching. random value returned is not secure!\n     */\n    public static String getUrlRand() {\n        return (System.currentTimeMillis() - 1167421101179L) + \".\" + sUrlRandSalt++;\n    }\n\n\n    private static Context sEnvCtxt = null;\n\n    static {\n         try {\n            Context sInitCtxt = new InitialContext();\n            sEnvCtxt = (Context) sInitCtxt.lookup(\"java:comp/env\");\n        } catch (NamingException e) {\n             /* ignore */\n        }\n    }\n\n    public static String getEnvString(String key, String defaultValue) {\n        try {\n            String value = sEnvCtxt == null ? defaultValue : (String) sEnvCtxt.lookup(key);\n            return value == null ? defaultValue : value;\n        } catch (NamingException e) {\n            return defaultValue;\n        }\n    }\n\n    public static boolean isAddressBook(ZFilterCondition condition) {\n        return condition instanceof ZAddressBookCondition;\n    }\n\n    public static ZAddressBookCondition getAddressBook(ZFilterCondition condition) {\n        return isAddressBook(condition) ? (ZAddressBookCondition) condition : null;\n    }\n\n    public static boolean isBody(ZFilterCondition condition) {\n        return condition instanceof ZBodyCondition;\n    }\n\n    public static ZBodyCondition getBody(ZFilterCondition condition) {\n        return isBody(condition) ? (ZBodyCondition) condition : null;\n    }\n\n    public static boolean isSize(ZFilterCondition condition) {\n        return condition instanceof ZSizeCondition;\n    }\n\n    public static ZSizeCondition getSize(ZFilterCondition condition) {\n        return isSize(condition) ? (ZSizeCondition) condition : null;\n    }\n\n    public static boolean isDate(ZFilterCondition condition) {\n        return condition instanceof ZDateCondition;\n    }\n\n    public static ZDateCondition getDate(ZFilterCondition condition) {\n        return isDate(condition) ? (ZDateCondition) condition : null;\n    }\n\n    public static boolean isHeader(ZFilterCondition condition) {\n        return condition instanceof ZHeaderCondition;\n    }\n\n    public static ZHeaderCondition getHeader(ZFilterCondition condition) {\n        return isHeader(condition) ? (ZHeaderCondition) condition : null;\n    }\n\n    public static boolean isHeaderExists(ZFilterCondition condition) {\n        return condition instanceof ZHeaderExistsCondition;\n    }\n\n    public static ZHeaderExistsCondition getHeaderExists(ZFilterCondition condition) {\n        return isHeaderExists(condition) ? (ZHeaderExistsCondition) condition : null;\n    }\n\n    public static boolean isAttachmentExists(ZFilterCondition condition) {\n        return condition instanceof ZAttachmentExistsCondition;\n    }\n\n    public static ZAttachmentExistsCondition getAttachmentExists(ZFilterCondition condition) {\n        return isAttachmentExists(condition) ? (ZAttachmentExistsCondition) condition : null;\n    }\n\n    /**\n     * Returns true if the specified object is an array or Collection.\n\t */\n    public static boolean isCollection(Object obj) {\n        return ((obj instanceof Object[]) || (obj instanceof Collection));\n    }\n\n    public static boolean isKeep(ZFilterAction action) {\n        return action instanceof ZKeepAction;\n    }\n\n    public static boolean isDiscard(ZFilterAction action) {\n        return action instanceof ZDiscardAction;\n    }\n\n    public static boolean isStop(ZFilterAction action) {\n        return action instanceof ZStopAction;\n    }\n\n    public static boolean isFileInto(ZFilterAction action) {\n        return action instanceof ZFileIntoAction;\n    }\n\n    public static ZFileIntoAction getFileInto(ZFilterAction action) {\n        return isFileInto(action) ? (ZFileIntoAction) action : null;\n    }\n\n    public static boolean isTag(ZFilterAction action) {\n        return action instanceof ZTagAction;\n    }\n\n    public static ZTagAction getTag(ZFilterAction action) {\n        return isTag(action) ? (ZTagAction) action : null;\n    }\n\n    public static boolean isFlag(ZFilterAction action) {\n        return action instanceof ZMarkAction;\n    }\n\n    public static ZMarkAction getFlag(ZFilterAction action) {\n        return isFlag(action) ? (ZMarkAction) action : null;\n    }\n\n    public static boolean isRedirect(ZFilterAction action) {\n        return action instanceof ZRedirectAction;\n    }\n\n    public static ZRedirectAction getRedirect(ZFilterAction action) {\n        return isRedirect(action) ? (ZRedirectAction) action : null;\n    }\n\n    public static Calendar getCalendarMidnight(long time, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(time);\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getCalendar(long time, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(time);\n        return cal;\n    }\n\n    public static Calendar getToday(TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(System.currentTimeMillis());\n        cal.set(Calendar.HOUR_OF_DAY, 0);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getTodayHour(int hour, TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(System.currentTimeMillis());\n        cal.set(Calendar.HOUR_OF_DAY, hour);\n        cal.set(Calendar.MINUTE, 0);\n        cal.set(Calendar.SECOND, 0);\n        cal.set(Calendar.MILLISECOND, 0);\n        return cal;\n    }\n\n    public static Calendar getCurrentTime(TimeZone tz) {\n        Calendar cal = tz == null ? Calendar.getInstance() : Calendar.getInstance(tz);\n        cal.setTimeInMillis(System.currentTimeMillis());\n        return cal;\n    }\n\n    public static Calendar getFirstDayOfMonthView(java.util.Calendar date, long prefFirstDayOfWeek) {\n         prefFirstDayOfWeek++; // pref goes 0-6, Calendar goes 1-7\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         cal.set(Calendar.DAY_OF_MONTH, 1);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n         if (dow == prefFirstDayOfWeek) {\n             cal.add(Calendar.DAY_OF_MONTH, -7);\n         } else {\n             cal.add(Calendar.DAY_OF_MONTH, - ((dow+(7-((int)prefFirstDayOfWeek)))%7));\n         }\n         return cal;\n     }\n\n    public static Calendar getFirstDayOfMultiDayView(java.util.Calendar date, long prefFirstDayOfWeek, String view) {\n\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n\n        // pref goes 0-6, Calendar goes 1-7\n        if (\"workWeek\".equalsIgnoreCase(view)) {\n                if (dow == Calendar.SUNDAY)\n                    cal.add(Calendar.DAY_OF_MONTH, 1);\n                else if (dow != Calendar.MONDAY)\n                    cal.add(Calendar.DAY_OF_MONTH, - (dow - Calendar.MONDAY));\n        } else if (\"week\".equalsIgnoreCase(view)) {\n                if (dow != prefFirstDayOfWeek)\n                    cal.add(Calendar.DAY_OF_MONTH, - (((dow-1) + (7- (int)prefFirstDayOfWeek)) % 7));\n        }\n        return cal;\n    }\n\n    public static Calendar getCurrentDay(java.util.Calendar date) {\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n\n         return cal;\n    }\n\n    public static void getNextDay(Calendar cal) {\n        cal.add(Calendar.DAY_OF_MONTH, 1);\n    }\n\n    public static void setDayOfWeek(Calendar cal, int dow) {\n        cal.set(Calendar.DAY_OF_WEEK, dow);\n    }\n\n    public static void setMonth(Calendar cal, int month) {\n        cal.set(Calendar.MONTH, month);\n    }\n\n    public static Calendar addDay(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.DAY_OF_MONTH, incr);\n        return other;\n    }\n\n    public static Calendar addMonth(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.MONTH, incr);\n        return other;\n    }\n\n    public static Calendar addYear(Calendar cal, int incr) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.YEAR, incr);\n        return other;\n    }\n\n    public static Calendar relativeDay(Calendar cal, int offset) {\n        Calendar other = Calendar.getInstance(cal.getTimeZone());\n        other.setTimeInMillis(cal.getTimeInMillis());\n        other.add(Calendar.DAY_OF_MONTH, offset);\n        return other;\n    }\n\n    public static boolean isSameDate(Calendar day1, Calendar day2) {\n        return day1.get(Calendar.YEAR) ==  day2.get(Calendar.YEAR) &&\n                day1.get(Calendar.MONTH) ==  day2.get(Calendar.MONTH) &&\n                day1.get(Calendar.DAY_OF_MONTH) ==  day2.get(Calendar.DAY_OF_MONTH);\n    }\n\n    public static boolean isSameMonth(Calendar day1, Calendar day2) {\n        return day1.get(Calendar.YEAR) ==  day2.get(Calendar.YEAR) &&\n                day1.get(Calendar.MONTH) ==  day2.get(Calendar.MONTH);\n\n    }\n\n    public static int getYear(Calendar cal) { return cal.get(Calendar.YEAR); }\n    public static int getMonth(Calendar cal) { return cal.get(Calendar.MONTH); }\n    public static int getDay(Calendar cal) { return cal.get(Calendar.DAY_OF_MONTH); }\n    public static int getDayOfWeek(Calendar cal) { return cal.get(Calendar.DAY_OF_WEEK); }\n\n    /** Given the checkedCalendars folder id, returns the canonical folder id for mountpoints\n     * @return canonical folder ids in case of mountpoints, local folder ids otherwise\n     */\n    public static String getCanonicalFolderIds(ZMailboxBean mailbox, String checkedCalendars) throws ServiceException {\n        StringBuilder sb = new StringBuilder();\n        String folders[] = checkedCalendars.split(\",\");\n        ZMailbox mbox = mailbox.getMailbox();\n        for (int i = 0; i < folders.length; i++) {\n            ZFolder f = mbox.getFolderById(folders[i]);\n            String folderid = f instanceof ZMountpoint ? ((ZMountpoint) f ).getCanonicalRemoteId() : folders[i];\n            if (sb.length() > 0) sb.append(',');\n            sb.append(folderid);\n        }\n        return sb.toString();\n    }\n\n    public static String getCheckedCalendarFolderIds(ZMailboxBean mailbox) throws ServiceException {\n        StringBuilder sb = new StringBuilder();\n        getCheckedCalendarFoldersRecursive(mailbox.getMailbox().getUserRoot(), sb);\n        return sb.toString();\n    }\n\n    private static void getCheckedCalendarFoldersRecursive(ZFolder f, StringBuilder sb) {\n        if (f.getDefaultView() == View.appointment && f.isCheckedInUI()) {\n            if (sb.length() > 0) sb.append(',');\n            sb.append(f.getId());\n        }\n        for (ZFolder child : f.getSubFolders()) {\n            getCheckedCalendarFoldersRecursive(child, sb);\n        }\n    }\n\n    public static boolean hasAnyAppointments(ZApptSummariesBean summary, long start, long end) {\n        for (ZAppointmentHit appt : summary.getAppointments()) {\n            if (appt.isInRange(start, end)) return true;\n        }\n        return false;\n    }\n\n    private static final long MSECS_PER_MINUTE = 1000*60;\n    private static final long MSECS_PER_HOUR = MSECS_PER_MINUTE * 60;\n\n    public static long MSECS_PER_MINUTE() { return MSECS_PER_MINUTE; }\n    public static long MSECS_PER_HOUR() { return MSECS_PER_HOUR; }\n\n\tpublic static String getCanonicalId(TimeZone tz) {\n\t\treturn TZIDMapper.canonicalize(tz.getID());\n\t}\n\n    public static TimeZone getTimeZone(String id) {\n        id = TZIDMapper.canonicalize(id);\n        return id == null ? TimeZone.getDefault() : TimeZone.getTimeZone(id);\n    }\n\n    public static String getFolderStyleColor(String color, String view) throws ServiceException {\n        return ZFolderBean.getStyleColor(Color.fromString(color), View.fromString(view));\n    }\n\n    public static String getFolderRgbColor(String color, String view) throws ServiceException {\n        return ZFolderBean.getRgbColor(Color.fromString(color), View.fromString(view));\n    }\n\n    public static boolean actionSet(Map param, String action) {\n        return param.containsKey(action) || param.containsKey(action+\".x\");\n    }\n\n    public static boolean isSameTimeZone(String tz1, String tz2) {\n        return (tz1 == null || tz2 == null) ? tz1 == tz2 :\n                TZIDMapper.canonicalize(tz1).equals(TZIDMapper.canonicalize(tz2));\n    }\n\n    public static ZAttendee getMyAttendee(ZInvite invite, ZMailboxBean mailbox) throws ServiceException {\n        ZComponent comp = invite.getComponent();\n        List<ZAttendee> attendees = comp.getAttendees();\n        if (attendees != null) {\n            Set<String> myAddrs = mailbox.getAccountInfo().getEmailAddresses();\n            for (ZAttendee attendee : attendees) {\n                if (myAddrs.contains(attendee.getAddress()) || myAddrs.contains(attendee.getUrl()))\n                    return attendee;\n            }\n        }\n        return null;\n    }\n\n    public static String getRepeatBlurb(ZSimpleRecurrence repeat, PageContext pc, TimeZone timeZone, Date startDate) {\n        String r = \"\";\n        Calendar cal;\n\n        if (repeat == null || repeat.getType() == null) {\n            return I18nUtil.getLocalizedMessage(pc, \"recurNone\");\n        }\n\n        switch (repeat.getType()) {\n            case NONE:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurNone\");\n                break;\n            case DAILY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurDailyEveryDay\");\n                break;\n            case DAILY_WEEKDAY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurDailyEveryWeekday\");\n                break;\n            case DAILY_INTERVAL:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurDailyEveryNumDays\", new Object[] {repeat.getDailyInterval()});\n                break;\n            case WEEKLY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurDailyEveryWeek\");\n                break;\n            case WEEKLY_BY_DAY:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getWeeklyByDay().ordinal()+1);\n                r = I18nUtil.getLocalizedMessage(pc, \"recurWeeklyEveryWeekday\", new Object[] {cal.getTime()});\n                break;\n            case WEEKLY_CUSTOM:\n                StringBuilder wc = new StringBuilder();\n                cal = getToday(timeZone);\n                wc.append(I18nUtil.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeks\", new Object[] {repeat.getWeeklyInterval()}));\n                wc.append(\" \");\n                int wci = 1, wcmax = repeat.getWeeklyIntervalDays().size();\n                for (ZWeekDay day : repeat.getWeeklyIntervalDays()) {\n                    if (wci != 1 && wci != wcmax) wc.append(I18nUtil.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksSep\")).append(\" \");\n                    if (wci != 1 && wci == wcmax) wc.append(\" \").append(I18nUtil.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksLastSep\")).append(\" \");\n                    setDayOfWeek(cal, day.getOrdinal()+1);\n                    wc.append(I18nUtil.getLocalizedMessage(pc, \"recurWeeklyEveryNumWeeksDay\", new Object[] {cal.getTime()}));\n                    wci++;\n                }\n                r = wc.toString();\n                break;\n            case MONTHLY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurMonthly\");\n                break;\n            case MONTHLY_BY_MONTH_DAY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurMonthlyEveryNumMonthsDate\",\n                        new Object[] {repeat.getMonthlyMonthDay(), repeat.getMonthlyInterval()});\n                break;\n            case MONTHLY_RELATIVE:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getMonthlyRelativeDay().getDay().getOrdinal()+1);\n                r = I18nUtil.getLocalizedMessage(pc, \"recurMonthlyEveryNumMonthsNumDay\",\n                        new Object[] {\n                                repeat.getMonthlyRelativeDay().getWeekOrd(),\n                                cal.getTime(),\n                                repeat.getMonthlyInterval()\n                        });\n                break;\n            case YEARLY:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurYearly\");\n                break;\n            case YEARLY_BY_DATE:\n                cal = getToday(timeZone);\n                setMonth(cal, repeat.getYearlyByDateMonth()-1);\n                r = I18nUtil.getLocalizedMessage(pc, \"recurYearlyEveryDate\",\n                        new Object[] { cal.getTime(), repeat.getYearlyByDateMonthDay()});\n                break;\n            case YEARLY_RELATIVE:\n                cal = getToday(timeZone);\n                setDayOfWeek(cal, repeat.getYearlyRelativeDay().getDay().getOrdinal()+1);\n                setMonth(cal, repeat.getYearlyRelativeMonth()-1);\n                r = I18nUtil.getLocalizedMessage(pc, \"recurYearlyEveryMonthNumDay\",\n                        new Object[] {\n                                repeat.getYearlyRelativeDay().getWeekOrd(),\n                                cal.getTime(),\n                                cal.getTime()\n                        });\n                break;\n            default:\n                r = I18nUtil.getLocalizedMessage(pc, \"recurComplex\");\n                break;\n        }\n\n        if (repeat.getType() == ZSimpleRecurrenceType.NONE)\n            return r;\n\n        String e = \"\";\n\n        switch (repeat.getEnd()) {\n            case NEVER:\n                e = I18nUtil.getLocalizedMessage(pc, \"recurEndNone\");\n                break;\n            case COUNT:\n                e = I18nUtil.getLocalizedMessage(pc, \"recurEndNumber\", new Object[] {repeat.getCount()});\n                break;\n            case UNTIL:\n                DateFormat untilDf = DateFormat.getDateInstance(DateFormat.MEDIUM, pc.getRequest().getLocale());\n                if (timeZone != null) untilDf.setTimeZone(timeZone);\n                String untilDate = untilDf.format(repeat.getUntilDate().getDate());\n                e = I18nUtil.getLocalizedMessage(pc, \"recurEndByDate\", new Object[] { untilDate});\n                break;\n        }\n\n        String s = \"\";\n        if (startDate != null) {\n            DateFormat startDf = DateFormat.getDateInstance(DateFormat.MEDIUM, pc.getRequest().getLocale());\n            if (timeZone != null) startDf.setTimeZone(timeZone);\n            s = I18nUtil.getLocalizedMessage(pc, \"recurStart\", new Object[] { startDf.format(startDate)});\n\n        }\n\n        return I18nUtil.getLocalizedMessage(pc, \"repeatBlurb\", new Object[] { r, e, s});\n    }\n\n    public static String getApptDateBlurb(PageContext pc, TimeZone timeZone, long startTime, long endTime, boolean allDay) {\n        Calendar startCal = getCalendar(startTime, timeZone);\n        Calendar endCal = getCalendar(endTime, timeZone);\n\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL, pc.getRequest().getLocale());\n        DateFormat tf = DateFormat.getTimeInstance(DateFormat.SHORT, pc.getRequest().getLocale());\n        \n        if (timeZone != null) {\n            df.setTimeZone(timeZone);\n            tf.setTimeZone(timeZone);\n        }\n\n        boolean sameDate = isSameDate(startCal, endCal);\n\n        if (allDay && sameDate) {\n                return I18nUtil.getLocalizedMessage(pc, \"apptDateBlurbAllDay\",\n                        new Object[] {df.format(startCal.getTime())});\n        } else if (allDay) {\n                return I18nUtil.getLocalizedMessage(pc, \"apptDateBlurbAllDayDiffEndDay\",\n                        new Object[] {df.format(startCal.getTime()), df.format(endCal.getTime())});\n        } else if (sameDate) {\n                return I18nUtil.getLocalizedMessage(pc, \"apptDateBlurb\",\n                        new Object[] {\n                                df.format(startCal.getTime()),\n                                tf.format(startCal.getTime()),\n                                tf.format(endCal.getTime())\n                        });\n        } else {\n                return I18nUtil.getLocalizedMessage(pc, \"apptDateBlurbDiffEndDay\",\n                        new Object[] {\n                                df.format(startCal.getTime()),\n                                tf.format(startCal.getTime()),\n                                df.format(endCal.getTime()),\n                                tf.format(endCal.getTime())\n                        });\n        }\n    }\n\n    public static void clearMessageCache(ZMailboxBean mailbox) {\n        mailbox.getMailbox().clearMessageCache();\n    }\n\n    public static void clearContactCache(ZMailboxBean mailbox) {\n        mailbox.getMailbox().clearContactCache();\n    }\n\n    public static void clearApptSummaryCache(ZMailboxBean mailbox) {\n        mailbox.getMailbox().clearApptSummaryCache();\n    }\n\n    public static void refreshPrefs(ZMailboxBean mailbox) throws JspTagException {\n        try {\n            mailbox.getMailbox().getPrefs(true);\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static boolean hasShareMountPoint(ZMailboxBean mailbox, ZMessageBean message) {\n        ZShare share = message.getShare();\n        if (share == null) return false;\n\n        try {\n            ZFolder folder = mailbox.getMailbox().getFolderById(share.getGrantor().getId()+\":\"+share.getLink().getId());\n            return folder != null;\n        } catch (ServiceException e) {\n            return false;\n        }\n    }\n\n    public static String jsEncode(String str) {\n        return StringUtil.jsEncode(str);\n\t}\n\n    public static String getFolderRestURL(ZMailboxBean mailbox, ZFolderBean folder) throws JspTagException {\n        try {\n            return mailbox.getRestURI(folder.getRootRelativePathURLEncoded()).toString();\n        } catch (ServiceException e) {\n            throw new JspTagException(e);\n        }\n    }\n\n    public static String getVoiceFolderType(ZFolderBean folder) {\n        String name = folder.getName();\n        if (VoiceConstants.FNAME_PLACEDCALLS.equals(name) ||\n            VoiceConstants.FNAME_ANSWEREDCALLS.equals(name) ||\n            VoiceConstants.FNAME_MISSEDCALLS.equals(name)) {\n            return ZSearchParams.TYPE_CALL; \n        }\n        return ZSearchParams.TYPE_VOICE_MAIL;\n    }\n\n    public static String getVoiceFolderQuery(ZFolderBean folder) {\n        String id = folder.getId();\n        String phone = id.substring(id.indexOf('-') + 1);\n        String name = folder.getName();\n        return \"phone:\" + phone + \" \" + \"in:\\\"\" + name + \"\\\"\";\n    }\n\n    public static String getVoiceFolderName(PageContext pc, ZFolderBean folder) {\n        String name = folder.getName();\n        String key = null;\n        if (VoiceConstants.FNAME_PLACEDCALLS.equals(name)) {\n            key = \"placedCalls\";\n        } else if (VoiceConstants.FNAME_ANSWEREDCALLS.equals(name)) {\n            key = \"answeredCalls\";\n        } else if (VoiceConstants.FNAME_MISSEDCALLS.equals(name)) {\n            key = \"missedCalls\";\n        } else if (VoiceConstants.FNAME_VOICEMAILINBOX.equals(name)) {\n            key = \"voiceMail\";\n        } else if (VoiceConstants.FNAME_TRASH.equals(name)) {\n            key = \"trash\";\n        }\n        return key != null ? I18nUtil.getLocalizedMessage(pc, key) : name;\n    }\n\n    public static String getPhoneDisplay(String name) {\n        return ZPhone.getDisplay(name);\n    }\n\n    public static String getPhoneFromVoiceQuery(String query) {\n        // Guess the phone name from query. If I knew better how to pass\n        // information around all these jsps, I wouldn't need to guess....\n        // TODO:\n        String phone = \"phone:\";\n        int match = query.indexOf(phone);\n        if (match != -1) {\n            int startIndex = match + phone.length();\n            int endIndex = query.indexOf(' ', startIndex);\n            if (endIndex == -1) {\n                endIndex = query.length();\n            }\n            return query.substring(startIndex, endIndex);\n        }\n        return \"\";\n    }\n\n    public static ZVoiceMailItemHitBean deserializeVoiceMailItemHit(String value, String phone) throws ServiceException {\n\t\treturn ZVoiceMailItemHitBean.deserialize(value, phone);\n\t}\n\t\n\tpublic static ZVoiceMailItemHitBean[] deserializeVoiceMailItemHits(String[] values, String phone) throws ServiceException {\n        if (values == null) {\n            return new ZVoiceMailItemHitBean[0]; \n        }\n        ZVoiceMailItemHitBean[] result = new ZVoiceMailItemHitBean[values.length];\n        for (int i = 0, count = values.length; i < count; i++) {\n            result[i] = deserializeVoiceMailItemHit(values[i], phone);\n        }\n        return result;\n    }\n\n    public static String deserializeVoiceMailItemIds(String[] values, String phone) throws ServiceException {\n        if (values == null) {\n            return \"\"; \n        }\n        StringBuilder builder = new StringBuilder(128);\n        for (String value : values) {\n            if (builder.length() > 0) {\n                builder.append(',');\n            }\n            ZVoiceMailItemHitBean bean = ZVoiceMailItemHitBean.deserialize(value, phone);\n            builder.append(bean.getId());\n        }\n        return builder.toString();\n    }\n\n\tpublic static ZPhoneAccountBean getFirstPhoneAccount(PageContext pc) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tList<ZPhoneAccount> accounts = mbox.getAllPhoneAccounts();\n\t\treturn accounts.size() > 0 ? new ZPhoneAccountBean(accounts.get(0)) : null;\n\t}\n\n\tpublic static ZPhoneAccountBean getPhoneAccount(PageContext pc, String phone) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tZPhoneAccount account = mbox.getPhoneAccount(phone);\n\t\treturn account == null ? null : new ZPhoneAccountBean(account);\n\t}\n\n\tpublic static Map<String, String> sPHONE_FIELDS = new HashMap<String, String>();\n\tstatic {\n\t\tsPHONE_FIELDS.put(ContactConstants.A_callbackPhone, \"phoneLabelCallback\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_carPhone, \"phoneLabelCar\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_assistantPhone, \"phoneLabelAssistant\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_companyPhone, \"phoneLabelCompany\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_homeFax, \"phoneLabelHomeFax\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_homePhone, \"phoneLabelHome\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_homePhone2, \"phoneLabelHome2\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_mobilePhone, \"phoneLabelMobile\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_otherPhone, \"phoneLabelHomeAlternate\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_workPhone, \"phoneLabelWork\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_workPhone2, \"phoneLabelWork2\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_homeFax, \"phoneLabelHomeFax\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_workFax, \"AB_FIELD_workFax\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_workMobile, \"AB_FIELD_workMobile\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_workAltPhone, \"AB_FIELD_workAlternatePhone\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_otherFax, \"AB_FIELD_otherFax\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_assistantPhone, \"phoneLabelAssistant\");\n\t\tsPHONE_FIELDS.put(ContactConstants.A_companyPhone, \"AB_FIELD_company\");\n\t}\n\tpublic static String getDisplayCaller(PageContext pc, ZPhone phone) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\tZContactByPhoneCache.ContactPhone data = mbox.getContactByPhone(phone.getName());\n\t\tString phoneDisplay = phone.getDisplay();\n\t\tif (data != null) {\n\t\t\tString fileAsString = Contact.getFileAsString(data.getContact().getAttrs());\n\t\t\tif (fileAsString != null && fileAsString.length() > 0) {\n\t\t\t\tString field = I18nUtil.getLocalizedMessage(pc, sPHONE_FIELDS.get(data.getField()));\n\t\t\t\treturn I18nUtil.getLocalizedMessage(pc, \"callingPartyFormat\",\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\t\tBeanUtils.cook(fileAsString),\n\t\t\t\t\t\t\t\tfield,\n\t\t\t\t\t\t\t\tphoneDisplay\n\t\t\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tString callerId = phone.getCallerId();\n\t\tif (!StringUtil.isNullOrEmpty(callerId)) {\n\t\t\treturn I18nUtil.getLocalizedMessage(pc, \"callingPartyCallerIdFormat\",\n\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tBeanUtils.cook(callerId),\n\t\t\t\t\t\t\tphoneDisplay\n\t\t\t\t\t});\n\t\t}\n\t\tif (phoneDisplay != null && phoneDisplay.length() != 0)\n\t\t\treturn phoneDisplay;\n\n\t\tString name = phone.getName();\n\t\tif (!StringUtil.isNullOrEmpty(name))\n\t\t\treturn name;\n\n\t\treturn I18nUtil.getLocalizedMessage(pc, \"noCallerId\");\n\t}\n\n\tprivate static Pattern sPHONE_NAME = Pattern.compile(\"[^\\\\d]\");\n\tprivate static String getPhoneName(String display) {\n\t\treturn sPHONE_NAME.matcher(display).replaceAll(\"\");\n\t}\n\n\tprivate static final Pattern sPHONE = Pattern.compile(\"[0-9()\\\\-\\\\s\\\\+]+\");\n\tpublic static boolean isValidPhoneNumber(String number) {\n\t\tif (number == null) {\n\t\t\treturn false;\n\t\t}\n\t\tint length = getPhoneName(number).length();\n\t\treturn 7 <= length && length <= 20 && sPHONE.matcher(number).matches();\n\t}\n\n    private static Pattern sEMAIL_ADDRESS = Pattern.compile(\".+@.+\\\\.[a-z]+\");\n    public static boolean isValidEmailAddress(String email) {\n        Matcher m = sEMAIL_ADDRESS.matcher(email);                          \n        boolean matchFound = m.matches();\n        if(matchFound)\n           return true;\n        else\n            return false;\n\n    }\n\n    public static boolean isValidEmailAddresses(String emailline) {\n        boolean validEmail = true;\n        try {\n            emailline = emailline.replace(\";\", \",\");\n            InternetAddress[] inetAddrs = JavaMailInternetAddress.parseHeader(emailline, false);\n            for (InternetAddress ia : inetAddrs) {\n                Matcher m = sEMAIL_ADDRESS.matcher(ia.getAddress());                          \n                boolean matchFound = m.matches();\n                if(matchFound)\n                    validEmail = true;\n                else\n                    validEmail =  false;\n            }\n            return validEmail;\n        } catch ( AddressException e) {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if the user's UA matches the allowed user agents for honoring\n     * zimbraWebClientLogoutURL.\n     * Returns true if the regex matches or if the\n     * zimbraWebClientLogoutURLAllowedUA is not set(implies all UAs are allowed),\n     * false otherwise.\n     */\n    public static boolean isAllowedUA(com.zimbra.cs.taglib.bean.ZUserAgentBean ua, String[] allowedUA) {\n        if (allowedUA == null || allowedUA.length == 0) return true;\n        Pattern pattern;\n        Matcher m;\n        for (String str : allowedUA) {\n            pattern = Pattern.compile(str);\n            if (ua.getUserAgent() == null) return false;\n            m = pattern.matcher(ua.getUserAgent());\n            if (m.find())\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether email features and tabs are enabled for a user or for a delegated admin access.\n     * Returns true if mail feature is enabled for a user or if zimbraFeatureAdminMailEnabled is set to\n     * true in case of delegated admin login, false otherwise.\n     */\n    public static boolean isMailEnabled(com.zimbra.cs.taglib.bean.ZMailboxBean mailbox) throws ServiceException{\n        ZFeatures features = mailbox.getFeatures();\n        if (features.getMail() && (!mailbox.getAdminDelegated() || (mailbox.getAdminDelegated() && features.getAdminMail()))) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Lightens the hex color string by a fraction of 0.3\n     */\n    public static String lightenColor(String color) {\n        java.awt.Color col = java.awt.Color.decode(color);\n        String retColor = \"#\";\n        int []rgb = new int[3];\n\n        rgb[0] = col.getRed();\n        rgb[1] = col.getGreen();\n        rgb[2] = col.getBlue();\n\n        for(int index = 0; index < 3 ;index ++)\n        {\n            rgb[index] = (int)Math.max(0, Math.min(255, rgb[index] + (255 - rgb[index])*0.3));\n            retColor += Integer.toHexString(rgb[index]);\n        }\n        return retColor;\n    }\n    \n    public static boolean getIsMyCard(PageContext pc, String ids) throws ServiceException, JspException {\n\t\tZMailbox mbox = ZJspSession.getZMailbox(pc);\n\t\treturn mbox.getIsMyCard(ids);\n\t}\n\t\n\t/*\n\t * Start Yahoo! code\n\t */\n\tpublic static Calendar getYFirstDayOfMonthView(java.util.Calendar date, long prefFirstDayOfWeek) {\n         prefFirstDayOfWeek++; // pref goes 0-6, Calendar goes 1-7\n         Calendar cal = Calendar.getInstance(date.getTimeZone());\n         cal.setTimeInMillis(date.getTimeInMillis());\n         cal.set(Calendar.HOUR_OF_DAY, 0);\n         cal.set(Calendar.MINUTE, 0);\n         cal.set(Calendar.SECOND, 0);\n         cal.set(Calendar.MILLISECOND, 0);\n         cal.set(Calendar.DAY_OF_MONTH, 1);\n         int dow = cal.get(Calendar.DAY_OF_WEEK);\n         if (dow != prefFirstDayOfWeek) {\n\t\t\tcal.add(Calendar.DAY_OF_MONTH, - ((dow+(7-((int)prefFirstDayOfWeek)))%7));\n         }\n         return cal;\n    }\n\t\n\tpublic static int getNumberOfWeeksOfMonth(java.util.Calendar date) {\n        Calendar cal = (Calendar)date.clone();\n        return cal.getActualMaximum(Calendar.WEEK_OF_MONTH);\n    }\n\n    /* End Yahoo! code */\n\n\tpublic static String getImagePath(PageContext pc, String relativePath) {\n\t\tfinal String ZIMBRA_IMAGE_SERVERS = \"zimbraImageServers\";\n\t\tString[] servers = (String[]) pc.getAttribute(ZIMBRA_IMAGE_SERVERS, PageContext.APPLICATION_SCOPE);\n\t\tif (servers == null) {\n\t\t\tString serverList = pc.getServletContext().getInitParameter(ZIMBRA_IMAGE_SERVERS);\n\t\t\tservers = (serverList == null || serverList.length() == 0) ? new String[0] : sCOMMA.split(serverList);\n\t\t\tfor (int i = 0, count = servers.length; i < count; i++) {\n\t\t\t\tservers[i] = servers[i].trim();\n\t\t\t}\n\t\t\tpc.setAttribute(ZIMBRA_IMAGE_SERVERS, servers, PageContext.APPLICATION_SCOPE);\n\t\t}\n\t\tif (servers.length > 0) {\n\t\t\t// Generate the url for the image. Path starts with \"//\" to pick up current protocol.\n\t\t\t// The use of hashCode just ensures that for any given image, the same server is always used.  \n\t\t\tint index = Math.abs(relativePath.hashCode()) % servers.length;\n\t\t\treturn \"//\" + servers[index] + \":\" +  pc.getRequest().getServerPort() + relativePath;\n\t\t} else {\n\t\t\treturn relativePath;\n\t\t}\n\t}\n\n\t/**\n\t * \"Cooks\" the input string. (Removes special characters that can be used to create xss attacks.)\n\t */\n\tpublic static String cook(String in) {\n\t\treturn StringUtil.escapeHtml(in);\n\t}\n\n\t/**\n\t * \"Cooks\" an input string where an integer is expected.\n\t */\n\tpublic static int cookInt(String in, int defaultValue) {\n\t\tif (in == null || in.length() == 0) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\ttry {\n\t\t\treturn Integer.parseInt(in);\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn defaultValue;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the specified object appears in the given container.\n\t * Container can be a Collection, an array, or a string.\n\t */\n\tpublic static boolean contains(Object container, Object object) {\n\t\tif (container == null || object == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (container instanceof Collection) {\n\t\t\treturn ((Collection)container).contains(object);\n\t\t}\n\t\tif (container instanceof Object[]) {\n\t\t\tObject[] array = (Object[])container;\n\t\t\tfor (Object item : array) {\n\t\t\t\tif (item.equals(object)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn String.valueOf(container).contains(String.valueOf(object));\n\t}\n\n\tpublic static String javaLocaleId(Locale locale) {\n\t\t// NOTE: Java uses has the wrong code for Indonesian\n\t\t// NOTE: http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6457127\n\t\tString locid = locale.toString();\n\t\treturn locid.startsWith(\"in\") ? locid.replaceAll(\"^in\", \"id\") : locid;\n\t}\n\tpublic static String browserLocaleId(Locale locale) {\n\t\treturn javaLocaleId(locale).toLowerCase().replace('_','-');\n\t}\n    public static java.lang.String yuiCompress(java.lang.String s, String type){\n        try{\n            StringWriter out = new StringWriter();\n            StringReader in = new StringReader(s);\n            int linebreakpos = -1;\n            if(type.equalsIgnoreCase(\"css\")){\n               CssCompressor compressor = new CssCompressor(in);\n                in.close(); in = null;\n                compressor.compress(out, linebreakpos);\n                s = out.toString();\n            }else if(type.equalsIgnoreCase(\"js\")){\n                JavaScriptCompressor jsc = new JavaScriptCompressor(in,new ErrorReporter() {\n\n                        public void warning(String message, String sourceName,\n                                int line, String lineSource, int lineOffset) {\n                            if (line < 0) {\n                                System.err.println(\"\\nyuiCompress:[WARNING] \" + message);\n                            } else {\n                                System.err.println(\"\\nyuiCompress:[WARNING] \" + line + ':' + lineOffset + ':' + message);\n                            }\n                        }\n\n                        public void error(String message, String sourceName,\n                                int line, String lineSource, int lineOffset) {\n                            if (line < 0) {\n                                System.err.println(\"\\nyuiCompress:[ERROR] \" + message);\n                            } else {\n                                System.err.println(\"\\nyuiCompress:[ERROR] \" + line + ':' + lineOffset + ':' + message);\n                            }\n                        }\n\n                        public EvaluatorException runtimeError(String message, String sourceName,\n                                int line, String lineSource, int lineOffset) {\n                            error(message, sourceName, line, lineSource, lineOffset);\n                            return new EvaluatorException(message);\n                        }\n                    });\n                jsc.compress(out,linebreakpos,true,false,true,false);\n                s = out.toString();\n            }\n        }catch (Exception ex){\n           System.err.println(\"\\nyuiCompress:[EXCEPTION] \" + ex);\n           ex.printStackTrace(System.err);\n        }\n        return s;\n    }\n\n    public static String capitalize(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        return s.length() > 1 ? s.substring(0,1).toUpperCase()+s.substring(1) : s.toUpperCase();\n    }\n}\n\nclass ExtendedDateFormatSymbols extends DateFormatSymbols{\n\n    public ExtendedDateFormatSymbols(Locale locale, PageContext pc){\n        super(locale);\n        init(pc);\n    }\n\n    private void init(PageContext pc){\n\n        String[] weekDays = new String[8], shortWeekDays=  new String[8], months = new String[12], shortMonths = new String[12];\n        String[] dayNames = {\"Sun\",\"Mon\", \"Tue\" ,\"Wed\", \"Thu\", \"Fri\" , \"Sat\"};\n        String[] monthNames = {\"Jan\",\"Feb\", \"Mar\" , \"Apr\", \"May\" , \"Jun\" , \"Jul\" , \"Aug\" , \"Sep\" ,\"Oct\" , \"Nov\" , \"Dec\"};\n\n        for(int i=0;i<dayNames.length;i++){\n            weekDays[i+1] = I18nUtil.getLocalizedMessage(pc,\"weekday\"+dayNames[i]+\"Long\", \"/messages/I18nMsg\");\n            shortWeekDays[i+1] = I18nUtil.getLocalizedMessage(pc,\"weekday\"+dayNames[i]+\"Medium\", \"/messages/I18nMsg\");\n        }\n\n        this.setWeekdays(weekDays);\n        this.setShortWeekdays(shortWeekDays);\n\n        for(int i=0;i<monthNames.length;i++){\n            months[i] = I18nUtil.getLocalizedMessage(pc,\"month\"+monthNames[i]+\"Long\", \"/messages/I18nMsg\");\n            shortMonths[i] = I18nUtil.getLocalizedMessage(pc,\"month\"+monthNames[i]+\"Medium\", \"/messages/I18nMsg\");\n        }\n\n        this.setMonths(months);\n        this.setShortMonths(shortMonths);\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-taglib",
    "commit": "3c1e9f3fd28135111914ef84807a0d65b1b0a784",
    "commit_msg": "bug: 75976 Failed to send message potential XSS\n\nIntegration from helix to main\n\n- Additional Checks for NPE\n- Handling similar case for forward of messages\n\nReviewboard url: https://reviewboard.eng.vmware.com/r/363794/\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=75976\n\nCopied from Perforce\n Change: 389560",
    "original_file": "BeanUtils.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 23,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2005, 2006, 2007, 2009, 2010 Zimbra, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\n/**\n * @author apalaniswamy\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\n\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.LogFactory;\n\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.cs.db.DbPool.DbConnection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\n\n// TODO mailbox migration between servers\n// TODO backup/restore\n// TODO redo logging!\n// TODO have to do GC for sanity\n\npublic class DbOutOfOffice {\n    public static String TABLE_NAME = \"out_of_office\";\n    private static Log mLog = LogFactory.getLog(DbOutOfOffice.class);\n\n    /**\n     * Determines whether an out-of-office reply has already been sent to the\n     * specified address within the last <code>numDays</code> days.\n     * \n     * @param conn the database connection\n     * @param mbox the sender's mailbox\n     * @param sentTo the recipient's email address\n     * @param cacheDurationMillis threshold for determining last sent time\n     * @throws ServiceException if a database error occurs\n     */\n    public static boolean alreadySent(DbConnection conn, Mailbox mbox, String sentTo, long cacheDurationMillis)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(DbMailbox.getZimbraSynchronizer(mbox)));\n\n        sentTo = sentTo.toLowerCase();\n        boolean result = false;\n        Timestamp cutoff = new Timestamp(System.currentTimeMillis() - cacheDurationMillis);\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"SELECT COUNT(*) FROM \" + DbMailbox.qualifyZimbraTableName(mbox, TABLE_NAME) +\n                    \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"sent_to = ? AND sent_on > ?\");\n            int pos = 1;\n            pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, sentTo);\n            stmt.setTimestamp(pos++, cutoff);\n\n            rs = stmt.executeQuery();\n            rs.next();\n            int count = rs.getInt(1);\n            result = (count > 0);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"DbOutOfOffice.getSentTime: sql exception (mailbox_id=\"\n                            + mbox.getId() + \" sent_to=\" + sentTo + \")\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n\n        if (mLog.isDebugEnabled()) {\n            mLog.debug(\"DbOutOfOffice.alreadySent() returning \" + result +\n                        \".  mailbox_id=\" + mbox.getId() + \", sent_to='\" + sentTo + \"'\");\n        }\n        return result;\n    }\n\n    /**\n     * Stores a row in the out_of_office table, indicating that we sent an\n     * out-of-office reply to the specified address.\n     * \n     * @param conn the database connection\n     * @param mbox the mailbox of the sender\n     * @param sentTo the email address of the recipient\n     * @throws ServiceException if a database error occurred\n     */\n    public static void setSentTime(DbConnection conn, Mailbox mbox, String sentTo)\n    throws ServiceException {\n        setSentTime(conn, mbox, sentTo, System.currentTimeMillis());\n    }\n    \n    /**\n     * Stores a row in the out_of_office table, indicating that we sent an\n     * out-of-office reply to the specified address.\n     * \n     * @param conn the database connection\n     * @param mbox the mailbox of the sender\n     * @param sentTo the email address of the recipient\n     * @param sentOn the timestamp of the out-of-office message\n     * @throws ServiceException if a database error occurred\n     */\n    public static void setSentTime(DbConnection conn, Mailbox mbox, String sentTo, long sentOn) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(DbMailbox.getZimbraSynchronizer(mbox)));\n\n        Timestamp ts = new Timestamp(sentOn);\n\n        PreparedStatement stmt = null;\n        try {\n            String command = Db.supports(Db.Capability.REPLACE_INTO) ? \"REPLACE\" : \"INSERT\";\n            stmt = conn.prepareStatement(command + \" INTO \" + DbMailbox.qualifyZimbraTableName(mbox, TABLE_NAME) +\n                    \"(\" + DbMailItem.MAILBOX_ID + \"sent_to, sent_on)\" +\n                    \" VALUES (\" + DbMailItem.MAILBOX_ID_VALUE +\" ?, ?) \");\n            int pos = 1;\n            pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n            stmt.setString(pos++, sentTo.toLowerCase());\n            stmt.setTimestamp(pos++, ts);\n            int num = stmt.executeUpdate();\n            if (num > 0) {\n                if (mLog.isDebugEnabled()) {\n                    mLog.debug(\"DbOutOfOffice.setSentTime: ok (mailbox_id=\" + mbox.getId() +\n                            \" sent_to=\" + sentTo + \" sent_on=\" + sentOn + \" rows=\" + num + \")\");\n                }\n            } else {\n                mLog.error(\"DbOutOfOffice.setSentTime: no rows updated (mailbox_id=\" + mbox.getId()\n                        + \" sent_to=\" + sentTo + \" sent_on=\" + sentOn + \" rows=\" + num + \")\");\n            }\n        } catch (SQLException e) {\n            if (Db.errorMatches(e, Db.Error.DUPLICATE_ROW)) {\n                try {\n                    stmt.close();\n\n                    stmt = conn.prepareStatement(\"UPDATE \" + DbMailbox.qualifyZimbraTableName(mbox, TABLE_NAME) +\n                            \" SET sent_on = ?\" +\n                            \" WHERE \" + DbMailItem.IN_THIS_MAILBOX_AND + \"sent_to = ?\");\n                    int pos = 1;\n                    stmt.setTimestamp(pos++, ts);\n                    pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n                    stmt.setString(pos++, sentTo.toLowerCase());\n                    stmt.executeUpdate();\n                } catch (SQLException nested) {\n                    throw ServiceException.FAILURE(\"DbOutOfOffice.setSentTime: sql exception \" +\n                            \"(mailbox_id=\" + mbox.getId() + \" sent_to\" + sentTo + \" sent_on=\" + sentOn + \")\", nested);\n                }\n            } else {\n                throw ServiceException.FAILURE(\"DbOutOfOffice.setSentTime: sql exception \" +\n                        \"(mailbox_id=\" + mbox.getId() + \" sent_to\" + sentTo + \" sent_on=\" + sentOn + \")\", e);\n            }\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    /**\n     * Clears entries from the <code>out_of_office</code> table for the\n     * specified mailbox.\n     * \n     * @param conn database connection \n     * @param mbox mailbox\n     * @throws ServiceException if a database error occurred\n     */\n    public static void clear(DbConnection conn, Mailbox mbox) throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(DbMailbox.getZimbraSynchronizer(mbox)));\n\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            stmt = conn.prepareStatement(\"DELETE FROM \" + DbMailbox.qualifyZimbraTableName(mbox, TABLE_NAME) +\n                    (DebugConfig.disableMailboxGroups ? \"\" : \" WHERE mailbox_id = ?\"));\n            DbMailItem.setMailboxId(stmt, mbox, 1);\n            int num = stmt.executeUpdate();\n \n            mLog.debug(\"DbOutOfOffice.clear() mbox=\" + mbox.getId() + \" rows=\" + num);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"DbOutOfOffice.clear acctId=\" + mbox.getAccountId(), e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n    \n    public static void prune(DbConnection conn, long cacheDurationMillis)\n    throws ServiceException {\n        // there's no centralized OoO table to prune in the DB-per-user case\n        if (DebugConfig.disableMailboxGroups)\n            return;\n\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(MailboxManager.getInstance()));\n\n        PreparedStatement stmt = null;\n        try {\n            Timestamp cutoff = new Timestamp(System.currentTimeMillis() - cacheDurationMillis);\n            stmt = conn.prepareStatement(\"DELETE FROM \" + TABLE_NAME + \" WHERE sent_on <= ?\");\n            stmt.setTimestamp(1, cutoff);\n            int num = stmt.executeUpdate();\n\n            if (mLog.isDebugEnabled())\n                mLog.debug(\"DbOutOfOffice.prune() deleted \" + num + \" rows\");\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"DbOutOfOffice.prune()\", e);\n        } finally {\n            DbPool.closeStatement(stmt);\n        }\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "6f40d18598ae40a1edded6f72efe472a12fe2ef2",
    "commit_msg": "(split)bug: 59208\n\nEnforce SQLite locking via Db.preOpen() and Db.preClose(). Remove asserts and synchronization on DbMailbox/DbMailItem .getSynchronizer(). Cleanup SQLite specific code in AbstractRetry and increase retry threshold.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=59208\n\nCopied from Perforce\n Change: 298943",
    "original_file": "DbOutOfOffice.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 24,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.taglib.bean;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.DateFormat;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TimeZone;\nimport java.util.UUID;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.jsp.PageContext;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.httpclient.methods.multipart.FilePart;\nimport org.apache.commons.httpclient.methods.multipart.StringPart;\nimport org.apache.commons.httpclient.methods.multipart.Part;\nimport org.apache.commons.httpclient.methods.multipart.PartSource;\n\nimport com.zimbra.common.calendar.TZIDMapper;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.mailbox.calendar.ParsedDuration;\nimport com.zimbra.cs.taglib.tag.i18n.I18nUtil;\nimport com.zimbra.cs.zclient.ZAlarm;\nimport com.zimbra.cs.zclient.ZDateTime;\nimport com.zimbra.cs.zclient.ZEmailAddress;\nimport com.zimbra.cs.zclient.ZFolder;\nimport com.zimbra.cs.zclient.ZIdentity;\nimport com.zimbra.cs.zclient.ZInvite;\nimport com.zimbra.cs.zclient.ZMailbox;\nimport com.zimbra.cs.zclient.ZPrefs;\nimport com.zimbra.cs.zclient.ZSignature;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence;\nimport com.zimbra.cs.zclient.ZInvite.ZAttendee;\nimport com.zimbra.cs.zclient.ZInvite.ZByDayWeekDay;\nimport com.zimbra.cs.zclient.ZInvite.ZClass;\nimport com.zimbra.cs.zclient.ZInvite.ZComponent;\nimport com.zimbra.cs.zclient.ZInvite.ZFreeBusyStatus;\nimport com.zimbra.cs.zclient.ZInvite.ZOrganizer;\nimport com.zimbra.cs.zclient.ZInvite.ZParticipantStatus;\nimport com.zimbra.cs.zclient.ZInvite.ZRole;\nimport com.zimbra.cs.zclient.ZInvite.ZStatus;\nimport com.zimbra.cs.zclient.ZInvite.ZTransparency;\nimport com.zimbra.cs.zclient.ZInvite.ZWeekDay;\nimport com.zimbra.cs.zclient.ZMailbox.ReplyVerb;\nimport com.zimbra.cs.zclient.ZMailbox.ZOutgoingMessage;\nimport com.zimbra.cs.zclient.ZMailbox.ZOutgoingMessage.AttachedMessagePart;\nimport com.zimbra.cs.zclient.ZMailbox.ZOutgoingMessage.MessagePart;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence.ZSimpleRecurrenceEnd;\nimport com.zimbra.cs.zclient.ZSimpleRecurrence.ZSimpleRecurrenceType;\n\npublic class ZMessageComposeBean {\n\n    public static final String NOTES_SEPARATOR = \"*~*~*~*~*~*~*~*~*~*\";\n\n    public static class MessageAttachment {\n        private String mId;\n        private String mSubject;\n\n        public MessageAttachment(String id, String subject) {\n            mId = id;\n            mSubject = subject;\n        }\n\n        public String getId() { return mId; }\n        public String getSubject() { return mSubject; }\n    }\n    public static class DocumentAttachment {\n        private String Id;\n        private String mSubject;\n\n        public DocumentAttachment(String id, String subject) {\n            Id = id;\n            mSubject = subject;\n        }\n\n        public String getId() { return Id; }\n        public String getSubject() { return mSubject; }\n    }\n    \n    public static String RT_BASIC = \"BASIC\";\n    \n    public static String CRLF = \"\\r\\n\";\n\n    public enum Action { NEW, REPLY, REPLY_ALL, FORWARD, RESEND, DRAFT, APPT_NEW, APPT_EDIT, APPT_CANCEL, INVITE_ACCEPT, INVITE_DECLINE, INVITE_TENTATIVE }\n\n    private String mAttendees;\n    private String mResources;\n    private String mApptFolderId;\n    private String mLocation;\n    private String mTimeZone;\n    private String mFreeBusyStatus;\n    private boolean mAllDay;\n    private String mStartDate;\n    private long mStartHour;\n    private long mStartMinute;\n    private String mEndDate;\n    private long mEndHour;\n    private long mEndMinute;\n    private String mInviteReplyVerb;\n    private long mInviteReplyInst;\n    private boolean mInviteReplyAllDay;\n\n    private String mSendUID;\n\n    private String mInviteId;\n    private String mExceptionInviteId;\n    private boolean mUseInstance;\n    private long mInstanceStartTime;\n    private long mInstanceDuration;\n    private String mCompNum;\n    private String mInstanceCompNum;\n    private String mClassProp;\n    private String mTaskStatus;\n    private String mTaskPriority;\n    private String mTaskPercentComplete;\n    private String mDescription;\n    private String mDescriptionHtml;\n    private String mDecodedDescHtml;\n\n    private String mOrigOrganizer;\n    private String mRepeatBasicType;\n    private String mRepeatType;\n    private int mRepeatDailyInterval;\n    private int mRepeatWeeklyByDay;\n    private int mRepeatWeeklyInterval;\n    private boolean mRepeatWeeklySun;\n    private boolean mRepeatWeeklyMon;\n    private boolean mRepeatWeeklyTue;\n    private boolean mRepeatWeeklyWed;\n    private boolean mRepeatWeeklyThu;\n    private boolean mRepeatWeeklyFri;\n    private boolean mRepeatWeeklySat;\n    private int mRepeatMonthlyInterval;\n    private int mRepeatMonthlyMonthDay;\n    private int mRepeatMonthlyRelativeInterval;\n    private int mRepeatMonthlyRelativeOrd;\n    private int mRepeatMonthlyRelativeDay;\n    private int mRepeatYearlyMonthDay;\n    private int mRepeatYearlyMonth;\n    private int mRepeatYearlyRelativeOrd;\n    private int mRepeatYearlyRelativeDay;\n    private int mRepeatYearlyRelativeMonth;\n    private String mRepeatEndType;\n    private int mRepeatEndCount;\n    private String mRecurrenceIdZ;\n\n    private String mRepeatEndDate;\n\n    // format to parse start/endDate\n    private String mDateFormat;\n    private String mTo;\n    private String mCc;\n    private String mBcc;\n    private String mFrom;\n    private String mReplyTo;\n    private String mReplyType;\n    private String mSubject;\n    private String mPriority;\n    private String mContentType = \"text/plain\";\n    private String mContent;\n    private String mHtmlContent;\n    private String mMessageId; // zimbra internal message id of message for reply/forward\n    private String mInReplyTo; // original message-id header\n    private String mDraftId; // id of draft we are editting\n    private List<MessageAttachment> mMessageAttachments;\n    private List<DocumentAttachment> mDocumentAttachments;\n    private Map<String,String> mCheckedAttachmentNames = new HashMap<String, String>();\n    private List<ZMimePartBean> mOriginalAttachments;\n    private List<FileItem> mFileItems = new ArrayList<FileItem>();\n    private String mUploadedAttachmentId;\n\n    // Reminder settings\n    private String mReminder1;\n    private String mReminder2;\n    private String mReminderEmail;\n    private String mReminderMobile;\n    private boolean mSendReminderEmail;\n    private boolean mSendReminderMobile;\n    private boolean mSendReminderYIM;\n\n    public ZMessageComposeBean(PageContext pageContext) {\n        mMessageAttachments = new ArrayList<MessageAttachment>();\n        mDocumentAttachments = new ArrayList<DocumentAttachment>();\n        mOriginalAttachments = new ArrayList<ZMimePartBean>();\n        mDateFormat = I18nUtil.getLocalizedMessage(pageContext, \"CAL_APPT_EDIT_DATE_FORMAT\");\n    }\n\n    public void setInviteReplyVerb(String verb) { mInviteReplyVerb = verb; }\n    public String getInviteReplyVerb() { return mInviteReplyVerb; }\n\n    public void setInviteReplyInst(long inst) { mInviteReplyInst = inst; }\n    public long getInviteReplyInst() { return mInviteReplyInst; }\n\n    public void setInviteReplyAllDay(boolean allDay) { mInviteReplyAllDay = allDay; }\n    public boolean getInviteReplyAllDay() { return mInviteReplyAllDay; }\n\n    public void setTo(String to) { mTo = to; }\n    public String getTo() { return mTo; }\n\n    public void setContent(String content) { mContent = content; }\n    public String getContent() { return mContent; }\n\n    public void setHtmlContent(String htmlContent) { mHtmlContent = htmlContent; }\n    public String getHtmlContent() { return mHtmlContent; }\n\n    public void setContenttype(String contentType) { mContentType = contentType; }\n    public String getContentType() { return mContentType; }\n\n    public void setReplyType(String replyType) { mReplyType = replyType; }\n    public String getReplyType() { return mReplyType; }\n\n    public void setSubject(String subject) { mSubject = subject; }\n    public String getSubject() { return mSubject; }\n\n    public void setPriority(String priority) { mPriority = priority; }\n    public String getPriority() { return mPriority; }\n\n    public void setInReplyTo(String inReplyTo) { mInReplyTo = inReplyTo; }\n    public String getInReplyTo() { return mInReplyTo; }\n\n    public void setFrom(String from) { mFrom = from; }\n    public String getFrom() { return mFrom; }\n\n    public void setBcc(String bcc) { mBcc = bcc; }\n    public String getBcc() { return mBcc; }\n\n    public void setCc(String cc) { mCc = cc; }\n    public String getCc() { return mCc; }\n\n    public void setApptFolderId(String id) { mApptFolderId = id; }\n    public String getApptFolderId() { return mApptFolderId; }\n\n    public void setAttendees(String attendees) { mAttendees = attendees; }\n    public String getAttendees() { return mAttendees; }\n\n    public void setResources(String resources) { mResources = resources; }\n    public String getResources() { return mResources; }\n\n    public void setLocation(String location) { mLocation = location; }\n    public String getLocation() { return mLocation; }\n\n    public void setOrigOrganizer(String organizer) { mOrigOrganizer = organizer; }\n    public String getOrigOrganizer() { return mOrigOrganizer; }\n\n    public void setTimeZone(String timeZone) {\n        mTimeZone = timeZone;\n    }\n    \n    public String getTimeZone() {\n        if (mTimeZone == null || mTimeZone.length() == 0) {\n            return TZIDMapper.canonicalize(TimeZone.getDefault().getID());\n        } else {\n            return mTimeZone;\n        }\n    }\n\n    public void setRecurrenceIdZ(String ridZ) { mRecurrenceIdZ = ridZ; }\n    public String getRecurrenceIdZ() { return mRecurrenceIdZ; }\n\n    public void setFreeBusyStatus(String freeBusyStatus) { mFreeBusyStatus = freeBusyStatus; }\n    public String getFreeBusyStatus() { return mFreeBusyStatus; }\n\n    public void setClassProp(String classProp) { mClassProp = classProp; }\n    public String getClassProp() { return mClassProp; }\n\n    public void setTaskPriority(String prio) { mTaskPriority = prio; }\n    public String getTaskPriority() { return mTaskPriority; }\n\n    public void setTaskStatus(String status) { mTaskStatus = status; }\n    public String getTaskStatus() { return mTaskStatus; }\n\n    public void setTaskPercentComplete(String per) { mTaskPercentComplete = per; }\n    public String getTaskPercentComplete() { return mTaskPercentComplete; }\n\n    public void setAllDay(boolean allDay) { mAllDay = allDay; }\n    public boolean getAllDay() { return mAllDay; }\n\n    public void setStartDate(String startDate) { mStartDate = startDate;}\n    public String getStartDate() { return mStartDate; }\n\n    public void setStartHour(long startHour) { mStartHour = startHour; }\n    public long getStartHour() { return mStartHour; }\n\n    public void setStartMinute(long startMinute) { mStartMinute = startMinute; }\n    public long getStartMinute() { return mStartMinute; }\n\n    public void setEndDate(String endDate) { mEndDate = endDate; }\n    public String getEndDate() { return mEndDate; }\n\n    public void setEndHour(long endHour) { mEndHour = endHour; }\n    public long getEndHour() { return mEndHour; }\n\n    public void setEndMinute(long endMinute) { mEndMinute = endMinute; }\n    public long getEndMinute() { return mEndMinute; }\n\n    public void setDateFormat(String dateFormat) { mDateFormat = dateFormat; }\n    public String getDateFormat() { return mDateFormat; }\n\n    public void setInviteId(String inviteId) { mInviteId = inviteId; }\n    public String getInviteId() { return mInviteId; }\n\n    public void setCompNum(String compNum) { mCompNum = compNum; }\n    public String getCompNum() { return mCompNum; }\n\n    public void setInstanceCompNum(String instCompNum) { mInstanceCompNum = instCompNum; }\n    public String getInstanceCompNum() { return mInstanceCompNum; }\n    \n    public void setExceptionInviteId(String exceptionInviteId) { mExceptionInviteId = exceptionInviteId; }\n    public String getExceptionInviteId() { return mExceptionInviteId; }\n\n    public void setUseInstance(boolean useInstance) { mUseInstance = useInstance; }\n    public boolean getUseInstance() { return mUseInstance; }\n\n    public void setInstanceStartTime(long startTime) { mInstanceStartTime = startTime; }\n    public long getInstanceStartTime() { return mInstanceStartTime; }\n\n    public void setInstanceDuration(long duration) { mInstanceDuration = duration; }\n    public long getInstanceDuration() { return mInstanceDuration; }\n\n    public void setReplyTo(String replyTo) { mReplyTo = replyTo; }\n    public String getReplyTo() { return mReplyTo; }\n\n    public void setMessageId(String id) { mMessageId = id; }\n    public String getMessageId() { return mMessageId; }\n\n    public void setDraftId(String id) { mDraftId = id; }\n    public String getDraftId() { return mDraftId; }\n\n    public Map<String,String> getCheckedAttachmentNames() { return mCheckedAttachmentNames; }\n    public void setCheckedAttachmentName(String name,String id) { mCheckedAttachmentNames.put(name,  id); }\n\n    public String getUploadedAttachment() { return mUploadedAttachmentId; }\n    public void setUploadedAttachment(String id) { mUploadedAttachmentId = id; }\n\n    public List<FileItem> getFileItems() { return mFileItems; }\n    public void addFileItem(FileItem item) { mFileItems.add(item); }\n    public boolean getHasFileItems() { return !mFileItems.isEmpty(); }\n\n    public void setOrignalAttachments(List<ZMimePartBean> attachments) { mOriginalAttachments = attachments; }\n    public List<ZMimePartBean> getOriginalAttachments() { return mOriginalAttachments; }\n\n    public void setMessageAttachments(List<MessageAttachment> attachments) { mMessageAttachments = attachments; }\n    public List<MessageAttachment> getMessageAttachments() { return mMessageAttachments; }\n\n    public void setDocumentAttachments(List<DocumentAttachment> attachments) { mDocumentAttachments = attachments; }\n    public List<DocumentAttachment> getDocumentAttachments() { return mDocumentAttachments; }\n\n    public String getRepeatBasicType() { return mRepeatBasicType; }\n    public void setRepeatBasicType(String repeatBasicType) { mRepeatBasicType = repeatBasicType; }\n\n    public String getRepeatType() { return mRepeatType;}\n    public void setRepeatType(String repeatType) { mRepeatType = repeatType; }\n\n    public int getRepeatDailyInterval() { return mRepeatDailyInterval; }\n    public void setRepeatDailyInterval(int repeatDailyInterval) { mRepeatDailyInterval = repeatDailyInterval; }\n\n    public int getRepeatWeeklyByDay() { return mRepeatWeeklyByDay; }\n    public void setRepeatWeeklyByDay(int repeatWeeklyByDay) { mRepeatWeeklyByDay = repeatWeeklyByDay; }\n\n    public int getRepeatWeeklyInterval() { return mRepeatWeeklyInterval; }\n    public void setRepeatWeeklyInterval(int repeatWeeklyInterval) { mRepeatWeeklyInterval = repeatWeeklyInterval; }\n\n    public boolean isRepeatWeeklySun() { return mRepeatWeeklySun; }\n    public void setRepeatWeeklySun(boolean repeatWeeklySun) { mRepeatWeeklySun = repeatWeeklySun; }\n\n    public boolean isRepeatWeeklyMon() { return mRepeatWeeklyMon; }\n    public void setRepeatWeeklyMon(boolean repeatWeeklyMon) { mRepeatWeeklyMon = repeatWeeklyMon; }\n\n    public boolean isRepeatWeeklyTue() { return mRepeatWeeklyTue; }\n    public void setRepeatWeeklyTue(boolean repeatWeeklyTue) { mRepeatWeeklyTue = repeatWeeklyTue; }\n\n    public boolean isRepeatWeeklyWed() { return mRepeatWeeklyWed; }\n    public void setRepeatWeeklyWed(boolean repeatWeeklyWed) { mRepeatWeeklyWed = repeatWeeklyWed; }\n\n    public boolean isRepeatWeeklyThu() { return mRepeatWeeklyThu; }\n    public void setRepeatWeeklyThu(boolean repeatWeeklyThu) { mRepeatWeeklyThu = repeatWeeklyThu; }\n\n    public boolean isRepeatWeeklyFri() { return mRepeatWeeklyFri; }\n    public void setRepeatWeeklyFri(boolean repeatWeeklyFri) { mRepeatWeeklyFri = repeatWeeklyFri; }\n\n    public boolean isRepeatWeeklySat() { return mRepeatWeeklySat; }\n    public void setRepeatWeeklySat(boolean repeatWeeklySat) { mRepeatWeeklySat = repeatWeeklySat; }\n\n    public int getRepeatMonthlyInterval() { return mRepeatMonthlyInterval; }\n    public void setRepeatMonthlyInterval(int repeatMonthlyInterval) { mRepeatMonthlyInterval = repeatMonthlyInterval; }\n\n    public int getRepeatMonthlyMonthDay() { return mRepeatMonthlyMonthDay; }\n    public void setRepeatMonthlyMonthDay(int repeatMonthlyMonthDay) { mRepeatMonthlyMonthDay = repeatMonthlyMonthDay; }\n\n    public int getRepeatMonthlyRelativeInterval() { return mRepeatMonthlyRelativeInterval; }\n    public void setRepeatMonthlyRelativeInterval(int repeatMonthlyRelativeInterval) { mRepeatMonthlyRelativeInterval = repeatMonthlyRelativeInterval; }\n\n    public int getRepeatMonthlyRelativeOrd() { return mRepeatMonthlyRelativeOrd; }\n    public void setRepeatMonthlyRelativeOrd(int repeatMonthlyRelativeOrd) { mRepeatMonthlyRelativeOrd = repeatMonthlyRelativeOrd; }\n\n    public int getRepeatMonthlyRelativeDay() { return mRepeatMonthlyRelativeDay; }\n    public void setRepeatMonthlyRelativeDay(int repeatMonthlyRelativeDay) { mRepeatMonthlyRelativeDay = repeatMonthlyRelativeDay; }\n\n    public int getRepeatYearlyMonthDay() { return mRepeatYearlyMonthDay; }\n    public void setRepeatYearlyMonthDay(int repeatYearlyMonthDay) { mRepeatYearlyMonthDay = repeatYearlyMonthDay; }\n\n    public int getRepeatYearlyMonth() { return mRepeatYearlyMonth; }\n    public void setRepeatYearlyMonth(int repeatYearlyMonth) { mRepeatYearlyMonth = repeatYearlyMonth; }\n\n    public int getRepeatYearlyRelativeOrd() { return mRepeatYearlyRelativeOrd; }\n    public void setRepeatYearlyRelativeOrd(int repeatYearlyRelativeOrd) { mRepeatYearlyRelativeOrd = repeatYearlyRelativeOrd; }\n\n    public int getRepeatYearlyRelativeDay() { return mRepeatYearlyRelativeDay; }\n    public void setRepeatYearlyRelativeDay(int repeatYearlyRelativeDay) { mRepeatYearlyRelativeDay = repeatYearlyRelativeDay; }\n\n    public int getRepeatYearlyRelativeMonth() { return mRepeatYearlyRelativeMonth; }\n    public void setRepeatYearlyRelativeMonth(int repeatYearlyRelativeMonth) { mRepeatYearlyRelativeMonth = repeatYearlyRelativeMonth; }\n\n    public String getRepeatEndType() { return mRepeatEndType; }\n    public void setRepeatEndType(String repeatEndType) { mRepeatEndType = repeatEndType; }\n\n    public int getRepeatEndCount() { return mRepeatEndCount; }\n    public void setRepeatEndCount(int repeatEndCount) { mRepeatEndCount = repeatEndCount; }\n\n    public String getRepeatEndDate() { return mRepeatEndDate; }\n    public void setRepeatEndDate(String repeatEndDate) { mRepeatEndDate = repeatEndDate; }\n\n    public String getSendUID() { return mSendUID; }\n    public void setSendUID(String uid) { mSendUID = uid; }\n\n    public String getDescription() { return mDescription; }\n    public void setDescription(String desc) { mDescription = desc; }\n\n    public String getDescriptionHtml() { return mDescriptionHtml; }\n    public void setDescriptionHtml(String descHtml) { mDescriptionHtml = descHtml; }\n\n    public String getDecodedDescHtml() { return mDecodedDescHtml; }\n    public void setDecodedDescHtml(String descHtml) { mDecodedDescHtml = BeanUtils.htmlDecode(descHtml); }\n\n    public String paramInit(HttpServletRequest req, String name, String defaultValue) {\n        String value = req.getParameter(name);\n        return (value == null || value.length()==0) ? defaultValue : value;\n    }\n\n    public String getReminder1() {\n        return mReminder1;\n    }\n\n    public void setReminder1(String mReminder1) {\n        if (mReminder1 != null && mReminder1.length() == 0){\n            this.mReminder1 = null;\n        } else {\n            this.mReminder1 = mReminder1;\n        }\n    }\n\n    public String getReminder2() {\n        return mReminder2;\n    }\n\n    public void setReminder2(String mReminder2) {\n        if (mReminder2 != null && mReminder2.length() == 0){\n            this.mReminder2 = null;\n        } else {\n            this.mReminder2 = mReminder2;\n        }\n    }\n\n    public String getReminderEmail() {\n        return mReminderEmail;\n    }\n\n    public void setReminderEmail(String mReminderEmail) {\n        this.mReminderEmail = mReminderEmail;\n    }\n\n    public boolean isSendReminderEmail() {\n        return mSendReminderEmail;\n    }\n\n    public void setSendReminderEmail(boolean mSendReminderEmail) {\n        this.mSendReminderEmail = mSendReminderEmail;\n    }\n\n    public String getReminderMobile() {\n        return mReminderMobile;\n    }\n\n    public void setReminderMobile(String mReminderMobile) {\n        this.mReminderMobile = mReminderMobile;\n    }\n\n    public boolean isSendReminderMobile() {\n        return mSendReminderMobile;\n    }\n\n    public void setSendReminderMobile(boolean mSendReminderMobile) {\n        this.mSendReminderMobile = mSendReminderMobile;\n    }\n\n    public boolean isSendReminderYIM() {\n        return mSendReminderYIM;\n    }\n\n    public void setSendReminderYIM(boolean mSendReminderYIM) {\n        this.mSendReminderYIM = mSendReminderYIM;\n    }\n\n    public static class AppointmentOptions {\n\n        private Calendar mDate;\n        private String mInviteId;\n        private String mExceptionInviteId;\n        private boolean mUseInstance;\n        private boolean mIsTask;\n        private long mInstanceStartTime;\n        private long mInstanceDuration;\n\n        public Calendar getDate() {\n            return mDate;\n        }\n\n        public void setDate(Calendar date) {\n            mDate = date;\n        }\n\n        public String getInviteId() {\n            return mInviteId;\n        }\n\n        public void setInviteId(String inviteId) {\n            mInviteId = inviteId;\n        }\n\n        public String getExceptionInviteId() {\n            return mExceptionInviteId;\n        }\n\n        public void setExceptionInviteId(String exceptionInviteId) {\n            mExceptionInviteId = exceptionInviteId;\n        }\n\n        public boolean isUseInstance() {\n            return mUseInstance;\n        }\n\n        public void setUseInstance(boolean useInstance) {\n            mUseInstance = useInstance;\n        }\n\n        public boolean isTask() {\n            return mIsTask;\n        }\n\n        public void setIsTask(boolean isTask) {\n            mIsTask = isTask;\n        }\n\n        public long getInstanceStartTime() {\n            return mInstanceStartTime;\n        }\n\n        public void setInstanceStartTime(long instanceStartTime) {\n            mInstanceStartTime = instanceStartTime;\n        }\n\n        public long getInstanceDuration() {\n            return mInstanceDuration;\n        }\n\n        public void setInstanceDuration(long instanceDuration) {\n            mInstanceDuration = instanceDuration;\n        }\n\n\n    }\n\n    private ZEmailAddress getOrganizerEmailAddress(ZInvite inv) {\n        if (inv != null) {\n            ZComponent appt = inv.getComponent();\n            if (appt != null) {\n                ZOrganizer org = appt.getOrganizer();\n                if (org != null)\n                    return org.getEmailAddress();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * construct a message compose bean based on action and state.\n     * @param action what type of compose we are doing, must not be null.\n     * @param msg Message for reply/replyAll/forward\n     * @param mailbox mailbox object\n     * @param pc the JSP PageContext for localization information\n     * @throws com.zimbra.common.service.ServiceException on error\n     * @param options appointment options\n     */\n    public ZMessageComposeBean(Action action, ZMessageBean msg, ZMailbox mailbox, PageContext pc,\n                               AppointmentOptions options, Boolean isMobile) throws ServiceException {\n        HttpServletRequest req = (HttpServletRequest) pc.getRequest();\n\n        setDateFormat(I18nUtil.getLocalizedMessage(pc, \"CAL_APPT_EDIT_DATE_FORMAT\"));\n\n        Set<String> emailAddresses = mailbox.getAccountInfo(false).getEmailAddresses();\n        List<ZIdentity> identities = mailbox.getAccountInfo(false).getIdentities();\n\n        mSendUID = UUID.randomUUID().toString();\n        \n        if (msg != null) {\n            setMessageId(msg.getId());\n            ZMimePartBean body = msg.getBody();\n            if (body != null) {\n                setContenttype(body.getContentType());    \n            }\n        }\n\n        // compute identity\n        ZIdentity identity = action == Action.NEW ?\n                defaultIdentity(identities) :\n                computeIdentity(msg, identities);\n\n        switch (action) {\n            case INVITE_ACCEPT:\n            case INVITE_DECLINE:\n            case INVITE_TENTATIVE:\n            case REPLY:\n            case REPLY_ALL:\n                if (msg == null) break;\n                setSubject(getReplySubject(msg.getSubject(), pc)); // Subject:\n                List<ZEmailAddress> toAddressList = new ArrayList<ZEmailAddress>();\n                Set<String> toAddressSet = new HashSet<String>();\n                setTo(getToAddress(msg.getEmailAddresses(), toAddressList, toAddressSet, emailAddresses)); // To:\n                if (action == Action.REPLY_ALL) {\n                    setCc(getCcAddress(msg.getEmailAddresses(), toAddressSet, emailAddresses));   // Cc:\n                    if (mTo == null || mTo.length() == 0) {\n                        mTo = mCc;\n                        mCc= null;\n                    }\n\n                } else if (mTo == null || mTo.equals(\"\") &&\n                    (action == Action.INVITE_ACCEPT || action == Action.INVITE_DECLINE || action == Action.INVITE_TENTATIVE)) {\n                    ZInvite inv = msg.getInvite();\n                    if (inv != null) {\n                        ZComponent appt = inv.getComponent();\n                        if (appt != null) {\n                            ZOrganizer org = appt.getOrganizer();\n                            if (org != null)\n                                setTo(org.getEmailAddress().getFullAddressQuoted());\n                        }\n                    }\n                }\n                setInReplyTo(msg.getMessageIdHeader()); // original message-id header\n                setReplyType(\"r\");\n                break;\n            case FORWARD:\n                if (msg == null) break;\n                setSubject(getForwardSubject(msg.getSubject(), pc)); // Subject:\n                setReplyType(\"w\");\n                break;\n            case RESEND:\n                if (msg == null) break;\n                setSubject(msg.getSubject());\n                setTo(msg.getDisplayTo());\n                setCc(msg.getDisplayCc());\n                addAttachments(msg, true);\n                break;\n            case DRAFT:\n                if (msg == null) break;\n                setSubject(msg.getSubject());\n                setTo(msg.getDisplayTo());\n                setCc(msg.getDisplayCc());\n                setBcc(msg.getDisplayBcc());\n                addAttachments(msg, true);\n                if (msg.getInReplyTo() != null)\n                    setInReplyTo(msg.getInReplyTo());\n                if (msg.getReplyType() != null)\n                    setReplyType(msg.getReplyType());\n                break;\n            case APPT_NEW:\n                doNewAppt(mailbox, pc, options);\n                if (req.getParameter(\"body\") != null)\n                    setContent(req.getParameter(\"body\"));\n                // RETURN!\n                return;\n            case APPT_EDIT:\n                doEditAppt(msg, mailbox, pc, options);\n                addAttachments(msg, true);\n                if (msg != null) {\n                    ZMimePartBean body = msg.getBody();\n                    if (body != null) {\n                        String bodyContent = body.getContent();\n                        int i = bodyContent.lastIndexOf(NOTES_SEPARATOR);\n                        if (i > 0) {\n                            i += NOTES_SEPARATOR.length();\n                            int n = 0;\n                            while (n < 4 && i < bodyContent.length() && (bodyContent.charAt(i) == '\\r' || bodyContent.charAt(i) == '\\n')) {\n                                i++;\n                                n++;\n                            }\n                            bodyContent = bodyContent.substring(i);\n                        }\n                        setContent(bodyContent);\n                    }\n                }\n                // RETURN! No WAI! WAI! OK!\n                return;\n            case NEW:\n                setSubject(req.getParameter(\"subject\"));\n                setTo(req.getParameter(\"to\"));\n                setCc(req.getParameter(\"cc\"));\n                setBcc(req.getParameter(\"bcc\"));\n                break;\n            default:\n                break;\n        }\n\n        // setup body for invite reply\n        if (action == Action.INVITE_ACCEPT || action == Action.INVITE_DECLINE || action == Action.INVITE_TENTATIVE) {\n            switch (action) {\n                case INVITE_ACCEPT:\n                    setInviteReplyVerb(ReplyVerb.ACCEPT.name());\n                    setContent(I18nUtil.getLocalizedMessage(pc, \"defaultInviteReplyAcceptMessage\"));\n                    break;\n                case INVITE_DECLINE:\n                    setInviteReplyVerb(ReplyVerb.DECLINE.name());\n                    setContent(I18nUtil.getLocalizedMessage(pc, \"defaultInviteReplyDeclineMessage\"));\n                    break;\n                case INVITE_TENTATIVE:\n                    setInviteReplyVerb(ReplyVerb.TENTATIVE.name());\n                    setContent(I18nUtil.getLocalizedMessage(pc, \"defaultInviteReplyTentativeMessage\"));\n                    break;\n            }\n            setInviteReplyInst(getParamLong(req.getParameter(\"inviteReplyInst\"), 0));\n            setInviteReplyAllDay(\"1\".equals(req.getParameter(\"inviteReplyAllDay\")));\n            setCompNum(req.getParameter(\"compNum\"));\n            setInstanceCompNum(req.getParameter(\"instCompNum\"));\n        }\n\n        if (identity == null)\n            return;\n\n        // Reply-to:\n        if (identity.getReplyToEnabled()) {\n            setReplyTo(identity.getReplyToEmailAddress().getFullAddress());\n        }\n\n        // from\n        setFrom(identity.getFromEmailAddress().getFullAddress());\n\n        if (action == Action.RESEND || action == Action.DRAFT) {\n            if (msg != null) {\n                ZMimePartBean body = msg.getBody();\n                setContent(body == null ? \"\" : body.getContent());\n            }\n            return;\n        }\n\n        // signature\n        ZSignature zsignature = mailbox.getAccountInfo(false).getSignature(identity.getSignatureId()) ;\n\n        String signature = zsignature != null ? zsignature.getValue() : null;\n        \n        boolean signatureTop = mailbox.getPrefs().getSignatureStyleTop();\n\n        StringBuilder content = new StringBuilder();\n\n        if (getContent() != null) {\n            content.append(getContent());\n        }\n        String composeFormat = mailbox.getPrefs().getComposeFormat();\n        Boolean isText = composeFormat.equals(\"text\");\n        if((action == Action.REPLY || action == Action.REPLY_ALL || action == Action.INVITE_ACCEPT || action == Action.INVITE_DECLINE ||\n                action == Action.INVITE_TENTATIVE || action == Action.FORWARD) && mailbox.getPrefs().getForwardReplyInOriginalFormat()){\n            if (getContentType() != null) {isText = getContentType().equals(\"text/plain\");} \n        }\n        // Compose in mobile interface is always in text/plain. Decode the HTML signatures, if any.\n        if((isText || isMobile) && zsignature != null && (zsignature.getType().equals(\"text/html\"))){\n           signature = BeanUtils.htmlDecode(signature);\n        }\n        if (signatureTop && signature != null && signature.length() > 0)\n            content.append(\"\\n\\n\\n\").append(signature);\n\n        if (action == Action.REPLY || action == Action.REPLY_ALL ||\n                action == Action.INVITE_ACCEPT || action == Action.INVITE_DECLINE || action == Action.INVITE_TENTATIVE)\n            replyInclude(msg, content, mailbox.getPrefs(), pc, isText);\n        else if (action == Action.FORWARD)\n            forwardInclude(msg, content, mailbox.getPrefs(), pc, isText);\n        else if (action == Action.NEW && req.getParameter(\"body\") != null)\n            content.append(req.getParameter(\"body\"));\n\n        if (!signatureTop && signature != null && signature.length() > 0) {\n            if (content.length() == 0)\n                content.append(\"\\n\\n\\n\");\n            content.append(\"-- \\n\").append(signature);\n        }\n\n        setContent(content.toString());\n    }\n\n    @SuppressWarnings({\"EmptyCatchBlock\"})\n    public long getParamLong(String value, long defaultValue) {\n        if (value != null)\n            try { return Long.parseLong(value); } catch (NumberFormatException e) {}\n        return defaultValue;\n    }\n\n    public ZSimpleRecurrence getSimpleRecurrence() throws ServiceException {\n        ZSimpleRecurrence repeat = new ZSimpleRecurrence(null);\n\n        if (getRepeatType() == null || getRepeatType().length() == 0)\n            return repeat;\n        \n        boolean basic = RT_BASIC.equals(getRepeatType());\n\n        ZSimpleRecurrenceType type =\n                ZSimpleRecurrenceType.fromString(basic ? getRepeatBasicType() : getRepeatType());\n        repeat.setType(type);\n\n        if (basic) {\n            repeat.setEnd(ZSimpleRecurrenceEnd.NEVER);\n            return repeat;\n        }\n\n        repeat.setEnd(ZSimpleRecurrenceEnd.fromString(getRepeatEndType()));\n\n        switch(repeat.getEnd()) {\n            case NEVER:\n                break;\n            case COUNT:\n                repeat.setCount(getRepeatEndCount());\n                break;\n            case UNTIL:\n                repeat.setUntilDate(new ZDateTime(getRepeatEndDateTime(), mTimeZone));\n                break;\n        }\n\n        switch(type) {\n            case COMPLEX:\n                break;\n            case NONE:\n                break;\n            case DAILY:\n                break;\n            case DAILY_INTERVAL:\n                repeat.setDailyInterval(getRepeatDailyInterval());\n                break;\n            case DAILY_WEEKDAY:\n                break;\n            case WEEKLY:\n                break;\n            case WEEKLY_BY_DAY:\n                repeat.setWeeklyByDay(ZWeekDay.fromOrdinal(getRepeatWeeklyByDay()));\n                break;\n            case WEEKLY_CUSTOM:\n                repeat.setWeeklyInterval(getRepeatWeeklyInterval());\n                List<ZWeekDay> weeklyDays = new ArrayList<ZWeekDay>();\n                if (isRepeatWeeklySun()) weeklyDays.add(ZWeekDay.SU);\n                if (isRepeatWeeklyMon()) weeklyDays.add(ZWeekDay.MO);\n                if (isRepeatWeeklyTue()) weeklyDays.add(ZWeekDay.TU);\n                if (isRepeatWeeklyWed()) weeklyDays.add(ZWeekDay.WE);\n                if (isRepeatWeeklyThu()) weeklyDays.add(ZWeekDay.TH);\n                if (isRepeatWeeklyFri()) weeklyDays.add(ZWeekDay.FR);\n                if (isRepeatWeeklySat()) weeklyDays.add(ZWeekDay.SA);\n                repeat.setWeeklyIntervalDays(weeklyDays);\n                break;\n            case MONTHLY:\n                break;\n            case MONTHLY_BY_MONTH_DAY:\n                repeat.setMonthlyInterval(getRepeatMonthlyInterval());\n                repeat.setMonthlyMonthDay(getRepeatMonthlyMonthDay());\n                break;\n            case MONTHLY_RELATIVE:\n                repeat.setMonthlyInterval(getRepeatMonthlyInterval());\n                ZByDayWeekDay mday = new ZByDayWeekDay();\n                mday.setDay(ZWeekDay.fromOrdinal(getRepeatWeeklyByDay()));\n                mday.setWeekOrd(getRepeatMonthlyRelativeOrd());\n                repeat.setMonthlyRelativeDay(mday);\n                break;\n            case YEARLY:\n                break;\n            case YEARLY_BY_DATE:\n                repeat.setYearlyByDateMonth(getRepeatYearlyMonth());\n                repeat.setYearlyByDateMonthDay(getRepeatYearlyMonthDay());\n                break;\n            case YEARLY_RELATIVE:\n                repeat.setYearlyRelativeMonth(getRepeatYearlyRelativeMonth());\n                ZByDayWeekDay yday = new ZByDayWeekDay();\n                yday.setDay(ZWeekDay.fromOrdinal(getRepeatYearlyRelativeDay()));\n                yday.setWeekOrd(getRepeatYearlyRelativeOrd());\n                repeat.setYearlyRelativeDay(yday);\n                break;\n        }\n        return repeat;\n    }\n\n    public void initRepeat(ZSimpleRecurrence repeat, Date date, PageContext pc, ZMailbox mailbox) throws ServiceException {\n\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(date);\n\n        setRepeatDailyInterval(repeat.getDailyInterval() > 0 ? repeat.getDailyInterval() :  1);\n\n        setRepeatWeeklyByDay(repeat.getWeeklyByDay() != null ? repeat.getWeeklyByDay().getOrdinal() : cal.get(Calendar.DAY_OF_WEEK)-1);\n\n        setRepeatWeeklyInterval(repeat.getWeeklyInterval() > 0 ? repeat.getWeeklyInterval() : 1);\n\n        if (repeat.getWeeklyIntervalDays() != null) {\n            for (ZWeekDay day : repeat.getWeeklyIntervalDays()) {\n                switch(day) {\n                    case SU: setRepeatWeeklySun(true); break;\n                    case MO: setRepeatWeeklyMon(true); break;\n                    case TU: setRepeatWeeklyTue(true); break;\n                    case WE: setRepeatWeeklyWed(true); break;\n                    case TH: setRepeatWeeklyThu(true); break;\n                    case FR: setRepeatWeeklyFri(true); break;\n                    case SA: setRepeatWeeklySat(true); break;\n                }\n            }\n        }\n\n        setRepeatMonthlyMonthDay(repeat.getMonthlyMonthDay() > 0 ? repeat.getMonthlyMonthDay() : cal.get(Calendar.DAY_OF_MONTH));\n        setRepeatMonthlyInterval(repeat.getMonthlyInterval() > 0 ? repeat.getMonthlyInterval() : 1);\n\n        int dom = cal.get(Calendar.DAY_OF_MONTH);\n\n        int dayOrd = ((dom-1)/7) + 1;\n        if (dayOrd > 4) dayOrd = -1;\n\n        ZByDayWeekDay day = repeat.getMonthlyRelativeDay();\n        setRepeatMonthlyRelativeOrd(day == null ? dayOrd : day.getWeekOrd());\n        setRepeatMonthlyRelativeDay(day == null ? cal.get(Calendar.DAY_OF_WEEK)-1 : day.getDay().getOrdinal());\n        setRepeatMonthlyRelativeInterval(repeat.getMonthlyInterval() > 0 ? repeat.getMonthlyInterval() : 1);\n\n        setRepeatYearlyMonth(repeat.getYearlyByDateMonth() != 0 ? repeat.getYearlyByDateMonth() : cal.get(Calendar.MONTH)+1);\n        setRepeatYearlyMonthDay(repeat.getYearlyByDateMonthDay() != 0 ? repeat.getYearlyByDateMonthDay() :  cal.get(Calendar.DAY_OF_MONTH));\n\n        ZByDayWeekDay relDay = repeat.getYearlyRelativeDay();\n        setRepeatYearlyRelativeOrd(relDay == null ? dayOrd : relDay.getWeekOrd());\n        setRepeatYearlyRelativeDay(relDay == null ? cal.get(Calendar.DAY_OF_WEEK)-1 : relDay.getDay().getOrdinal());\n        setRepeatYearlyRelativeMonth(repeat.getYearlyRelativeMonth() > 0 ? repeat.getYearlyRelativeMonth() :  cal.get(Calendar.MONTH)+1);\n\n        setRepeatEndCount((int)(repeat.getCount() > 0 ? repeat.getCount() : 1));\n        \n        Date endDate = repeat.getUntilDate() != null ? repeat.getUntilDate().getDate() : date;\n        DateFormat df = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, \"CAL_APPT_EDIT_DATE_FORMAT\"));\n        df.setTimeZone(mailbox.getPrefs().getTimeZone());\n        setRepeatEndDate(df.format(endDate));\n        setRepeatEndType(repeat.getEnd().name());\n\n        setRepeatType(repeat.getType().name());\n        setRepeatBasicType(ZSimpleRecurrenceType.DAILY.name());\n\n        if (repeat.getType().isNone()) return;\n\n        ZSimpleRecurrenceType type = repeat.getType();\n\n        if ((type.isDaily() && repeat.getEnd() == ZSimpleRecurrenceEnd.NEVER) ||\n                type.isWeekly() || type.isMonthly() || type.isYearly()) {\n            setRepeatType(RT_BASIC);\n            setRepeatBasicType(type.name());\n        } else {\n            setRepeatType(type.name());\n        }\n\n    }\n\n    private void doNewAppt(ZMailbox mailbox, PageContext pc, AppointmentOptions options) throws ServiceException {\n        HttpServletRequest req = (HttpServletRequest) pc.getRequest();\n        \n        setSubject(req.getParameter(ZComposeUploaderBean.F_subject));\n        setLocation(req.getParameter(ZComposeUploaderBean.F_location));\n        setAllDay(\"1\".equals(req.getParameter(ZComposeUploaderBean.F_allDay)));\n        setAttendees(req.getParameter(ZComposeUploaderBean.F_attendees));\n        setResources(req.getParameter(ZComposeUploaderBean.F_resources));\n        setFreeBusyStatus(paramInit(req, ZComposeUploaderBean.F_freeBusyStatus, ZInvite.ZFreeBusyStatus.B.name()));\n        setTimeZone(paramInit(req, ZComposeUploaderBean.F_timeZone, mailbox.getPrefs().getTimeZoneId()));\n        setApptFolderId(ZFolder.ID_CALENDAR);\n        if (options.isTask()) {\n            setApptFolderId(ZFolder.ID_TASKS);\n            setTaskPercentComplete(\"0\");\n            setTaskPriority(\"5\");\n            setTaskStatus(ZInvite.ZStatus.NEED.name());\n        }\n        Calendar calendar = options.getDate() != null ? options.getDate() : BeanUtils.getCalendar(System.currentTimeMillis(), mailbox.getPrefs().getTimeZone());\n        DateFormat df = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, \"CAL_APPT_EDIT_DATE_FORMAT\"));\n        df.setTimeZone(mailbox.getPrefs().getTimeZone());\n        String dateStr = df.format(calendar.getTime());\n        int hour = calendar.get(Calendar.HOUR_OF_DAY);\n        setStartDate(paramInit(req, ZComposeUploaderBean.F_startDate, dateStr));\n        setStartHour(Long.parseLong(paramInit(req, ZComposeUploaderBean.F_startHour, Integer.toString(hour))));\n        setStartMinute(Long.parseLong(paramInit(req, ZComposeUploaderBean.F_startMinute, \"0\")));\n\n        // add one hour to current time\n        calendar.add(Calendar.HOUR_OF_DAY, 1);\n\n        dateStr = df.format(calendar.getTime());\n        hour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        setEndDate(paramInit(req, ZComposeUploaderBean.F_endDate, dateStr));\n        setEndHour(Long.parseLong(paramInit(req, ZComposeUploaderBean.F_endHour, Integer.toString(hour))));\n        setEndMinute(Long.parseLong(paramInit(req, ZComposeUploaderBean.F_endMinute, \"0\")));\n\n        initRepeat(new ZSimpleRecurrence(null), calendar.getTime(), pc, mailbox);\n    }\n\n    private void doEditAppt(ZMessageBean msg, ZMailbox mailbox, PageContext pc, AppointmentOptions options) throws ServiceException {\n        HttpServletRequest req = (HttpServletRequest) pc.getRequest();\n        ZComponent appt = msg.getInvite().getComponent();\n\n        setUseInstance(options.isUseInstance());\n        setInviteId(options.getInviteId());\n        setExceptionInviteId(options.getExceptionInviteId());\n        setInstanceDuration(options.getInstanceDuration());\n        setInstanceStartTime(options.getInstanceStartTime());\n        setApptFolderId(msg.getFolderId());\n\n        setSubject(appt.getName());\n        setLocation(appt.getLocation());\n\n        setAllDay(appt.isAllDay());\n\n        if (!appt.getAttendees().isEmpty()) {\n            StringBuilder sb = new StringBuilder();\n            StringBuilder rs = new StringBuilder();\n            for (ZAttendee attendee : appt.getAttendees()) {\n                if(attendee.getCalendarUserType().isResource()){\n                    if (rs.length() > 0) rs.append(\", \");\n                    rs.append(attendee.getEmailAddress().getFullAddress());\n                }else{\n                    if (sb.length() > 0) sb.append(\", \");\n                    sb.append(attendee.getEmailAddress().getFullAddress());\n                }\n            }\n            setAttendees(sb.toString());\n            setResources(rs.toString());\n        }\n\n        setClassProp(appt.getClassProp().name());\n\n        DateFormat df = new SimpleDateFormat(I18nUtil.getLocalizedMessage(pc, \"CAL_APPT_EDIT_DATE_FORMAT\"));\n\n        setRecurrenceIdZ(appt.getRecurrenceIdZ());\n\n        if (options.isTask()) {\n            setTaskPercentComplete(appt.getPercentCompleted());\n            setTaskPriority(appt.getPriority());\n            setTaskStatus(appt.getStatus().name());\n            if(appt.getOrganizer() != null)\n                setOrigOrganizer(appt.getOrganizer().getAddress());\n\n            String tz = appt.getStart() != null ? appt.getStart().getTimeZoneId() : null;\n            setTimeZone(tz == null ? mailbox.getPrefs().getTimeZoneId() : TZIDMapper.canonicalize(tz));\n            TimeZone apptTz = TimeZone.getTimeZone(TZIDMapper.canonicalize(getTimeZone()));\n            if (apptTz != null) \n                df.setTimeZone(apptTz);\n\n            if (appt.getStart() != null) {\n                Date startDate = appt.getStart().getDate();\n                setStartDate(paramInit(req, ZComposeUploaderBean.F_startDate, df.format(startDate)));\n            }\n            if (appt.getEnd() != null) {\n                Date endDate = appt.getEnd().getDate();\n                setEndDate(paramInit(req, ZComposeUploaderBean.F_endDate, df.format(endDate)));\n            }\n\n        } else {\n\n            setFreeBusyStatus(appt.getFreeBusyStatus().name());\n            String tz = appt.getStart() != null ? appt.getStart().getTimeZoneId() : null;\n            setTimeZone(appt.isAllDay() ? mailbox.getPrefs().getTimeZoneId() : tz == null ? tz : TZIDMapper.canonicalize(tz)); //paramInit(req, ZComposeUploaderBean.F_timeZone, mailbox.getPrefs().getTimeZonenId()));\n\n            TimeZone apptTz = TimeZone.getTimeZone((TZIDMapper.canonicalize(getTimeZone())));\n\n            if (appt.isAllDay()) {\n                ZDateTime st = appt.getStart();\n                if (st != null && st.getHasNoTimeZone()) st.setTimeZoneId(apptTz.getID());\n                ZDateTime et = appt.getEnd();\n                if (et != null && et.getHasNoTimeZone()) et.setTimeZoneId(apptTz.getID());\n            }\n\n            Date startDate = getUseInstance() ? new Date(getInstanceStartTime()) : appt.getStart() == null ? null :  appt.getStart().getDate();\n\n            Calendar startCalendar = Calendar.getInstance(apptTz);\n            if (startDate != null) startCalendar.setTime(startDate);\n\n            df.setTimeZone(apptTz);\n\n            if (startDate != null)\n                setStartDate(paramInit(req, ZComposeUploaderBean.F_startDate, df.format(startDate)));\n\n            if (appt.isAllDay()) {\n                setStartHour(0);\n                setStartMinute(0);\n            } else if (startDate != null) {\n                setStartHour(startCalendar.get(Calendar.HOUR_OF_DAY));\n                setStartMinute(startCalendar.get(Calendar.MINUTE));\n            }\n\n            Date endDate = getUseInstance() ? new Date(getInstanceStartTime() + getInstanceDuration()) : appt.getComputedEndDate();\n            Calendar endCalendar = Calendar.getInstance(apptTz);\n            endCalendar.setTime(endDate);\n            if (getUseInstance() && appt.isAllDay()) {\n              endCalendar.add(Calendar.DATE, -1);\n              endDate = endCalendar.getTime();\n            }\n\n            setEndDate(paramInit(req, ZComposeUploaderBean.F_endDate, df.format(endDate)));\n\n            if (appt.isAllDay()) {\n                setEndHour(0);\n                setEndMinute(0);\n            } else {\n                setEndHour(endCalendar.get(Calendar.HOUR_OF_DAY));\n                setEndMinute(endCalendar.get(Calendar.MINUTE));\n            }\n            initRepeat(appt.getSimpleRecurrence(), startDate, pc, mailbox);\n            initReminders(appt.getAlarms());\n        }\n\n        if(appt.getIsNoBlob()) {\n            setDescription(appt.getDescription());\n            setDescriptionHtml(appt.getDescriptionHtml());\n            setDecodedDescHtml(BeanUtils.htmlDecode(appt.getDescriptionHtml()));\n        }\n    }\n\n    private void initReminders(List<ZAlarm> alarms){\n        for (ZAlarm alarm : alarms){\n            ZAlarm.ZAction action = alarm.getAction();\n            if (action.equals(ZAlarm.ZAction.EMAIL)){\n                this.mReminderEmail = alarm.getAttendees().get(0).getAddress();\n                this.mSendReminderEmail = true;\n            } else if (action.equals(ZAlarm.ZAction.X_YAHOO_CALENDAR_ACTION_IM)){\n                this.mSendReminderYIM = true;\n            } else if (action.equals(ZAlarm.ZAction.X_YAHOO_CALENDAR_ACTION_MOBILE)){\n                this.mReminderMobile = alarm.getAttendees().get(0).getAddress();\n                this.mSendReminderMobile = true;\n            }\n            String duration = alarm.getTriggerRelated().toString();\n            if (this.mReminder1 == null ||\n                this.mReminder2 == null){\n                if (this.mReminder1 == null){\n                    this.mReminder1 = duration;\n                } else if (!this.mReminder1.equalsIgnoreCase(duration)){\n                    this.mReminder2 = duration;\n                }\n            }\n        }\n    }\n\n    private String getQuotedHeaders(ZMessageBean msg, PageContext pc) {\n        StringBuilder headers = new StringBuilder();\n        //from, to, cc, date, subject\n        String fromHdr = msg.getDisplayFrom();\n        if (fromHdr != null)\n            headers.append(I18nUtil.getLocalizedMessage(pc, \"ZM_HEADER_FROM\")).append(\": \").append(fromHdr).append(CRLF);\n        String toHdr = msg.getDisplayTo();\n        if (toHdr != null)\n            headers.append(I18nUtil.getLocalizedMessage(pc, \"ZM_HEADER_TO\")).append(\": \").append(toHdr).append(CRLF);\n         String ccHdr = msg.getDisplayCc();\n        if (ccHdr != null)\n            headers.append(I18nUtil.getLocalizedMessage(pc, \"ZM_HEADER_CC\")).append(\": \").append(ccHdr).append(CRLF);\n\n        headers.append(I18nUtil.getLocalizedMessage(pc, \"ZM_HEADER_SENT\")).append(\": \").append(msg.getDisplaySentDate()).append(CRLF);\n\n        String subjectHdr = msg.getSubject();\n        if (subjectHdr != null)\n            headers.append(I18nUtil.getLocalizedMessage(pc, \"ZM_HEADER_SUBJECT\")).append(\": \").append(subjectHdr).append(CRLF);\n        return headers.toString();\n    }\n\n    private String getQuotedDisplay(ZMessageBean msg) {\n        String org = msg.getDisplayFrom();\n        if (org == null) {\n            ZEmailAddress addr = getOrganizerEmailAddress(msg.getInvite());\n            if (addr != null) {\n                return addr.getFullAddressQuoted();\n            }\n        }\n        return org;\n    }\n\n    private void forwardInclude(ZMessageBean msg, StringBuilder content, ZPrefs prefs, PageContext pc, boolean isText) {\n        if (prefs.getForwardIncludeAsAttachment()) {\n            mMessageAttachments = new ArrayList<MessageAttachment>();\n            mMessageAttachments.add(new MessageAttachment(msg.getId(), msg.getSubject()));\n        } else if (prefs.getForwardIncludeBody()) {\n            content.append(CRLF).append(CRLF).append(I18nUtil.getLocalizedMessage(pc, \"ZM_forwardedMessage\")).append(CRLF);\n            String qHdr = getQuotedHeaders(msg, pc);\n            if(!isText) { qHdr = BeanUtils.htmlEncode(qHdr); }\n            content.append(qHdr).append(CRLF);\n            ZMimePartBean body = msg.getBody();\n            content.append(body == null ? \"\" : body.getContent());\n            content.append(CRLF);\n            addAttachments(msg, true);\n        } else if (prefs.getForwardIncludeBodyWithPrefx()) {\n            String org = getQuotedDisplay(msg);\n            if(!isText) { org = BeanUtils.htmlEncode(getQuotedDisplay(msg)); }\n            content.append(CRLF).append(CRLF).append(I18nUtil.getLocalizedMessage(pc, \"ZM_forwardPrefix\", new Object[] {org})).append(CRLF);\n            content.append(getQuotedBody(msg, prefs));\n            content.append(CRLF);\n            addAttachments(msg, true);\n        }\n    }\n\n    private void replyInclude(ZMessageBean msg, StringBuilder content, ZPrefs prefs, PageContext pc, boolean isText) {\n        if (prefs.getReplyIncludeNone()) {\n            // nothing to see, move along\n        } else if (prefs.getReplyIncludeBody()) {\n            content.append(CRLF).append(CRLF).append(I18nUtil.getLocalizedMessage(pc, \"ZM_originalMessage\")).append(CRLF);\n            String qHdr = getQuotedHeaders(msg, pc);\n            if(!isText) { qHdr = BeanUtils.htmlEncode(qHdr); }\n            content.append(qHdr).append(CRLF);\n            ZMimePartBean body = msg.getBody();\n            content.append(body == null ? \"\" : body.getContent());\n            content.append(CRLF);\n            addAttachments(msg, false);\n        } else if (prefs.getReplyIncludeBodyWithPrefx()) {\n            String org = getQuotedDisplay(msg);\n            if(!isText) { org = BeanUtils.htmlEncode(getQuotedDisplay(msg)); }\n            content.append(CRLF).append(CRLF).append(I18nUtil.getLocalizedMessage(pc, \"ZM_replyPrefix\", new Object[] {org})).append(CRLF);\n            content.append(getQuotedBody(msg, prefs));\n            content.append(CRLF);\n            addAttachments(msg, false);\n        } else if (prefs.getReplyIncludeSmart()) {\n            // TODO: duh\n        } else if (prefs.getReplyIncludeAsAttachment()) {\n            mMessageAttachments = new ArrayList<MessageAttachment>();\n            mMessageAttachments.add(new MessageAttachment(msg.getId(), msg.getSubject()));\n        }\n    }\n\n    private void addAttachments(ZMessageBean msg, boolean checked) {\n        List<ZMimePartBean> attachments = msg.getAttachments();\n        setOrignalAttachments(attachments);\n        if (checked) {\n            for (ZMimePartBean part : attachments) {\n                setCheckedAttachmentName(part.getPartName(),(part.getContentId() == null || part.getContentId().equals(\"\") ? \"true\" : part.getContentId()));\n            }\n        }\n    }\n\n    private String getQuotedBody(ZMessageBean msg, ZPrefs prefs) {\n        if (msg == null) return \"\";\n        String prefixChar = prefs.getForwardReplyPrefixChar();\n        prefixChar = (prefixChar == null) ? \"> \" : prefixChar + \" \";\n        ZMimePartBean body = msg.getBody();\n        return body == null ? \"\" : BeanUtils.prefixContent(body.getContent(), prefixChar);\n    }\n\n    private ZIdentity computeIdentity(ZMessageBean msg, List<ZIdentity> identities) {\n\n        if (identities.size() == 1)\n            return identities.get(0);\n\n        if (msg == null)\n            return defaultIdentity(identities);\n\n        List<ZEmailAddress> addressList = new ArrayList<ZEmailAddress>();\n        for (ZEmailAddress address: msg.getEmailAddresses()) {\n            if (ZEmailAddress.EMAIL_TYPE_TO.equals(address.getType()) ||\n                    ZEmailAddress.EMAIL_TYPE_CC.equals(address.getType())) {\n                addressList.add(address);\n            }\n        }\n\n        String folderId = msg.getFolderId();\n        \n        for (ZIdentity identity: identities) {\n            if (identity.containsFolderId(folderId))\n                return identity;\n        }\n\n        return defaultIdentity(identities);\n        \n    }\n\n    private ZIdentity defaultIdentity(List<ZIdentity> identities) {\n        if (identities.size() == 1)\n            return identities.get(0);\n        \n        for (ZIdentity identity: identities) {\n            if (identity.isDefault())\n                return identity;\n        }\n        return identities.get(0);\n    }\n\n\n    private static String getReplySubject(String subject, PageContext pc) {\n        String REPLY_PREFIX = I18nUtil.getLocalizedMessage(pc, \"ZM_replySubjectPrefix\");\n        if (subject == null) subject = \"\";\n        if ((subject.length() > 3) && subject.substring(0, 3).equalsIgnoreCase(REPLY_PREFIX))\n            return subject;\n        else\n            return REPLY_PREFIX+\" \"+subject;\n    }\n\n    private static String getForwardSubject(String subject, PageContext pc) {\n        String FORWARD_PREFIX = I18nUtil.getLocalizedMessage(pc, \"ZM_forwardSubjectPrefix\");\n        if (subject == null) subject = \"\";\n        if ((subject.length() > 3) && subject.substring(0, 3).equalsIgnoreCase(FORWARD_PREFIX))\n            return subject;\n        else\n            return FORWARD_PREFIX+\" \"+subject;\n    }\n\n    private static String getToAddress(List<ZEmailAddress> emailAddresses, List<ZEmailAddress> toAddressList, Set<String> toAddresses, Set<String> aliases) {\n        for (ZEmailAddress address : emailAddresses) {\n            if (ZEmailAddress.EMAIL_TYPE_REPLY_TO.equals(address.getType())) {\n               if (aliases.contains(address.getAddress().toLowerCase()))\n                    return \"\";\n                toAddresses.add(address.getAddress());\n                toAddressList.add(address);\n                return address.getFullAddress();\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        ZEmailAddress selfAddress = null;\n        for (ZEmailAddress address : emailAddresses) {\n            if (ZEmailAddress.EMAIL_TYPE_FROM.equals(address.getType())) {\n                if (!aliases.contains(address.getAddress().toLowerCase())) {\n                    if (sb.length() > 0) sb.append(\", \");\n                    sb.append(address.getFullAddress());\n                    toAddressList.add(address);\n                    toAddresses.add(address.getAddress());\n                }else{\n                selfAddress = address;\n                }\n            }\n        }\n        if(sb.length() == 0 && selfAddress != null){\n            sb.append(selfAddress.getFullAddress());\n            toAddressList.add(selfAddress);\n            toAddresses.add(selfAddress.getAddress());\n        }\n        return sb.toString();\n    }\n\n    private static String getCcAddress(List<ZEmailAddress> emailAddresses, Set<String> toAddresses, Set<String> aliases) {\n        StringBuilder sb = new StringBuilder();\n        for (ZEmailAddress address : emailAddresses) {\n            if (ZEmailAddress.EMAIL_TYPE_TO.equals(address.getType()) ||\n                    ZEmailAddress.EMAIL_TYPE_CC.equals(address.getType())) {\n                String a = address.getAddress().toLowerCase();\n                if (!toAddresses.contains(a) && !aliases.contains(a) ) {\n                    if (sb.length() > 0) sb.append(\", \");\n                    sb.append(address.getFullAddress());\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    /*\n\n     <comp status=\"CONF\" fb=\"B\" transp=\"O\" allDay=\"0\" name=\"test yearly\">\n    <s tz=\"(GMT-08.00) Pacific Time (US &amp; Canada)\" d=\"20070308T130000\"/>\n    <e tz=\"(GMT-08.00) Pacific Time (US &amp; Canada)\" d=\"20070308T150000\"/>\n      <or a=\"user1@slapshot.liquidsys.com\"/>\n       <recur>\n        <add>\n         <rule freq=\"YEA\">\n            <interval ival=\"1\"/>\n         </rule>\n        </add>\n      </recur>\n    </comp></inv>\n\n     */\n    public List<ZEmailAddress> getAttendeesAddrs() throws ServiceException{\n        if (mAttendees != null && mAttendees.length() > 0) {\n            return ZEmailAddress.parseAddresses(mAttendees, ZEmailAddress.EMAIL_TYPE_TO);\n        }\n        return null;\n    }\n\n    public List<ZEmailAddress> getResourcesAddrs() throws ServiceException{\n        if (mResources != null && mResources.length() > 0) {\n            return ZEmailAddress.parseAddresses(mResources, ZEmailAddress.EMAIL_TYPE_TO);\n        }\n        return null;\n    }\n\n    public ZInvite toInvite(ZMailbox mailbox, ZMessageBean message) throws ServiceException {\n        ZInvite existingInvite = message != null ? message.getInvite() : null;\n        ZInvite invite = new ZInvite();\n        ZInvite.ZComponent comp = new ZComponent();\n\n        comp.setStatus(ZStatus.CONF);\n        comp.setClassProp(getClassProp() != null ? ZClass.fromString(getClassProp()) : ZClass.PUB);\n\n        if (getTaskPercentComplete() != null)\n            comp.setPercentCompleted(getTaskPercentComplete());\n\n        if (getTaskPriority() != null)\n            comp.setPriority(getTaskPriority());\n        \n        if (getTaskStatus() != null) comp.setStatus(ZStatus.fromString(getTaskStatus()));\n        \n        comp.setTransparency(ZTransparency.O);\n        if (mFreeBusyStatus != null) comp.setFreeBusyStatus(ZFreeBusyStatus.fromString(mFreeBusyStatus));\n\n        if (mTimeZone == null || mTimeZone.length() == 0)\n            mTimeZone = mailbox.getPrefs().getTimeZoneCanonicalId();\n        if (getStartDate() != null && getStartDate().length() > 0)\n            comp.setStart(new ZDateTime(getApptStartTime(), mTimeZone));\n        if (getEndDate() != null && getEndDate().length() > 0)\n            comp.setEnd(new ZDateTime(getApptEndTime(), mTimeZone));\n        \n        if (mLocation != null && mLocation.length() > 0) comp.setLocation(mLocation);\n        comp.setName(mSubject);\n        \n        List<ZIdentity> identities = mailbox.getAccountInfo(false).getIdentities();\n        String organizerEmail = null;\n        for (ZIdentity i : identities) {\n        \tif (i.isDefault()) \n        \t\torganizerEmail = i.getFromAddress();\n        }\n        \n        if (organizerEmail == null) {\n        \tthrow ServiceException.FAILURE(\"Default identity not found\", null);\n        }\n\n        String origOrganizer = getOrigOrganizer();\n        if (origOrganizer == null || origOrganizer.length()==0 || origOrganizer.equalsIgnoreCase(organizerEmail)) {\n            comp.setOrganizer(new ZOrganizer(organizerEmail));\n        } else {\n            ZOrganizer zo = new ZOrganizer(origOrganizer);\n            zo.setSentBy(organizerEmail);\n            comp.setOrganizer(zo);\n        }\n\n        comp.setIsAllDay(getAllDay());\n\n        if (mAttendees != null && mAttendees.length() > 0) {\n            List<ZEmailAddress> addrs =\n                    ZEmailAddress.parseAddresses(mAttendees, ZEmailAddress.EMAIL_TYPE_TO);\n            for (ZEmailAddress addr : addrs) {\n                ZAttendee attendee = new ZAttendee();\n                attendee.setAddress(addr.getAddress());\n                attendee.setRole(ZRole.REQ);\n                attendee.setParticipantStatus(ZParticipantStatus.NE);\n                attendee.setRSVP(true);\n                if (addr.getPersonal() != null) attendee.setPersonalName(addr.getPersonal());\n                comp.getAttendees().add(attendee);\n            }\n        }\n        if (mResources != null && mResources.length() > 0) {\n            List<ZEmailAddress> addrs =\n                    ZEmailAddress.parseAddresses(mResources, ZEmailAddress.EMAIL_TYPE_TO);\n            for (ZEmailAddress addr : addrs) {\n                ZAttendee attendee = new ZAttendee();\n                attendee.setAddress(addr.getAddress());\n                attendee.setRole(ZRole.NON);\n                attendee.setCalendarUserType(ZInvite.ZCalendarUserType.RES);\n                attendee.setParticipantStatus(ZParticipantStatus.NE);\n                attendee.setRSVP(true);\n                if (addr.getPersonal() != null) attendee.setPersonalName(addr.getPersonal());\n                comp.getAttendees().add(attendee);\n            }\n        }\n        invite.getComponents().add(comp);\n        ZComponent ecomp = existingInvite != null ? existingInvite.getComponent() : null;\n\n\n        // don't set recurrence for exceptions\n        if (!getUseInstance()) {\n            ZSimpleRecurrence repeat = getSimpleRecurrence();\n            switch(repeat.getType()) {\n                case NONE:\n                    break;\n                case COMPLEX:\n                    // leave it alone!\n                    if (ecomp != null)\n                        comp.setRecurrence(ecomp.getRecurrence());\n                    break;\n                default:\n                    comp.setRecurrence(repeat.getRecurrence());\n                    break;\n            }\n        }\n\n\n        if (ecomp != null) {\n            comp.setSequenceNumber(ecomp.getSequenceNumber());\n            comp.setTransparency(ecomp.getTransparency());\n            if (getTaskStatus() == null) comp.setStatus(ecomp.getStatus());\n            //comp.setClassProp(ecomp.getClassProp());\n        }\n        if (getReminder1() != null && getReminder1().length() > 0){\n            toAlarm(comp, getReminder1());\n        }\n        if (getReminder2() != null && getReminder2().length() > 0){\n            toAlarm(comp, getReminder2());\n        }\n\n        return invite;\n    }\n    \n    private void toAlarm(ZComponent comp, String remDuration) throws ServiceException{\n        ParsedDuration dur = ParsedDuration.parse(remDuration);\n        if (this.isSendReminderEmail()){\n            ZAlarm alarm = new ZAlarm();\n            alarm.setTriggerRelative(dur);\n            alarm.setSummary(getSubject());\n            alarm.setDescription(getContent());\n            alarm.setRepeatCount(0);\n            alarm.setAction(ZAlarm.ZAction.EMAIL);\n            ZAttendee attendee = new ZAttendee();\n            attendee.setAddress(this.getReminderEmail());\n            alarm.addAttendee(attendee);\n            comp.getAlarms().add(alarm);\n        }\n        if (this.isSendReminderMobile()) {\n            ZAlarm alarm = new ZAlarm();\n            alarm.setTriggerRelative(dur);\n            alarm.setSummary(getSubject());\n            alarm.setDescription(getContent());\n            alarm.setRepeatCount(0);\n            alarm.setAction(ZAlarm.ZAction.X_YAHOO_CALENDAR_ACTION_MOBILE);\n            ZAttendee attendee = new ZAttendee();\n            attendee.setAddress(this.getReminderMobile());\n            alarm.addAttendee(attendee);\n            comp.getAlarms().add(alarm);\n        }\n        if (this.isSendReminderYIM()) {\n            ZAlarm alarm = new ZAlarm();\n            alarm.setTriggerRelative(dur);\n            alarm.setSummary(getSubject());\n            alarm.setDescription(getContent());\n            alarm.setRepeatCount(0);\n            alarm.setAction(ZAlarm.ZAction.X_YAHOO_CALENDAR_ACTION_IM);\n            comp.getAlarms().add(alarm);\n        }\n    }\n\n    public boolean getIsValidStartTime() {\n        try {\n            getApptStartTime();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    public boolean getIsValidEndTime() {\n        try {\n            getApptEndTime();\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n\n    public boolean getIsValidRepeatEndDateTime() {\n        try {\n            getRepeatEndDateTime();\n            return true;\n        } catch(Exception e) {\n            return false;\n        }\n    }\n\n    public String getRepeatEndDateTime() throws ZTagLibException {\n        return getICalTime(mRepeatEndDate, 0 ,0);\n    }\n\n    public String getApptStartTime() throws ZTagLibException {\n        return getICalTime(mStartDate, mStartHour, mStartMinute);\n    }\n    \n    public Calendar getApptStartCalendar() {\n        try {\n            return getCalendar(mStartDate, mStartHour, mStartMinute);\n        } catch (ZTagLibException e) {\n            return null;\n        }\n    }\n\n    public Calendar getApptEndCalendar() {\n        try {\n            return getCalendar(mEndDate, mEndHour, mEndMinute);\n        } catch (ZTagLibException e) {\n            return null;\n        }\n    }\n\n    public String getApptEndTime() throws ZTagLibException {\n        return getICalTime(mEndDate, mEndHour, mEndMinute);\n    }\n\n    private String getICalTime(String dateStr, long hour, long minute) throws ZTagLibException {\n            DateFormat icalFmt = new SimpleDateFormat(getAllDay() ? \"yyyyMMdd\" : \"yyyyMMdd'T'HHmmss\");\n            return icalFmt.format(getCalendar(dateStr, hour, minute).getTime());\n    }\n\n    @SuppressWarnings({\"EmptyCatchBlock\"})\n    private Calendar getCalendar(String dateStr, long hour, long minute) throws ZTagLibException {\n        try {\n\n            if (dateStr == null)\n                throw ZTagLibException.INVALID_APPT_DATE(\"date field is empty\", null);\n\n            DateFormat df = new SimpleDateFormat(mDateFormat);\n            df.setLenient(false);\n            ParsePosition pos = new ParsePosition(0);\n            Date date = df.parse(dateStr, pos);\n\n            if (pos.getIndex() != dateStr.length())\n                throw ZTagLibException.INVALID_APPT_DATE(\"invalid date: \"+dateStr, null);\n\n            if (hour < 0 || hour > 23)\n                throw  ZTagLibException.INVALID_APPT_DATE(\"invalid hour: \"+hour, null);\n\n            if (minute < 0 || minute > 59)\n                throw ZTagLibException.INVALID_APPT_DATE(\"invalid minute: \"+minute, null);\n\n\n            Calendar cal = Calendar.getInstance();\n            cal.setTime(date);\n            cal.set(Calendar.HOUR_OF_DAY, (int)hour);\n            cal.set(Calendar.MINUTE, (int)minute);\n            cal.set(Calendar.SECOND, 0);\n            cal.set(Calendar.MILLISECOND, 0);\n\n            int year = cal.get(Calendar.YEAR);\n            if (year < 100)\n                cal.set(Calendar.YEAR, 2000+year);\n            if (year < 1900)\n                throw ZTagLibException.INVALID_APPT_DATE(\"invalid year: \"+year, null);\n\n            return cal;\n        } catch (Exception e) {\n            throw ZTagLibException.INVALID_APPT_DATE(dateStr, e);\n        }\n    }\n\n    /**\n     * fix up content be pre-pending blurb to content\n     * @param mailbox mailbox\n     * @param newInvite outgoing invite\n     * @param previousInvite previous invite (null if new invite)\n     * @param blurbHeaderKey message prop key to use for blurb header\n     * @throws ServiceException on error\n     * @param pc page context for messages\n     */\n    public void setInviteBlurb(ZMailbox mailbox, PageContext pc, ZInvite newInvite, ZInvite previousInvite, String blurbHeaderKey) throws ServiceException {\n\n        String content = getContent();\n        if (content == null)\n            content = \"\";\n\n        String blurb = generateInviteBlurb(mailbox, pc, newInvite, previousInvite, blurbHeaderKey, false);\n        setContent(blurb+content);\n\n        String htmlBlurb = generateInviteBlurb(mailbox, pc, newInvite, previousInvite, blurbHeaderKey, true);\n        setHtmlContent(\"<html><body>\"+htmlBlurb+BeanUtils.textToHtml(content)+\"</body></html>\");\n\n        /*\n        StringBuilder sb = new StringBuilder();\n        String blurbHeader = I18nUtil.getLocalizedMessage(pc, blurbHeaderKey);\n\n        if (blurbHeader != null) {\n            sb.append(blurbHeader);\n            sb.append(\"\\n\\n\");\n        }\n\nThe following is a new meeting request:\n\nSubject: da subject\nOrganizer: \"Demo User One\" <user1@macpro.local>\n\nLocation: da location\nTime: 4:30:00 PM - 6:00:00 PM\n Recurrence : The first Thursday of every 1 month(s). No end date. Effective Mar 22, 2007.\n\nInvitees: user2@macpro.local\n\n\n\nda body\n        \n        */\n\n        \n    }\n\n    private void addLine(StringBuilder sb, String a, String b, String c, boolean html, String tzId)\n    {\n        if (html) {\n            sb.append(\"<tr><th valign='top' align='left'>\").append(a).append(\":</th><td>\");\n            sb.append(BeanUtils.htmlEncode(b));\n\n            if (tzId != null)\n                sb.append(\" <span style='color: #686357'>\").append(tzId).append(\"</span>\");\n\n            if (c != null) sb.append(' ').append(c);\n            sb.append(\"</td></tr>\");\n        } else {\n            sb.append(a).append(\": \").append(b);\n            if (tzId != null)\n                sb.append(\" \").append(tzId);\n            if (c != null) sb.append(' ').append(c);\n        }\n    }\n\n    private static String msg(PageContext pc, String key) {\n        return I18nUtil.getLocalizedMessage(pc, key);\n    }\n\n    private String generateInviteBlurb(ZMailbox mailbox, PageContext pc,\n                                      ZInvite newInvite, ZInvite previousInvite,\n                                      String blurbHeaderKey, boolean html) throws ServiceException\n    {\n        String mod = msg(pc, \"apptModifiedStamp\");\n        TimeZone tz = mailbox.getPrefs().getTimeZone();\n        String tzId = mailbox.getPrefs().getTimeZoneCanonicalId();\n        \n        StringBuilder sb = new StringBuilder();\n\n        ZComponent appt = newInvite.getComponent();\n        ZComponent oldAppt = previousInvite == null ? null : previousInvite.getComponent();\n\n        if (html) sb.append(\"<h3>\");\n        sb.append(I18nUtil.getLocalizedMessage(pc, blurbHeaderKey));\n        if (html) sb.append(\"</h3>\");\n        sb.append(\"\\n\\n\");\n\n        if (html) sb.append(\"<p>\\n<table border='0'>\\n\");\n\n        String name = appt.getName();\n        String oldName = oldAppt == null ? null : oldAppt.getName();\n\n        addLine(sb,\n                msg(pc, \"subject\"),\n                name,\n                oldAppt != null && !name.equals(oldName) ? mod : null,\n                html,\n                null\n        );\n        sb.append(\"\\n\");\n\n        ZOrganizer org = appt.getOrganizer();\n        if (org != null) {\n            String orgEmail = org.getEmailAddress().getFullAddress();\n            String oldOrgEmail = oldAppt == null || oldAppt.getOrganizer() == null ? null :\n                    oldAppt.getOrganizer().getEmailAddress().getFullAddress(); \n            addLine(sb,\n                    msg(pc, \"organizer\"),\n                    orgEmail,\n                    oldAppt != null && !orgEmail.equals(oldOrgEmail) ? mod : null,\n                    html,\n                    null\n            );\n            sb.append(\"\\n\");\n        }\n\n        if (html) sb.append(\"</table>\\n\");\n        sb.append(\"\\n\");\n\n        if (html) sb.append(\"<p>\\n<table border='0'>\\n\");\n\n        String loc = appt.getLocation();\n        String oldLoc = oldAppt == null ? null : oldAppt.getLocation();\n        \n        if (loc != null) {\n            addLine(sb,\n                    msg(pc, \"location\"),\n                    loc,\n                    oldAppt != null && !loc.equals(oldLoc) ? mod : null,\n                    html,\n                    null\n                    );\n            sb.append(\"\\n\");\n        }\n\n        String timeBlurb = BeanUtils.getApptDateBlurb(pc,\n                tz,\n                html ? appt.getStart().getDate().getTime() : getApptStartCalendar().getTimeInMillis(),\n                html ? appt.getEnd().getDate().getTime() : getApptEndCalendar().getTimeInMillis(),\n                getAllDay());\n\n        String oldTimeBlurb = oldAppt == null ? null :\n            BeanUtils.getApptDateBlurb(pc,\n                    tz,\n                    oldAppt.getStart().getDate().getTime(),\n                    oldAppt.getComputedEndDate().getTime(),\n                    oldAppt.isAllDay());\n\n        boolean diffTime = oldAppt != null && !timeBlurb.equals(oldTimeBlurb);\n\n        addLine(sb,\n                msg(pc, \"time\"),\n                timeBlurb,\n                oldAppt != null && diffTime ? mod : null,\n                html,\n                tzId);\n        sb.append(\"\\n\");\n        \n        ZSimpleRecurrence repeat = appt.getSimpleRecurrence();\n        ZSimpleRecurrence oldRepeat = oldAppt == null ? null : oldAppt.getSimpleRecurrence();\n\n        String repeatStr = BeanUtils.getRepeatBlurb(repeat, pc, tz, appt.getStart().getDate());\n        String oldRepeatStr = oldAppt == null ? \"\" : BeanUtils.getRepeatBlurb(oldRepeat, pc, tz, oldAppt.getStart().getDate());\n        boolean diffRepeat = oldAppt != null && !repeatStr.equals(oldRepeatStr);\n        if (repeat.getType() != ZSimpleRecurrenceType.NONE || diffRepeat) {\n            addLine(sb,\n                    msg(pc, \"recurrence\"),\n                    repeatStr,\n                    diffRepeat ? mod : null,\n                    html,\n                    null);\n            sb.append(\"\\n\");\n        }\n\n        if (html) sb.append(\"</table>\\n\");\n\n        List<ZAttendee> attendees = appt.getAttendees();\n        if (attendees != null && attendees.size() > 0) {\n            if (html) sb.append(\"<p>\\n<table border='0'>\\n\");\n            sb.append(\"\\n\");\n            String alist = getAttendeeList(attendees);\n            String oldAlist = oldAppt == null ? null : getAttendeeList(oldAppt.getAttendees());\n            addLine(sb,\n                    msg(pc, \"invitees\"),\n                    alist,\n                    oldAppt != null && !alist.equals(oldAlist) ? mod : null, /// TODO: THIS IS BROKE IF FIRST 10 ARE SAME\n                    html, null);\n            if (html) sb.append(\"</table>\\n\");\n        }\n\n        sb.append(html ? \"<div>\" : \"\\n\\n\");\n        sb.append(NOTES_SEPARATOR);\n        sb.append(html ? \"</div><br>\" : \"\\n\\n\");\n        return sb.toString();\n    }\n\n    private String getAttendeeList(List<ZAttendee> attendees) {\n        if (attendees == null || attendees.size() == 0)\n            return \"\";\n        StringBuilder a = new StringBuilder();\n        int n = 0;\n        for (ZAttendee attendee : attendees) {\n            if (a.length() > 0) a.append(\"; \");\n            a.append(attendee.getEmailAddress().getFullAddress());\n            if (n++ > 10) break;\n        }\n        if (attendees.size() > 10) a.append(\"; ...\");\n        return a.toString();\n    }\n    \n    public ZOutgoingMessage toOutgoingMessage(ZMailbox mailbox) throws ServiceException {\n\n        List<ZEmailAddress> addrs = new ArrayList<ZEmailAddress>();\n\n        if (mTo != null && mTo.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mTo, ZEmailAddress.EMAIL_TYPE_TO));\n\n        if (mReplyTo != null && mReplyTo.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mReplyTo, ZEmailAddress.EMAIL_TYPE_REPLY_TO));\n\n        if (mCc != null && mCc.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mCc, ZEmailAddress.EMAIL_TYPE_CC));\n\n        if (mFrom != null && mFrom.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mFrom, ZEmailAddress.EMAIL_TYPE_FROM));\n\n        if (mBcc != null && mBcc.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mBcc, ZEmailAddress.EMAIL_TYPE_BCC));\n\n        if (mAttendees != null && mAttendees.length() > 0)\n            addrs.addAll(ZEmailAddress.parseAddresses(mAttendees, ZEmailAddress.EMAIL_TYPE_TO));\n\n        if (mResources != null && mResources.length() > 0)\n                    addrs.addAll(ZEmailAddress.parseAddresses(mResources, ZEmailAddress.EMAIL_TYPE_TO));\n\n        ZOutgoingMessage m = new ZOutgoingMessage();\n        \n        if (mMessageAttachments != null && mMessageAttachments.size() > 0) {\n            List<String> messages = new ArrayList<String>();\n            for (MessageAttachment ma : mMessageAttachments) {\n                messages.add(ma.getId());\n            }\n            m.setMessageIdsToAttach(messages);\n        }\n\n        if (mDocumentAttachments != null && mDocumentAttachments.size() > 0) {\n            List<String> docs = new ArrayList<String>();\n            for (DocumentAttachment doc : mDocumentAttachments) {\n                docs.add(doc.getId());\n            }\n            m.setDocIdsToAttach(docs);\n        }\n\n        if (mCheckedAttachmentNames != null && mCheckedAttachmentNames.size() > 0) {\n            List<AttachedMessagePart> attachments = new ArrayList<AttachedMessagePart>();\n            for (Map.Entry<String,String> entry : mCheckedAttachmentNames.entrySet()) {\n                String mid = (mDraftId != null && mDraftId.length() > 0) ? mDraftId : mMessageId;\n                if (mid != null && mid.length() > 0) {\n                    attachments.add(new AttachedMessagePart(mid, entry.getKey(),(entry.getValue() != null && !entry.getValue().equals(\"true\") ? entry.getValue() : null)));\n                }\n            }\n            m.setMessagePartsToAttach(attachments);\n        }\n\n        /*\n        if (mOriginalAttachments != null && mOriginalAttachments.size() > 0) {\n            List<AttachedMessagePart> attachments = m.getMessagePartsToAttach();\n            if (attachments == null) attachments = new ArrayList<AttachedMessagePart>();\n            for (ZMimePartBean part : mOriginalAttachments) {\n                attachments.add(new AttachedMessagePart(mMessageId, part.getPartName()));\n            }\n            m.setMessagePartsToAttach(attachments);\n        }\n        */\n\n        m.setAddresses(addrs);\n\n        m.setSubject(mSubject);\n\n        m.setPriority(mPriority);\n\n        if (mInReplyTo != null && mInReplyTo.length() > 0)\n            m.setInReplyTo(mInReplyTo);\n\n        if (mMessageId != null && mMessageId.length() > 0)\n            m.setOriginalMessageId(mMessageId);\n\n        if (mReplyType != null && mReplyType.length() > 0)\n            m.setReplyType(mReplyType);\n\n        boolean hasHtml = mHtmlContent != null && mHtmlContent.length() > 0;\n        boolean hasText = mContent != null;\n\n        if (hasHtml && hasText) {\n            List<AttachedMessagePart> inlineAttachments = m.getInlineMessagePartsToAttach();\n            if(inlineAttachments != null && inlineAttachments.size() > 0){\n                MessagePart html = new MessagePart(ZMimePartBean.CT_TEXT_HTML, mHtmlContent, inlineAttachments);\n            \tMessagePart related = new MessagePart(ZMimePartBean.CT_MULTI_RELATED, html);                                \n\t\t\t \tm.setMessagePart(new MessagePart(ZMimePartBean.CT_MULTI_ALT,\n\t                    new MessagePart(ZMimePartBean.CT_TEXT_PLAIN, mContent),\n\t                    related)\n\t                    );\n            }else{\n\t\t\t\t m.setMessagePart(new MessagePart(ZMimePartBean.CT_MULTI_ALT,\n\t\t                    new MessagePart(ZMimePartBean.CT_TEXT_PLAIN, mContent),\n\t\t                    new MessagePart(ZMimePartBean.CT_TEXT_HTML, mHtmlContent)\n\t\t                    ));\n            }\n\n        } else if (hasHtml) {\n\n            List<AttachedMessagePart> inlineAttachments = m.getInlineMessagePartsToAttach();\n            if(inlineAttachments != null && inlineAttachments.size() > 0){\n\n                MessagePart html = new MessagePart(ZMimePartBean.CT_TEXT_HTML, mContent != null ? mContent : \"\", inlineAttachments);\n            \tMessagePart related = new MessagePart(ZMimePartBean.CT_MULTI_RELATED, html);                                \n\t\t\t \tm.setMessagePart(new MessagePart(ZMimePartBean.CT_MULTI_ALT,related));\n            }else{\n            \tm.setMessagePart(new MessagePart(ZMimePartBean.CT_TEXT_HTML, mContent != null ? mContent : \"\"));\n\t\t\t}\n        } else {\n            m.setMessagePart(new MessagePart(mContentType, mContent != null ? mContent : \"\"));\n        }\n\n\n        //bug:25270 checked of 0kb file attachment and discarded\n        String attachmentUploadId = null;\n        if (getHasFileItems()) {\n            int num = 0;\n            for (FileItem item : mFileItems) {\n                if (item.getSize() > 0) num++;\n            }\n            Part[] parts = new Part[num*3];\n            int i=0;\n            int j=0;\n            for (FileItem item : mFileItems) {\n                if (item.getSize() > 0 ){\n                    String name = item.getName();\n                    try{\n                        name = new String(item.getName().getBytes(\"UTF-8\"),\"UTF-8\");\n                    }catch(Exception e){\n                        System.out.println(\"Failed to get UTF8 name for \"+ name);  /* TODO: need logging infra */\n                        e.printStackTrace();\n                        name = item.getName();\n                    }\n\n                    parts[i++] = new StringPart(\"_charset_\", \"UTF-8\",\"UTF-8\");\n                    parts[i++] = new StringPart(\"filename\"+j++, name,\"UTF-8\");\n                    parts[i++] = new FilePart(item.getFieldName(), new UploadPartSource(item), item.getContentType(), \"UTF-8\");\n                }\n            }\n\n            try {\n                if(parts.length > 0) {\n                    attachmentUploadId = mailbox.uploadAttachments(parts, 1000 * 60);  //TODO get timeout from config\n                }\n            } finally {\n                for (FileItem item : mFileItems) {\n                    try { item.delete(); } catch (Exception e) { /* TODO: need logging infra */ }\n                }\n            }\n        }\n        \n        if (mUploadedAttachmentId != null) {\n            if (attachmentUploadId != null) {\n                attachmentUploadId += \",\" + mUploadedAttachmentId;\n            } else {\n                attachmentUploadId = mUploadedAttachmentId;\n            }\n        }\n        m.setAttachmentUploadId(attachmentUploadId);\n        return m;\n    }\n\n    public static class UploadPartSource implements PartSource {\n\n        private FileItem mItem;\n\n        public UploadPartSource(FileItem item) { mItem = item; }\n\n        public long getLength() {\n            return mItem.getSize();\n        }\n\n        public String getFileName() {\n            return mItem.getName();\n        }\n\n        public InputStream createInputStream() throws IOException {\n            return mItem.getInputStream();\n        }\n    }\n}\n",
    "vulnerability_type": "Cross-Site Scripting (XSS)",
    "repo": "zm-taglib",
    "commit": "bf8883434f7dddc3fbc90c18a11201ff8ca7dca6",
    "commit_msg": "bug: 75976 Failed to send message potential XSS\n\n- If the message original format is text/plain, then while replying in html format prevent html content from being rendered.\n\nReviewboard url: https://reviewboard.eng.vmware.com/r/362802/\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=75976\n\nCopied from Perforce\n Change: 388694",
    "original_file": "ZMessageComposeBean.java",
    "confidence_score": 0.8
  },
  {
    "serial_no": 25,
    "vulnerable_code": "/*\n * ***** BEGIN LICENSE BLOCK *****\n * Zimbra Collaboration Suite Server\n * Copyright (C) 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n * \n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n * \n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\npackage com.zimbra.cs.db;\n\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.ListUtil;\nimport com.zimbra.common.util.Log;\nimport com.zimbra.common.util.StringUtil;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.db.DbPool.Connection;\nimport com.zimbra.cs.db.DbSearchConstraints.NumericRange;\nimport com.zimbra.cs.db.DbSearchConstraints.StringRange;\nimport com.zimbra.cs.db.DbSearchConstraintsNode.NodeType;\nimport com.zimbra.cs.imap.ImapMessage;\nimport com.zimbra.cs.index.SortBy;\nimport com.zimbra.cs.index.SortBy.SortCriterion;\nimport com.zimbra.cs.index.SortBy.SortDirection;\nimport com.zimbra.cs.localconfig.DebugConfig;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Tag;\n\npublic class DbSearch {\n\n    private static Log sLog = ZimbraLog.index_search;\n\n    public static final class SearchResult {\n        public int    id;\n        public int    indexId;\n        public byte   type;\n        public Object sortkey;\n        public Object extraData;\n\n        public enum ExtraData { NONE, MAIL_ITEM, IMAP_MSG, MODSEQ, PARENT, MODCONTENT };\n\n        public static class SizeEstimate {\n            public SizeEstimate() {}\n            public SizeEstimate(int initialval) { mSizeEstimate = initialval; }\n            public int mSizeEstimate;\n        }\n\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort, boolean inDumpster) throws SQLException, ServiceException {\n            return createResult(rs, sort, ExtraData.NONE, inDumpster);\n        }\n\n        public static SearchResult createResult(ResultSet rs, SortBy sort, ExtraData extra, boolean inDumpster) throws SQLException, ServiceException {\n            SearchResult result = new SearchResult();\n            result.id      = rs.getInt(COLUMN_ID);\n            result.indexId = rs.getInt(COLUMN_INDEXID);\n            result.type    = rs.getByte(COLUMN_TYPE);\n            switch (sort.getCriterion()) {\n                case SUBJECT:\n                case SENDER:\n                case NAME:\n                case NAME_NATURAL_ORDER:\n                    result.sortkey = rs.getString(COLUMN_SORTKEY);\n                    break;\n                case SIZE:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY));\n                    break;\n                case NONE:\n                    // note that there's no sort column in the result set for SORT_NONE\n                    break;\n                default:\n                    result.sortkey = new Long(rs.getInt(COLUMN_SORTKEY) * 1000L);\n                    break;\n            }\n\n            // note that there's no sort column in the result set for SORT_NONE\n            int offset = sort.getCriterion() == SortCriterion.NONE ? COLUMN_SORTKEY - 1 : COLUMN_SORTKEY;\n            if (extra == ExtraData.MAIL_ITEM) {\n                result.extraData = DbMailItem.constructItem(rs, offset, inDumpster);\n            } else if (extra == ExtraData.IMAP_MSG) {\n                int flags = rs.getBoolean(offset + 2) ? Flag.BITMASK_UNREAD | rs.getInt(offset + 3) : rs.getInt(offset + 3);\n                result.extraData = new ImapMessage(result.id, result.type, rs.getInt(offset + 1), flags, rs.getLong(offset + 4));\n            } else if (extra == ExtraData.MODSEQ || extra == ExtraData.PARENT || extra==ExtraData.MODCONTENT) {\n                int value = rs.getInt(offset + 1);\n                result.extraData = rs.wasNull() ? -1 : value;\n            }\n            return result;\n        }\n\n        @Override public String toString() {\n            return sortkey + \" => (\" + id + \",\" + type + \")\";\n        }\n\n        @Override public int hashCode() {\n            return id;\n        }\n\n        @Override public boolean equals(Object obj) {\n            SearchResult other = (SearchResult) obj;\n            return other.id == id;\n        }\n        \n        private static class SearchResultComparator implements Comparator<SearchResult> {\n            private SortBy mSort;\n            SearchResultComparator(SortBy sort)  { mSort = sort; }\n\n            @Override public int compare(SearchResult o1, SearchResult o2) {\n                switch (mSort.getCriterion()) {\n                    case SIZE:\n                    case DATE:\n                        long date1 = (Long) o1.sortkey;\n                        long date2 = (Long) o2.sortkey;\n                        if (date1 != date2) {\n                            long diff;\n                            if (mSort.getDirection() == SortDirection.DESCENDING) {\n                                diff = date2 - date1;\n                            } else {\n                                diff = date1 - date2;\n                            }\n                            return (diff > 0) ? 1 : -1;\n                        }\n                        // fall through to ID-based comparison below!\n                        break;\n                    case SENDER:\n                    case SUBJECT:\n                    case NAME:\n                    case NAME_NATURAL_ORDER:\n                        String s1 = (String) o1.sortkey;\n                        String s2 = (String) o2.sortkey;\n                        if (!StringUtil.equal(s1, s2)) {\n                            if (mSort.getDirection() == SortDirection.DESCENDING) {\n                                return StringUtil.compareTo(s2, s1);\n                             } else {\n                                return StringUtil.compareTo(s1, s2);\n                             }\n                        }\n                        break;\n                    case ID:\n                    case NONE:\n                        break;\n                    default:\n                        throw new UnsupportedOperationException(\"SearchResultComparator not implemented \" +\n                                                                \" for anything except for DATE and SIZE right now. \" +\n                                                                \" Feel free to fix it!\"); \n                }\n                if (mSort.getDirection() == SortDirection.DESCENDING) {\n                    return o2.id - o1.id;\n                } else {\n                    return o1.id - o2.id;\n                }\n            }\n        }\n        \n        public static Comparator<SearchResult> getComparator(SortBy sort) {\n            return new SearchResultComparator(sort);\n        }\n    }\n\n    // alias the sort column b/c of ambiguity problems (the sort column is included twice in the \n    // result set, and MySQL chokes on the ORDER BY when we do a UNION query (doesn't know\n    // which 2 of the 4 sort columns are the \"right\" ones to use)\n    public static final String SORT_COLUMN_ALIAS = \"sortcol\";\n    \n    /**\n     * @param fieldName\n     * @return TRUE if this field is case-sensitive for search/sort -- ie do we need to\n     *         do an UPPER(fieldName) on it in places?\n     */\n    private static boolean isCaseSensitiveField(String fieldName) {\n        // we need to handle things like \"mi.sender\" for the sender column, etc\n        // so look for the last . in the fieldname, return the string after that.\n        String colNameAfterPeriod; \n        int periodOffset = fieldName.lastIndexOf('.');\n        if (periodOffset <= 0 && periodOffset < (fieldName.length()+1))\n            colNameAfterPeriod = fieldName;\n        else\n            colNameAfterPeriod = fieldName.substring(periodOffset+1);\n        \n        return (colNameAfterPeriod.equals(\"sender\") || \n                        colNameAfterPeriod.equals(\"subject\") ||\n                        colNameAfterPeriod.equals(\"name\")); \n    }\n\n    private static String sortField(SortBy sort, boolean useAlias, boolean includeCollation) {\n        String str;\n        boolean stringVal = false;\n        switch (sort.getCriterion()) {\n            case SENDER:   str = \"mi.sender\";   stringVal = true;  break;\n            case SUBJECT:  str = \"mi.subject\";  stringVal = true;  break;\n            case NAME_NATURAL_ORDER:\n            case NAME:     str = \"mi.name\";     stringVal = true;  break;\n            case ID:       str = \"mi.id\";    break;\n            case SIZE:     str = \"mi.size\";  break;\n            case DATE:\n            default:       str = \"mi.date\";  break; \n            case NONE:     return null;\n        }\n        \n        if (useAlias) {\n            str = SORT_COLUMN_ALIAS; // still need the stringVal setting above!\n        } else {\n            if (stringVal && Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON)) \n                str = \"UPPER(\" + str + \")\";\n        }\n\n        // tim: back this out for now, but leave code stub here until I deal with it\n        // see bugs 22665, 36579\n        //if (Db.supports(Db.Capability.REQUEST_UTF8_UNICODE_COLLATION) && stringVal && includeCollation) \n        //    str += \" COLLATE utf8_unicode_ci\";\n\n        return str;\n    }\n    \n    /**\n     * generate a column-reference for the sort-by column.  This column reference\n     * goes at the beginning of the SELECT statement (the ORDER BY part is generated\n     * by sortQuery() below)\n     */\n    static String sortKey(SortBy sort) {\n        String field = sortField(sort, false, false);\n        // note that there's no sort column in the result set for SORT_NONE\n        if (field == null)\n            return \"\";\n        return \", \" + field + \" AS \" + SORT_COLUMN_ALIAS;\n    }\n\n    static String sortQuery(SortBy sort) {\n        return sortQuery(sort, false);\n    }\n\n    /**\n     * Generate the ORDER BY part that goes at the end of the select\n     */\n    static String sortQuery(SortBy sort, boolean useAlias) {\n        // note that there's no need for an ORDER BY clause for SORT_NONE\n        if (sort.getCriterion() == SortCriterion.NONE)\n            return \"\";\n\n        String direction = sort.getDirection() == SortDirection.DESCENDING ? \" DESC\" : \"\";\n        StringBuilder statement = new StringBuilder(\" ORDER BY \");\n        statement.append(sortField(sort, useAlias, true)).append(direction);\n        // when two items match in their sort field, let's use item ID as the tie breaker\n        //   (commented out as a result of perf issues -- see bug 50469)\n//        statement.append(\", mi.id\").append(direction);\n        return statement.toString();\n    }\n\n\n    public static int countResults(Connection conn, DbSearchConstraintsNode node, Mailbox mbox, boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // Assemble the search query\n        StringBuilder statement = new StringBuilder(\"SELECT count(*) \");\n        statement.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \"mi\", inDumpster));\n        statement.append(\" WHERE \").append(DbMailItem.IN_THIS_MAILBOX_AND);\n        int num = DebugConfig.disableMailboxGroups ? 0 : 1;\n        \n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            num += encodeConstraint(mbox, node, null, false, statement, conn);\n\n            stmt = conn.prepareStatement(statement.toString());\n            int pos = 1;\n            pos = DbMailItem.setMailboxId(stmt, mbox, pos);\n            pos = setSearchVars(stmt, node, pos, null, false);\n\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: \" + statement);\n\n            assert(pos == num + 1); \n            rs = stmt.executeQuery();\n            rs.next();\n            return rs.getInt(1);\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    // Indexes on mail_item table\n    private static final String MI_I_MBOX_FOLDER_DATE = \"i_folder_id_date\";\n//    private static final String MI_I_MBOX_ID_PKEY     = \"PRIMARY\";\n    private static final String MI_I_MBOX_PARENT      = \"i_parent_id\";\n    private static final String MI_I_MBOX_INDEX       = \"i_index_id\";\n//    private static final String MI_I_MBOX_DATE        = \"i_date\";\n//    private static final String MI_I_MBOX_TAGS_DATE   = \"i_tags_date\";\n//    private static final String MI_I_MBOX_FLAGS_DATE  = \"i_flags_date\";\n//    private static final String MI_I_MBOX_TYPE        = \"i_type\";\n//    private static final String MI_I_MBOX_UNREAD      = \"i_unread\";\n//    private static final String MI_I_MBOX_MODMETADATA = \"i_mod_metadata\";\n//    private static final String MI_I_MBOX_FOLDER_NAME = \"i_name_folder_id\";\n\n    private static final String NO_HINT = \"\";\n\n    private static String getForceIndexClause(DbSearchConstraintsNode node, SortBy sort, boolean hasLimit) {\n        if (LC.search_disable_database_hints.booleanValue())\n            return NO_HINT;\n\n        if (!Db.supports(Db.Capability.FORCE_INDEX_EVEN_IF_NO_SORT) && sort.getCriterion() == SortCriterion.NONE)\n            return NO_HINT;\n        \n        String index = null;\n\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        DbSearchConstraints constraints = node.getSearchConstraints();\n        if (ntype == DbSearchConstraintsNode.NodeType.LEAF) {\n            if (!constraints.itemIds.isEmpty()) {\n                return \"\";\n            } else if (constraints.convId > 0) {\n                index = MI_I_MBOX_PARENT;\n            } else if (!constraints.indexIds.isEmpty()) {\n                index = MI_I_MBOX_INDEX;\n            } else if (sort.getCriterion() == SortCriterion.DATE && hasLimit) {\n                // Whenever we learn a new case of mysql choosing wrong index, add a case here.\n                if (constraints.isSimpleSingleFolderMessageQuery()) {\n                    // Optimization for folder query\n                    //\n                    // If looking at a single folder and sorting by date with a limit,\n                    // force the use of i_folder_id_date index.  Typical example of\n                    // such a query is the default \"in:Inbox\" search.\n                    index = MI_I_MBOX_FOLDER_DATE;\n                }\n            }\n        }\n\n        return Db.forceIndex(index);\n    }\n\n    // put these into constants so that people can easily tell what is dependent on the positons\n    private static final int COLUMN_ID      = 1;\n    private static final int COLUMN_INDEXID = 2;\n    private static final int COLUMN_TYPE    = 3;\n    private static final int COLUMN_SORTKEY = 4;\n\n    private static final String encodeSelect(Mailbox mbox, SortBy sort, SearchResult.ExtraData extra,\n                                             boolean includeCalTable, DbSearchConstraintsNode node,\n                                             boolean validLIMIT, boolean inDumpster) {\n        /*\n         * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi [, appointment AS ap]\n         *    [FORCE INDEX (...)]\n         *    WHERE mi.mailboxid=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND\n         * \n         *  If you change the first for parameters, you must change the COLUMN_* values above!\n         */\n        StringBuilder select = new StringBuilder(\"SELECT mi.id, mi.index_id, mi.type\").append(sortKey(sort));\n        if (extra == SearchResult.ExtraData.MAIL_ITEM)\n            select.append(\", \" + DbMailItem.DB_FIELDS);\n        else if (extra == SearchResult.ExtraData.IMAP_MSG)\n            select.append(\", mi.imap_id, mi.unread, mi.flags, mi.tags\");\n        else if (extra == SearchResult.ExtraData.MODSEQ)\n            select.append(\", mi.mod_metadata\");\n        else if (extra == SearchResult.ExtraData.PARENT)\n            select.append(\", mi.parent_id\");\n        else if (extra == SearchResult.ExtraData.MODCONTENT)\n            select.append(\", mi.mod_content\");\n\n        select.append(\" FROM \" + DbMailItem.getMailItemTableName(mbox, \"mi\", inDumpster));\n        if (includeCalTable) \n            select.append(\", \").append(DbMailItem.getCalendarItemTableName(mbox, \"ap\", inDumpster));\n        \n        /*\n         * FORCE INDEX (...)\n         */\n        if (!includeCalTable) // can't force index when selecting from two tables?\n            select.append(getForceIndexClause(node, sort, validLIMIT));\n        \n        /*\n         *  WHERE mi.mailboxId=? [AND ap.mailboxId=? AND mi.id = ap.id ] AND \"\n         */\n        select.append(\" WHERE \");\n        select.append(DbMailItem.getInThisMailboxAnd(mbox.getId(), \"mi\", includeCalTable ? \"ap\" : null));\n        if (includeCalTable)\n            select.append(\" mi.id = ap.item_id AND \");\n        \n        return select.toString();\n    }\n    \n    /**\n     * @param mbox\n     * @param node\n     * @param calTypes\n     * @param inCalTable\n     * @param statement\n     * @param conn\n     * @return Number of constraints encoded \n     * @throws ServiceException\n     */\n    private static final int encodeConstraint(Mailbox mbox, DbSearchConstraintsNode node,\n        byte[] calTypes, boolean inCalTable, StringBuilder statement, Connection conn) \n    throws ServiceException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        int num = 0;\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            boolean first = true;\n            boolean and = ntype == DbSearchConstraintsNode.NodeType.AND;\n            statement.append('(');\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (!first)\n                    statement.append(and ? \" AND \" : \" OR \");\n                num += encodeConstraint(mbox, subnode, calTypes, inCalTable, statement, conn);\n                first = false;\n            }\n            statement.append(\") \");\n            return num;\n        }\n        \n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        c.checkDates();\n        \n        // if there are no possible matches, short-circuit here...\n        TagConstraints tc = TagConstraints.getTagConstraints(mbox, c, conn);\n        if (c.automaticEmptySet() || tc.noMatches) {\n            statement.append(Db.supports(Db.Capability.BOOLEAN_DATATYPE) ?\n                \"FALSE\" : \"0=1\"); \n            return num;\n        }\n        \n        statement.append('(');\n\n        // special-case this one, since there can't be a leading AND here...\n        if (ListUtil.isEmpty(c.types)) {\n            statement.append(\"type NOT IN \" + DbMailItem.NON_SEARCHABLE_TYPES);\n        } else {\n            statement.append(DbUtil.whereIn(\"type\", c.types.size()));\n            num += c.types.size();\n        }\n        \n        num += encode(statement, \"mi.type\", false, c.excludeTypes);\n        num += encode(statement, \"mi.type\", inCalTable, calTypes);\n\n        // if hasTags is NULL then nothing\n        // if hasTags is TRUE then !=0\n        // if hasTags is FALSE then = 0\n        if (c.hasTags != null) {\n            if (c.hasTags.booleanValue())\n                statement.append(\" AND mi.tags != 0\");\n            else\n                statement.append(\" AND mi.tags = 0\");\n        }\n        \n        num += encode(statement, \"mi.tags\", true, tc.searchTagsets);\n        num += encode(statement, \"mi.flags\", true, tc.searchFlagsets);\n        num += encode(statement, \"unread\", true, tc.unread);\n        num += encode(statement, \"mi.folder_id\", true, c.folders);\n        num += encode(statement, \"mi.folder_id\", false, c.excludeFolders);\n        if (c.convId > 0)\n            num += encode(statement, \"mi.parent_id\", true);\n        else\n            num += encode(statement, \"mi.parent_id\", false, c.prohibitedConvIds);\n        num += encode(statement, \"mi.id\", true, c.itemIds);\n        num += encode(statement, \"mi.id\", false, c.prohibitedItemIds);\n        num += encode(statement, \"mi.index_id\", true, c.indexIds);\n        num += encodeRangeWithMinimum(statement, \"mi.date\", c.dates, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_metadata\", c.modified, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.mod_content\", c.modifiedContent, 1);\n        num += encodeRangeWithMinimum(statement, \"mi.size\", c.sizes, 0);\n        num += encodeRange(statement, \"mi.subject\", c.subjectRanges);\n        num += encodeRange(statement, \"mi.sender\", c.senderRanges);\n        \n        Boolean isSoloPart = node.getSearchConstraints().getIsSoloPart();\n        if (isSoloPart != null) {\n            if (isSoloPart.booleanValue()) {\n                statement.append(\" AND mi.parent_id is NULL \");\n            } else {\n                statement.append(\" AND mi.parent_id is NOT NULL \");\n            }\n        }\n        \n        if (c.hasIndexId != null) {\n            if (c.hasIndexId.booleanValue()) {\n                statement.append(\" AND mi.index_id is NOT NULL \");\n            } else {\n                statement.append(\" AND mi.index_id is NULL \");\n            }\n        }\n        \n        if (inCalTable) {\n            num += encodeRangeWithMinimum(statement, \"ap.start_time\", c.calStartDates, 1);\n            num += encodeRangeWithMinimum(statement, \"ap.end_time\", c.calEndDates, 1);\n        }\n\n        statement.append(')');\n        \n        return num;\n    }\n    \n    /**\n     * @return TRUE if some part of this query has a non-appointment select (ie 'type not in (11,15)' non-null \n     */\n    private static final boolean hasMailItemOnlyConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasMailItemOnlyConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasNonAppointmentTypes();\n    }\n    \n    /**\n     * @return TRUE if this constraint needs to do a join with the Appointment table in order to be evaluated\n     */\n    private static final boolean hasAppointmentTableConstraints(DbSearchConstraintsNode node) {\n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes()) {\n                if (hasAppointmentTableConstraints(subnode))\n                    return true;\n            }\n            return false;\n        }\n        return node.getSearchConstraints().hasAppointmentTableConstraints();\n    }\n    \n    \n    static final byte[] APPOINTMENT_TABLE_TYPES = new byte[] { MailItem.TYPE_APPOINTMENT, MailItem.TYPE_TASK };\n\n    public static List<SearchResult> search(List<SearchResult> result, Connection conn, DbSearchConstraints c,\n                                            Mailbox mbox, SortBy sort, SearchResult.ExtraData extra)\n    throws ServiceException {\n        return search(result, conn, c, mbox, sort, extra, false);\n    }\n    \n    public static List<SearchResult> search(List<SearchResult> result, Connection conn, DbSearchConstraints c,\n            Mailbox mbox, SortBy sort, SearchResult.ExtraData extra, boolean inDumpster)\n    throws ServiceException {\n        return search(result, conn, c, mbox, sort, -1, -1, extra, inDumpster);\n    }\n\n    private static <T> List<T> mergeSortedLists(List<T> toRet, List<List<T>> lists, Comparator<? super T> comparator) {\n        for (List<T> l : lists) {\n            toRet.addAll(l);\n        }\n        \n        Collections.sort(toRet, comparator);\n        \n        return toRet;\n    }\n    \n    private static List<SearchResult> intersectSortedLists(List<SearchResult> toRet, List<List<SearchResult>> lists) {\n        if (lists.size() < 0) {\n            return toRet;\n        }\n        //optimize so shortest list is first\n        Collections.sort(lists, new Comparator<List<SearchResult>>() {\n            @Override\n            public int compare(List<SearchResult> l1, List<SearchResult> l2) {\n                return l1.size() - l2.size();\n            }\n        });\n        \n        for (SearchResult result : lists.get(0)) {\n            boolean intersect = true;\n            for (int i = 1; i < lists.size(); i++) {\n                if (!lists.get(i).contains(result)) {\n                    intersect = false;\n                    break;\n                }\n            }\n            if (intersect) {\n                toRet.add(result);\n            }\n        }\n        return toRet;\n    }\n\n    public static List<SearchResult> search(List<SearchResult> result, Connection conn,\n                                            DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                            int offset, int limit, SearchResult.ExtraData extra, boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        // this monstrosity for bug 31343\n        if (!Db.supports(Db.Capability.AVOID_OR_IN_WHERE_CLAUSE) || NodeType.OR != node.getNodeType()) {\n            // do it the old way\n            try {\n                return searchInternal(result, conn, node, mbox, sort, offset, limit, extra, inDumpster);\n            } catch (ServiceException se) {\n                boolean splitNodes = false;\n                if (Db.supports(Db.Capability.SQL_PARAM_LIMIT) && (NodeType.LEAF != node.getNodeType())) {\n                    Throwable cause = se;\n                    while (cause != null) {\n                        if (cause instanceof SQLException) {\n                            if (Db.errorMatches((SQLException)cause, Db.Error.TOO_MANY_SQL_PARAMS)) {\n                                sLog.debug(\"Query %s resulted in too many sql params; attempting split clauses into individual queries\", node);\n                                splitNodes = true;\n                                break;\n                            }\n                        }\n                        cause = cause.getCause();\n                    }\n                }\n                if (!splitNodes) {\n                    throw se;\n                }\n            }\n        } \n        // if (where a or b) not supported or if we encountered too many sql params try splitting \n        // run each toplevel OR/AND part as a separate SQL query, then merge\n        // the results in memory\n        List<List<SearchResult>> resultLists = new ArrayList<List<SearchResult>>();\n            \n        for (DbSearchConstraintsNode subNode : node.getSubNodes()) {\n            List<SearchResult> subNodeResults = new ArrayList<SearchResult>();\n            search(subNodeResults, conn, subNode, mbox, sort, offset, limit, extra, inDumpster);\n            resultLists.add(subNodeResults);\n        }\n\n        Comparator<SearchResult> comp = SearchResult.getComparator(sort);\n        if (NodeType.OR == node.getNodeType()) {\n            result = mergeSortedLists(result, resultLists, comp);\n        } else if (NodeType.AND == node.getNodeType()) {\n            result = intersectSortedLists(result, resultLists);\n        } else {\n            throw ServiceException.FAILURE(\"Reached merge/intersect block with something other than OR/AND clause\", null);\n        }\n        return result;\n    }\n        \n    public static List<SearchResult> searchInternal(List<SearchResult> result, Connection conn,\n                                                    DbSearchConstraintsNode node, Mailbox mbox, SortBy sort,\n                                                    int offset, int limit, SearchResult.ExtraData extra,\n                                                    boolean inDumpster)\n    throws ServiceException {\n        assert(Db.supports(Db.Capability.ROW_LEVEL_LOCKING) || Thread.holdsLock(mbox));\n\n        boolean hasValidLIMIT = offset >= 0 && limit >= 0;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        StringBuilder statement = new StringBuilder();\n        int numParams = 0;\n        boolean hasMailItemOnlyConstraints = true;\n        boolean hasAppointmentTableConstraints = hasAppointmentTableConstraints(node);\n        if (hasAppointmentTableConstraints)\n            hasMailItemOnlyConstraints = hasMailItemOnlyConstraints(node);\n        boolean requiresUnion = hasMailItemOnlyConstraints && hasAppointmentTableConstraints;\n        \n        try {\n            if (hasMailItemOnlyConstraints) {\n                if (requiresUnion) {\n                    statement.append(\"(\");\n                }\n                \n                /*\n                 * \"SELECT mi.id,mi.date, [extrafields] FROM mail_item AS mi \n                 *    [FORCE INDEX (...)]\n                 *    WHERE mi.mailboxid=? AND\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, false, node, hasValidLIMIT, inDumpster));\n                \n                /*\n                 *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n                 *    ( \n                 *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n                 *       [ AND tags != 0]\n                 *       [ AND tags IN ( ... ) ]\n                 *       [ AND flags IN (...) ] \n                 *       ..etc\n                 *    )   \n                 */\n                numParams += encodeConstraint(mbox, node, \n                    (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), \n                    false, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                }\n            }\n            \n            if (requiresUnion) {\n                /*\n                 * UNION\n                 */\n                statement.append(\" ) UNION ALL (\");\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                /*\n                 * SELECT...again...(this time with \"appointment as ap\")...WHERE...\n                 */\n                statement.append(encodeSelect(mbox, sort, extra, true, node, hasValidLIMIT, inDumpster));\n                numParams += encodeConstraint(mbox, node, APPOINTMENT_TABLE_TYPES, true, statement, conn);\n                \n                if (requiresUnion) {\n                    /*\n                     * ORDER BY (sortField) \n                     */\n                    statement.append(sortQuery(sort, true));\n                    \n                    /*\n                     * LIMIT ?, ? \n                     */\n                    if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                        statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n                    }\n                    \n                    if (requiresUnion) {\n                        statement.append(\")\");\n                    }\n                }\n            }\n            \n            //\n            // TODO FIXME: include COLLATION for sender/subject sort\n            //\n            \n            /*\n             * ORDER BY (sortField) \n             */\n            statement.append(sortQuery(sort, true));\n            \n            /*\n             * LIMIT ?, ? \n             */\n            if (hasValidLIMIT && Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                statement.append(\" LIMIT \").append(offset).append(',').append(limit);\n            }\n\n            /**********************************************************/\n            /* Above here: build statement, below here bind params */\n            /**********************************************************/\n\n            /*\n             * Create the statement and bind all our parameters!\n             */\n            if (sLog.isDebugEnabled())\n                sLog.debug(\"SQL: (\"+numParams+\" parameters): \"+statement.toString());\n            \n            if (Db.supports(Db.Capability.SQL_PARAM_LIMIT)) {\n                Db.getInstance().checkParamLimit(numParams);\n            }\n            long startTime = LC.zimbra_slow_logging_enabled.booleanValue() ? System.currentTimeMillis() : 0;\n            \n            stmt = conn.prepareStatement(statement.toString());\n            int param = 1;\n            \n            \n            if (hasMailItemOnlyConstraints) {\n                param = setSearchVars(stmt, node, param, (hasAppointmentTableConstraints ? APPOINTMENT_TABLE_TYPES : null), false);\n            }\n            \n            if (hasAppointmentTableConstraints) {\n                param = setSearchVars(stmt, node, param, APPOINTMENT_TABLE_TYPES, true);\n            }\n            \n            /*\n             * Limit query if DB doesn't support LIMIT clause\n             */\n            if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE))\n                stmt.setMaxRows(offset + limit + 1);\n\n            long prepTime = startTime > 0 ? System.currentTimeMillis() - startTime : 0;\n            \n            /*\n             * EXECUTE!\n             */\n            assert(param == numParams+1);\n            rs = stmt.executeQuery();\n            \n            long execTime = startTime > 0 ? System.currentTimeMillis() - startTime - prepTime : 0;\n            \n            /*\n             * Return results\n             */\n            while (rs.next()) {\n                if (hasValidLIMIT && !Db.supports(Db.Capability.LIMIT_CLAUSE)) {\n                    if (offset-- > 0)\n                        continue;\n                    if (limit-- <= 0)\n                        break;\n                }\n                result.add(SearchResult.createResult(rs, sort, extra, inDumpster));\n            }\n            \n            long fetchTime = startTime > 0 ? System.currentTimeMillis() - startTime - prepTime - execTime: 0;\n            if (prepTime + execTime + fetchTime > LC.zimbra_slow_logging_threshold.longValue()) {\n                sLog.warn(\"Slow SQL (start=%d prep=%d exec=%d fetch=%d rows=%d):\\n\" + statement.toString(),\n                        startTime, prepTime, execTime, fetchTime, result.size());\n            }\n            \n            return result;\n        } catch (SQLException e) {\n            throw ServiceException.FAILURE(\"fetching search metadata\", e);\n        } finally {\n            DbPool.closeResults(rs);\n            DbPool.closeStatement(stmt);\n        }\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, byte[] c) throws SQLException {\n        if (c != null && c.length > 0) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setBytes(PreparedStatement stmt, int param, Collection<Byte> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (byte b: c)\n                stmt.setByte(param++, b);\n        }\n        return param;\n    }\n\n    private static final int setIntegers(PreparedStatement stmt, int param, Collection<Integer> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (int i: c)\n                stmt.setInt(param++, i);\n        }\n        return param;\n    }\n    \n    private static final int setDateRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.lowest / 1000, Integer.MAX_VALUE)); \n                if (date.highest >= 1)\n                    stmt.setInt(param++, (int) Math.min(date.highest / 1000, Integer.MAX_VALUE));\n            }\n        }\n        return param;\n    }\n\n    private static final int setTimestampRange(PreparedStatement stmt, int param, Collection<NumericRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange date : c) { \n                if (date.lowest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.lowest));\n                if (date.highest >= 1)\n                    stmt.setTimestamp(param++, new Timestamp(date.highest));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setLong(param++, r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setLong(param++, r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setIntRangeWithMinimum(PreparedStatement stmt, int param, Collection<NumericRange> c, int minimum) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (NumericRange r : c) { \n                if (r.lowest >= minimum)\n                    stmt.setInt(param++, (int)r.lowest);\n                if (r.highest >= minimum)\n                    stmt.setInt(param++, (int)r.highest);\n            }\n        }\n        return param;\n    }\n\n    private static final int setStringRange(PreparedStatement stmt, int param, Collection<StringRange> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (StringRange r: c) { \n                if (r.lowest != null) \n                    stmt.setString(param++, r.lowest.replace(\"\\\\\\\"\", \"\\\"\"));\n                if (r.highest != null)\n                    stmt.setString(param++, r.highest.replace(\"\\\\\\\"\", \"\\\"\"));\n            }\n        }\n        return param;\n    }\n\n    private static final int setLongs(PreparedStatement stmt, int param, Collection<Long> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (long l: c)\n                stmt.setLong(param++, l);\n        }\n        return param;\n    }\n\n    private static final int setFolders(PreparedStatement stmt, int param, Collection<Folder> c) throws SQLException {\n        if (!ListUtil.isEmpty(c)) {\n            for (Folder f : c) \n                stmt.setInt(param++, f.getId());\n        }\n        return param;\n    }\n\n    private static final int setBooleanAsInt(PreparedStatement stmt, int param, Boolean b) throws SQLException {\n        if (b != null) {\n            stmt.setInt(param++, b.booleanValue() ? 1 : 0);\n        }\n        return param;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @return number of parameters bound (always 0 in this case)\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness) {\n        statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n        return 1;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param o\n     *            if NULL, this function is a NoOp, otherwise puts ? to bind one value\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Object o) {\n        if (o != null) {\n            statement.append(\" AND \").append(column).append(truthiness ? \" = ?\" : \" != ?\");\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, Collection<?> c) {\n        if (!ListUtil.isEmpty(c)) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.size()));\n            return c.size();\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param truthiness\n     *           if FALSE then sense is reversed (!=) \n     * @param c\n     * @return number of parameters bound\n     */\n    private static final int encode(StringBuilder statement, String column, boolean truthiness, byte[] c) {\n        if (c != null && c.length > 0) {\n            statement.append(\" AND \").append(DbUtil.whereIn(column, truthiness, c.length));\n            return c.length;\n        }\n        return 0;\n    }\n    \n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @param lowestValue\n     * @return number of parameters bound\n     */\n    private static final int encodeRangeWithMinimum(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.NumericRange> ranges, long lowestValue) {\n        if (ListUtil.isEmpty(ranges))\n            return 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column) ) {\n            column = \"UPPER(\"+column+\")\";\n        }\n\n        int params = 0;\n        for (DbSearchConstraints.NumericRange r : ranges) {\n            boolean lowValid = r.lowest >= lowestValue;\n            boolean highValid = r.highest >= lowestValue;\n            if (!(lowValid || highValid))\n                continue;\n\n            statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n            if (lowValid) {\n                if (r.lowestEqual)\n                    statement.append(\" \" + column + \" >= ?\");\n                else\n                    statement.append(\" \" + column + \" > ?\");\n                params++;\n            }\n            if (highValid) {\n                if (lowValid)\n                    statement.append(\" AND\");\n                if (r.highestEqual)\n                    statement.append(\" \" + column + \" <= ?\");\n                else\n                    statement.append(\" \" + column + \" < ?\");\n                params++;\n            }\n            statement.append(')');\n        }\n        return params;\n    }\n\n    /**\n     * @param statement\n     * @param column\n     * @param ranges\n     * @return number of parameters bound\n     */\n    private static final int encodeRange(StringBuilder statement, String column, Collection<? extends DbSearchConstraints.StringRange> ranges) {\n        int retVal = 0;\n        \n        if (Db.supports(Db.Capability.CASE_SENSITIVE_COMPARISON) && isCaseSensitiveField(column)) {\n            column = \"UPPER(\"+column+\")\";\n        }\n        \n        if (!ListUtil.isEmpty(ranges)) {\n            for (DbSearchConstraints.StringRange r : ranges) {\n                statement.append(r.negated ? \" AND NOT (\" : \" AND (\");\n                if (r.lowest != null) {\n                    retVal++;\n                    if (r.lowestEqual)\n                        statement.append(\" \" + column + \" >= ?\");\n                    else\n                        statement.append(\" \" + column + \" > ?\");\n                }\n                if (r.highest != null) {\n                    if (r.lowest != null)\n                        statement.append(\" AND\");\n                    retVal++;\n                    if (r.highestEqual)\n                        statement.append(\" \" + column + \" <= ?\");\n                    else\n                        statement.append(\" \" + column + \" < ?\");\n                }\n                statement.append(')');\n            }\n        }\n        return retVal;\n    }\n\n\n    static class TagConstraints {\n        Set<Long> searchTagsets;\n        Set<Long> searchFlagsets;\n        Boolean unread;\n        boolean noMatches;\n\n        static TagConstraints getTagConstraints(Mailbox mbox, DbSearchConstraints c, Connection conn) throws ServiceException {\n            TagConstraints tc = c.tagConstraints = new TagConstraints();\n            if (ListUtil.isEmpty(c.tags) && ListUtil.isEmpty(c.excludeTags))\n                return tc;\n\n            int setFlagMask = 0;\n            long setTagMask = 0;\n\n            if (!ListUtil.isEmpty(c.tags)) {\n                for (Tag tag : c.tags) {\n                    if (tag.getId() == Flag.ID_FLAG_UNREAD) {\n                        tc.unread = Boolean.TRUE; \n                    } else if (tag instanceof Flag) {\n                        setFlagMask |= tag.getBitmask();\n                    } else {\n                        setTagMask |= tag.getBitmask();\n                    }\n                }\n            }\n\n            int flagMask = setFlagMask;\n            long tagMask = setTagMask;\n\n            if (!ListUtil.isEmpty(c.excludeTags)) {\n                for (Tag tag : c.excludeTags) {\n                    if (tag.getId() == Flag.ID_FLAG_UNREAD) {\n                        if (tc.unread == Boolean.TRUE)\n                            tc.noMatches = true;\n                        tc.unread = Boolean.FALSE;\n                    } else if (tag instanceof Flag) {\n                        if ((setFlagMask & tag.getBitmask()) != 0)\n                            tc.noMatches = true;\n                        flagMask |= tag.getBitmask();\n                    } else {\n                        if ((setTagMask & tag.getBitmask()) != 0)\n                            tc.noMatches = true;\n                        tagMask |= tag.getBitmask();\n                    }\n                }\n            }\n\n            // if we know we have no matches (e.g. \"is:flagged and is:unflagged\"), just stop here...\n            if (tc.noMatches)\n                return tc;\n\n            TagsetCache tcFlags = DbMailItem.getFlagsetCache(conn, mbox);\n            TagsetCache tcTags  = DbMailItem.getTagsetCache(conn, mbox);\n            if (setTagMask != 0 || tagMask != 0) {\n                // note that tcTags.getMatchingTagsets() returns null when *all* tagsets match\n                tc.searchTagsets = tcTags.getMatchingTagsets(tagMask, setTagMask);\n                // if no items match the specified tags...\n                if (tc.searchTagsets != null && tc.searchTagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchTagsets = null; // otherwise we encode \"tags IN()\" which MySQL doesn't like\n                }\n            }\n\n            if (setFlagMask != 0 || flagMask != 0) {\n                // note that tcFlags.getMatchingTagsets() returns null when *all* flagsets match\n                tc.searchFlagsets = tcFlags.getMatchingTagsets(flagMask, setFlagMask);\n                // if no items match the specified flags...\n                if (tc.searchFlagsets != null && tc.searchFlagsets.isEmpty()) {\n                    tc.noMatches = true;\n                    tc.searchFlagsets = null;  // otherwise we encode \"flags IN()\" which MySQL doesn't like\n                }\n            }\n\n            return tc;\n        }\n    }\n    \n    private static int setSearchVars(PreparedStatement stmt, \n        DbSearchConstraintsNode node, int param, \n        byte[] calTypes, boolean inCalTable) throws SQLException {\n        /*\n         *( SUB-NODE AND/OR (SUB-NODE...) ) AND/OR ( SUB-NODE ) AND\n         *    ( \n         *       one of: [type NOT IN (...)]  || [type = ?] || [type IN ( ...)]\n         *       [ AND tags != 0]\n         *       [ AND tags IN ( ... ) ]\n         *       [ AND flags IN (...) ] \n         *       ..etc\n         *    )   \n         */\n        \n        DbSearchConstraintsNode.NodeType ntype = node.getNodeType();\n        if (ntype == DbSearchConstraintsNode.NodeType.AND || ntype == DbSearchConstraintsNode.NodeType.OR) {\n            for (DbSearchConstraintsNode subnode : node.getSubNodes())\n                param = setSearchVars(stmt, subnode, param, calTypes, inCalTable);\n            return param;\n        }\n\n        // we're here, so we must be in a DbSearchConstraints leaf node\n        DbSearchConstraints c = node.getSearchConstraints();\n        assert(ntype == DbSearchConstraintsNode.NodeType.LEAF && c != null);\n        \n        // if there are no possible matches, short-circuit here...\n        if (c.automaticEmptySet() || c.tagConstraints.noMatches)\n            return param;\n\n        param = setBytes(stmt, param, c.types);\n        param = setBytes(stmt, param, c.excludeTypes);\n        param = setBytes(stmt, param, calTypes);\n        \n        param = setLongs(stmt, param, c.tagConstraints.searchTagsets);\n        param = setLongs(stmt, param, c.tagConstraints.searchFlagsets);\n        param = setBooleanAsInt(stmt, param, c.tagConstraints.unread);\n        param = setFolders(stmt, param, c.folders);\n        param = setFolders(stmt, param, c.excludeFolders);\n        if (c.convId > 0)\n            stmt.setInt(param++, c.convId);\n        else\n            param = setIntegers(stmt, param, c.prohibitedConvIds);\n        param = setIntegers(stmt, param, c.itemIds);\n        param = setIntegers(stmt, param, c.prohibitedItemIds);\n        param = setIntegers(stmt, param, c.indexIds);\n        param = setDateRange(stmt, param, c.dates);\n        param = setLongRangeWithMinimum(stmt, param, c.modified, 1);\n        param = setLongRangeWithMinimum(stmt, param, c.modifiedContent, 1);\n        param = setIntRangeWithMinimum(stmt, param, c.sizes, 0);\n        param = setStringRange(stmt, param, c.subjectRanges);\n        param = setStringRange(stmt, param, c.senderRanges);\n        \n        if (inCalTable) {\n            param = setTimestampRange(stmt, param, c.calStartDates);\n            param = setTimestampRange(stmt, param, c.calEndDates);\n        }\n        \n        return param;\n    }\n\n\n    public static void main(String[] args) throws ServiceException {\n        Mailbox mbox = MailboxManager.getInstance().getMailboxById(1);\n\n        DbSearchConstraints hasTags = new DbSearchConstraints();\n        hasTags.hasTags = true;\n\n        DbSearchConstraints inTrash = new DbSearchConstraints();\n        Set<Folder> folders = new HashSet<Folder>();  folders.add(mbox.getFolderById(null, Mailbox.ID_FOLDER_TRASH));\n        inTrash.folders = folders;\n\n        DbSearchConstraints isUnread = new DbSearchConstraints();\n        Set<Tag> tags = new HashSet<Tag>();  tags.add(mbox.getFlagById(Flag.ID_FLAG_UNREAD));\n        isUnread.tags = tags;\n\n        DbSearchConstraintsInnerNode orClause = DbSearchConstraintsInnerNode.OR();\n        orClause.addSubNode(hasTags);\n        DbSearchConstraintsInnerNode andClause = DbSearchConstraintsInnerNode.AND();\n        andClause.addSubNode(inTrash);\n        andClause.addSubNode(isUnread);\n        orClause.addSubNode(andClause);\n\n        // \"is:unread\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), isUnread, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n        // \"has:tags or (in:trash is:unread)\" (first 5 results)\n        //System.out.println(search(new ArrayList<DbSearch.XSearchResult>(), DbPool.getConnection(), orClause, 1, DEFAULT_SORT_ORDER, 0, 5, DbSearch.XSearchResult.ExtraData.NONE));\n    }\n}\n",
    "vulnerability_type": "SQL Injection",
    "repo": "zm-mailbox",
    "commit": "99455af0374ec42e4034680b2c69bf221981355a",
    "commit_msg": "(split)Integrate from ZDESKTOP-721 to HELIX\n\tChange 394702 by dywang@dywang-mac-zd721 on 2012/08/21 14:58:53\n\n       bug: 72299\n\n       Split DB search cononstraints for folders as too many folders\n       involved could hit SQLite's limit on SQLITE_MAX_VARIABLE_NUMBER.\n\nhttp://bugzilla.zimbra.com/show_bug.cgi?id=72299\n\nCopied from Perforce\n Change: 394704",
    "original_file": "DbSearch.java",
    "confidence_score": 0.8
  }
]